# Design 1-1-2 - 后台模式和日志管理（极简版）

## Requirements

### 核心目标
- **后台daemon运行**：程序在后台静默运行，不占用终端
- **日志状态记录**：将监控状态、发现问题写入日志文件供查看
- **生命周期绑定**：Chrome关闭自动停止监控（利用现有connection_lost_callback）
- **PID管理**：自动管理后台进程，Chrome关闭后自动清理

### 技术约束（严格遵守）
- **最小改动**：仅修改`browserfairy/cli.py`，不新增模块
- **零并行管线**：不复制代码，完全复用现有`monitor_comprehensive`
- **向后兼容**：所有现有CLI功能完全不变
- **简单够用**：一次fork()即可，不搞复杂的double fork

## Solution（极简实现 - 专家建议版）

### 改动范围（最小）
- **仅改`browserfairy/cli.py`**：不新增模块、不动核心监控逻辑
- **对`monitor_comprehensive`做两个极简增强**：
  - 增加可选参数：`status_callback`、`exit_event`
  - 如果有`exit_event`：设置`connector.set_connection_lost_callback(lambda: exit_event.set())`，主循环使用`await exit_event.wait()`
  - 如果有`status_callback`：用它替换原来的`print`；否则保留原`print`
- **CLI增加两个参数**：`--daemon`、`--log-file`（可选）
- **daemon实现**：一次`fork()`，父进程退出，子进程写PID、重定向stdout/stderr到`/dev/null`

### 核心实现（极简版）

**1. 修改现有monitor_comprehensive函数（+10行）**

```python
# 在browserfairy/cli.py中修改现有函数
async def monitor_comprehensive(host: str, port: int, duration: Optional[int] = None,
                              status_callback: Optional[Callable] = None,
                              exit_event: Optional[asyncio.Event] = None) -> int:
    """Start comprehensive monitoring - 极简daemon支持版"""
    connector = ChromeConnector(host=host, port=port)
    
    # 新增：设置连接丢失回调
    if exit_event:
        connector.set_connection_lost_callback(lambda: exit_event.set())
    
    try:
        # ... 保持所有现有逻辑不变 ...
        
        # 新增：使用注入的status_callback（如果有的话）
        if not status_callback:
            # 保持原有的print回调
            def status_callback(event_type: str, payload: dict) -> None:
                timestamp_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                if event_type == "console_error":
                    print(f"[{timestamp_str}] CONSOLE_ERROR: {payload.get('level', '')} - {payload.get('message', '')}")
                elif event_type == "large_request":
                    print(f"[{timestamp_str}] LARGE_REQUEST: {payload.get('url', '')} ({payload.get('size_mb', 0):.1f}MB)")
                # ... 保持所有现有print逻辑 ...
        
        # ... 保持所有现有监控启动逻辑不变 ...
        
        # 新增：主循环支持exit_event
        if duration:
            await asyncio.sleep(duration)
        else:
            print("Comprehensive monitoring running... (Press Ctrl+C to stop)")
            try:
                if exit_event:
                    # daemon模式：等待exit_event信号
                    await exit_event.wait()
                else:
                    # 前台模式：保持原有的无限循环
                    while True:
                        await asyncio.sleep(1.0)
            except KeyboardInterrupt:
                print("\nStopping comprehensive monitoring...")
        
        return 0
    
    # ... 保持所有现有异常处理不变 ...
    
    finally:
        # 保持所有现有清理逻辑不变
        try:
            if 'data_manager' in locals():
                await data_manager.stop()
            # ...
        except Exception as e:
            logger.warning(f"Error during cleanup: {e}")
        if connector.websocket:
            await connector.disconnect()
```

**2. CLI增加daemon支持（+30行）**

```python
# 在browserfairy/cli.py的main()函数中增加
async def main() -> None:
    """Main CLI entry point - 极简daemon支持"""
    parser = argparse.ArgumentParser(description="BrowserFairy - Chrome performance monitoring tool")
    
    # 保持所有现有参数不变
    # ...
    
    # 新增daemon参数
    parser.add_argument("--daemon", action="store_true", help="Run comprehensive monitoring in daemon mode (Unix only)")
    parser.add_argument("--log-file", type=str, help="Custom log file path for daemon mode")
    
    args = parser.parse_args()
    setup_logging(args.verbose)
    
    # 保持所有现有分支不变
    # ...
    elif args.monitor_comprehensive:
        if args.daemon:
            # 极简daemon实现
            if os.name != 'posix':
                print("Daemon mode not supported on Windows, running in foreground...")
                exit_code = await monitor_comprehensive(args.host, args.port, args.duration)
            else:
                exit_code = await run_daemon_comprehensive(args.host, args.port, args.duration, args.log_file)
        else:
            # 前台模式：调用原函数（新参数为None，保持兼容）
            exit_code = await monitor_comprehensive(args.host, args.port, args.duration)
        sys.exit(exit_code)
    # ...

async def run_daemon_comprehensive(host: str, port: int, duration: Optional[int] = None, 
                                  log_file: Optional[str] = None) -> int:
    """极简daemon包装器"""
    import atexit
    
    # 设置文件路径
    data_dir = ensure_data_directory()
    pid_file = os.path.join(data_dir, "monitor.pid")
    if not log_file:
        log_file = os.path.join(data_dir, "monitor.log")
    
    # 一次fork即可
    pid = os.fork()
    if pid > 0:
        # 父进程：显示信息后退出
        print("BrowserFairy daemon starting...")
        print(f"Monitor log: {log_file}")
        print("Close Chrome browser to stop monitoring.")
        sys.exit(0)
    
    # 子进程：daemon化
    os.setsid()
    os.chdir('/')
    os.umask(0)
    
    # 重定向stdio到/dev/null
    with open('/dev/null', 'r') as dev_null_r, open('/dev/null', 'w') as dev_null_w:
        os.dup2(dev_null_r.fileno(), sys.stdin.fileno())
        os.dup2(dev_null_w.fileno(), sys.stdout.fileno())
        os.dup2(dev_null_w.fileno(), sys.stderr.fileno())
    
    # 写PID文件
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))
    
    # 注册清理函数
    def cleanup():
        try:
            if os.path.exists(pid_file):
                os.remove(pid_file)
        except:
            pass
    atexit.register(cleanup)
    
    # 极简日志回调（写文件）
    def log_status(event_type: str, payload: dict) -> None:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = f"[{timestamp}] {event_type}: {payload}\n"
        try:
            with open(log_file, "a", encoding="utf-8") as f:
                f.write(message)
        except:
            pass  # daemon模式忽略写入错误
    
    # 创建退出事件
    exit_event = asyncio.Event()
    
    # 调用修改后的monitor_comprehensive
    return await monitor_comprehensive(
        host=host, 
        port=port, 
        duration=duration,
        status_callback=log_status,
        exit_event=exit_event
    )
```

## 实现特点（极简优势）

### 代码改动量（最小）
- `monitor_comprehensive`：+10-15行（两个参数、一次set回调、一个await分支）
- CLI主函数：+30行（daemon参数解析、fork()、PID管理、日志回调）
- **总计：约50行代码**，无新增模块

### 如何满足4个目标
1. **后台daemon**：一次`fork()`即可，父进程退出，子进程静默运行
2. **日志状态记录**：10行不到的`log_status`回调，追加到log文件
3. **生命周期绑定**：`connection_lost_callback -> exit_event.set()`，Chrome断开即优雅退出
4. **PID管理**：子进程写PID到`~/BrowserFairyData/monitor.pid`，`atexit`清理

### 零复杂度设计
- ✅ **零并行管线**：daemon和前台使用完全相同的监控代码
- ✅ **零新类/模块**：所有功能都在cli.py中实现
- ✅ **零破坏性**：现有功能完全不变
- ✅ **零过度设计**：最简实现，够用就行

## Tests（极简验证）

### 功能测试
```bash
# 前台模式（完全不变）
python -m browserfairy --monitor-comprehensive

# 后台daemon模式（新功能）
python -m browserfairy --monitor-comprehensive --daemon

# 自定义日志文件
python -m browserfairy --monitor-comprehensive --daemon --log-file /tmp/monitor.log

# 验证daemon状态
cat ~/BrowserFairyData/monitor.log

# 手动停止daemon（如需要）
kill $(cat ~/BrowserFairyData/monitor.pid)
```

### 验证指标
- ✅ **daemon正常运行**：父进程退出，子进程在后台运行
- ✅ **日志正确写入**：重要事件写入log文件，不输出到终端
- ✅ **Chrome关闭自动退出**：连接断开后5秒内daemon自动退出
- ✅ **PID文件管理**：daemon运行时PID文件存在，退出后自动清理
- ✅ **向后兼容**：所有现有CLI命令功能完全不变

## 极简总结

这个设计遵循"能跑起来为主"的原则：
- **改动最小**：只在cli.py加50行代码
- **功能完整**：满足所有4个核心目标  
- **零复杂度**：没有多余的类、模块、设计模式
- **生产可用**：包含必要的错误处理和清理逻辑

专家建议是对的 - 简单直接的方案往往是最好的方案。