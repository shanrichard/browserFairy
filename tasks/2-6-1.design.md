# Design 2-6-1

## Requirements

- **核心需求**：添加参数允许主动收集所有Source Map，而不仅仅在异常时才收集
- **用户痛点**：当前只在异常发生时才下载Source Map，可能会错过一些未被捕获的异常
- **向后兼容**：保持现有功能不变，新功能通过可选参数启用
- **性能考虑**：主动收集会增加网络请求和存储，需要适当的限流机制

## Solution

### 1. SourceMapResolver类增强 - 最小改动原则

**修改构造函数** - 添加persist_all参数：
```python
def __init__(self, connector, max_cache_size: int = 10, persist_all: bool = False):
    # ... existing code ...
    self.persist_all = persist_all  # 新增：是否主动持久化所有source maps
    self.download_semaphore = asyncio.Semaphore(3)  # 新增：限制并发下载数
```

**修改_on_script_parsed方法** - 在第113行后添加主动下载逻辑：
```python
async def _on_script_parsed(self, params: dict) -> None:
    """监听脚本解析事件，收集sourceMapURL"""
    if params.get("sessionId") != self.session_id:
        return
        
    script_id = params.get("scriptId")
    source_map_url = params.get("sourceMapURL")
    url = params.get("url")
    
    if script_id and url:
        self.script_metadata[script_id] = {
            "url": url,
            "sourceMapURL": source_map_url
        }
        if source_map_url:
            logger.debug(f"Found source map for {url}: {source_map_url}")
            
            # 新增：如果启用了persist_all，主动下载并持久化
            if self.persist_all and self.hostname:
                # 使用create_task避免阻塞事件处理
                asyncio.create_task(self._proactive_persist(script_id, url, source_map_url))
```

**新增_proactive_persist方法**：
```python
async def _proactive_persist(self, script_id: str, script_url: str, source_map_url: str) -> None:
    """主动下载并持久化source map（不等待异常）"""
    async with self.download_semaphore:  # 限流
        try:
            # 复用现有的_get_source_map方法
            source_map = await self._get_source_map(script_url, source_map_url, script_id)
            if source_map:
                logger.debug(f"Proactively persisted source map for {script_url}")
        except Exception as e:
            logger.warning(f"Failed to proactively persist source map for {script_url}: {e}")
```

### 2. ConsoleMonitor传递参数 - 零侵入修改

**修改ConsoleMonitor构造函数** - 添加persist_all_source_maps参数：
```python
def __init__(self, connector: ChromeConnector, session_id: str,
             event_queue: asyncio.Queue, status_callback: Optional[Callable] = None,
             enable_source_map: bool = False, persist_all_source_maps: bool = False):
    # ... existing code ...
    self.persist_all_source_maps = persist_all_source_maps  # 新增参数
```

**修改start_monitoring方法第47行**：
```python
if self.enable_source_map:
    try:
        from ..analysis.source_map import SourceMapResolver
        self.source_map_resolver = SourceMapResolver(
            self.connector, 
            persist_all=self.persist_all_source_maps  # 传递新参数
        )
        # ... rest of existing code ...
```

### 3. MemoryCollector传递参数

**修改构造函数** - 添加persist_all_source_maps参数：
```python
def __init__(self, connector: ChromeConnector, target_id: str, hostname: str,
             data_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
             enable_comprehensive: bool = False,
             status_callback: Optional[Callable] = None,
             enable_source_map: bool = False,
             persist_all_source_maps: bool = False):  # 新增参数
    # ... existing code ...
    self.persist_all_source_maps = persist_all_source_maps
```

**修改_enable_comprehensive_monitoring方法第710行**：
```python
self.console_monitor = ConsoleMonitor(
    self.connector,
    self.session_id,
    self.event_queue,
    self.status_callback,
    enable_source_map=self.enable_source_map,
    persist_all_source_maps=self.persist_all_source_maps  # 传递新参数
)
```

### 4. CLI参数添加 - 用户接口

**在cli.py添加命令行参数**（第1259行附近）：
```python
parser.add_argument(
    "--persist-all-source-maps",
    action="store_true",
    help="Persist all source maps immediately when scripts are parsed (requires --enable-source-map)"
)
```

**修改所有监控函数签名**，添加persist_all_source_maps参数：
- monitor_comprehensive
- monitor_single_site  
- start_monitoring_service
- 相关的daemon函数

**参数传递链**：
CLI args → monitor函数 → MemoryCollector → ConsoleMonitor → SourceMapResolver

### 5. 优化细节

- **并发控制**：使用Semaphore(3)限制同时下载的source map数量
- **错误处理**：主动下载失败不影响正常监控流程
- **日志级别**：主动下载使用debug级别，失败使用warning级别
- **缓存复用**：主动下载的source map会被缓存，异常时可直接使用

## Tests

### 1. 单元测试 - SourceMapResolver

**test_source_map_proactive.py**：
```python
async def test_persist_all_disabled_by_default():
    """测试默认不启用主动持久化"""
    resolver = SourceMapResolver(mock_connector)
    assert resolver.persist_all is False

async def test_persist_all_enabled():
    """测试启用主动持久化"""
    resolver = SourceMapResolver(mock_connector, persist_all=True)
    assert resolver.persist_all is True
    
async def test_proactive_persist_triggered():
    """测试scriptParsed事件触发主动持久化"""
    resolver = SourceMapResolver(mock_connector, persist_all=True)
    resolver.set_hostname("test.com")
    await resolver.initialize("session123")
    
    # 模拟scriptParsed事件
    await resolver._on_script_parsed({
        "sessionId": "session123",
        "scriptId": "script1",
        "url": "https://test.com/app.js",
        "sourceMapURL": "app.js.map"
    })
    
    # 等待异步任务
    await asyncio.sleep(0.1)
    
    # 验证source map被下载和保存
    # Check file system for persisted files

async def test_download_semaphore_limits_concurrency():
    """测试并发下载限制"""
    # 验证Semaphore正确限制并发数
```

### 2. 集成测试 - ConsoleMonitor

**test_console_persist_all.py**：
```python
async def test_console_monitor_passes_persist_all():
    """测试ConsoleMonitor正确传递persist_all参数"""
    monitor = ConsoleMonitor(
        connector, session_id, queue,
        enable_source_map=True,
        persist_all_source_maps=True
    )
    await monitor.start_monitoring()
    
    assert monitor.source_map_resolver.persist_all is True
```

### 3. 端到端测试 - CLI

**test_cli_persist_all.py**：
```python
async def test_cli_persist_all_source_maps():
    """测试CLI参数正确传递到SourceMapResolver"""
    # 模拟运行：browserfairy --monitor-comprehensive --enable-source-map --persist-all-source-maps
    # 验证参数传递链完整
```

### 4. 性能测试

**test_performance_persist_all.py**：
```python
async def test_persist_all_performance_impact():
    """测试主动持久化的性能影响"""
    # 模拟100个脚本同时解析
    # 验证Semaphore限流有效
    # 测量总耗时和内存占用
```

### 5. 回归测试

**test_backward_compatibility.py**：
```python
async def test_existing_functionality_unchanged():
    """测试现有功能不受影响"""
    # 不启用persist_all时，行为应与之前完全一致
    # 只在异常时才下载source map
```

## 实现顺序（TDD）

1. 先写测试用例（特别是test_persist_all_disabled_by_default）
2. 修改SourceMapResolver添加persist_all参数（让测试通过）
3. 实现_proactive_persist方法
4. 修改_on_script_parsed添加主动下载逻辑
5. 逐层向上传递参数（ConsoleMonitor → MemoryCollector → CLI）
6. 运行集成测试验证端到端功能
7. 性能测试确保不会过度消耗资源