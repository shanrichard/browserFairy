# Design 2-5: Claude Code SDK集成 - AI智能分析功能

## Requirements

### 背景与目标
- **问题**：BrowserFairy收集的监控数据量大（JSONL格式），直接读取分析困难，不同场景需要不同的分析程序
- **解决方案**：集成Claude Code SDK，利用AI能力动态生成分析代码，智能诊断性能问题
- **核心价值**：将BrowserFairy从"数据收集工具"升级为"智能性能诊断平台"

### 功能需求

1. **SDK集成**
   - 集成claude-code-sdk作为默认依赖
   - 支持Python 3.10+环境
   - 检测Node.js 18+环境（SDK运行时依赖）
     - 使用subprocess.run检测node版本
     - 版本不满足时提供清晰的升级指引
     - 缺失Node.js时降级到基础分析功能
   - 自动检测ANTHROPIC_API_KEY环境变量

2. **AI分析器组件**
   - PerformanceAnalyzer类：封装Claude Code SDK调用
   - 支持指定session目录进行分析
   - 支持不同分析焦点（内存泄漏、性能瓶颈、网络问题等）
   - 自定义系统提示词，专门训练为浏览器性能分析专家

3. **CLI命令接口**
   - 新增命令：`--analyze-with-ai [session_dir]`
   - 支持焦点参数（可选）：`--focus [memory_leak|performance|network|errors|general]`
     - 默认值：`general`（综合分析）
   - 支持自定义prompt（可选）：`--custom-prompt "your specific analysis request"`
   - 所有参数均为可选，支持零配置使用

4. **分析能力**
   - 自动处理大量JSONL数据文件
   - 识别内存泄漏源（结合HeapProfiler数据和源代码）
   - 源代码级问题定位（利用source_maps和sources目录）
   - 发现性能瓶颈和异常模式
   - 生成包含代码片段的精确分析报告
   - 输出可操作的代码级优化建议

5. **用户体验**
   - 流式输出分析进度
   - 保存分析历史和结果
   - 支持中断和恢复分析
   - 清晰的错误提示和引导

### 技术需求

1. **认证机制**
   - 用户自行提供ANTHROPIC_API_KEY
   - 不在代码中硬编码任何密钥
   - 提供清晰的配置指南文档
   - 支持.env文件配置（可选）

2. **权限控制**
   - Claude Code仅获得Read权限读取数据文件
   - Write权限用于生成报告
   - Bash权限用于运行分析脚本
   - 可配置auto_approve模式

3. **错误处理**
   - 优雅处理API Key缺失
   - 处理Node.js缺失或版本不兼容
     - 检测失败时提示安装/升级
     - 自动降级到--analyze-sites基础分析
   - 处理SDK依赖缺失
   - 处理API调用限制和错误
   - 提供降级方案（基础统计分析）

4. **性能优化**
   - 支持增量分析（仅分析新数据）
   - 缓存分析结果避免重复调用
   - 合理的提示词工程减少token消耗
   - 支持本地分析脚本复用

### 非功能需求

1. **可用性**
   - AI分析功能默认集成，开箱即用
   - 当API Key未配置时，提供友好的配置引导
   - 保留基础统计分析功能作为降级方案

2. **安全性**
   - 不存储或传输用户API Key
   - 数据不离开用户本地环境
   - 分析过程完全透明可审计

3. **成本控制**
   - 用户自行承担API调用费用
   - 提供预估token使用量功能
   - 支持设置分析预算限制

4. **文档完善**
   - 详细的配置指南
   - API Key获取教程
   - 常见问题解答
   - 分析案例和最佳实践

## Solution

### 1. 模块架构设计

```
browserfairy/
├── analysis/
│   ├── __init__.py
│   ├── correlation.py      # 现有：关联分析
│   ├── source_map.py       # 现有：源码映射
│   └── ai_analyzer.py      # 新增：AI分析器
├── cli.py                  # 集成点：新增--analyze-with-ai命令
└── data/
    └── site_manager.py     # 复用：获取session路径
```

### 2. Prompt工程设计

#### 默认综合分析Prompt（无参数时使用）
```python
DEFAULT_SYSTEM_PROMPT = """
你是一个浏览器性能分析专家。你需要分析Chrome监控数据来帮助开发者定位和解决性能问题。

重要原则：
1. 不要直接读取整个JSONL文件（可能有几百MB）
2. 使用Python标准库进行流式处理和统计分析
3. 发现问题后才定点读取相关记录
4. 必要时在源代码中搜索问题根源

分析方法：
1. 先统计 - 用代码统计分析，不是直接读文件
2. 找模式 - 识别异常模式和高频问题
3. 深入查 - 对关键问题定点分析
4. 给建议 - 提供可操作的优化方案

可用工具：
- Python标准库（json, collections, statistics, datetime等）
- Bash命令执行Python脚本
- Grep搜索特定模式
- Read定点查看文件片段（不要读整个文件）

数据文件说明：
- memory.jsonl: 内存使用时序数据，每行一条记录
- heap_sampling.jsonl: 内存分配采样，包含函数级统计
- console.jsonl: 控制台日志，包含错误和警告
- network.jsonl: 网络请求生命周期数据
- gc.jsonl: 垃圾回收事件
- longtask.jsonl: 长任务（>50ms）记录
- source_maps/: Source Map文件和元数据（2-6已实现）
- sources/: 提取的源代码文件（2-6已实现）
"""

DEFAULT_ANALYSIS_PROMPT = """
请编写Python代码来分析监控数据，不要直接读取全部文件内容。

分析策略：
1. 先了解数据规模和结构
   - 检查文件大小和数量
   - 采样查看数据格式（只读几行示例）
   - 检查source_maps/和sources/目录，了解有哪些源代码可用

2. 编写高效的统计分析代码
   - 使用流式处理遍历大文件
   - 提取关键指标和统计信息
   - 识别异常模式和问题

3. 对发现的问题进行深入分析
   - 定点读取相关的详细记录
   - 利用source_maps/metadata.jsonl找到对应的源文件
   - 在sources/目录中查看具体的源代码实现
   - 结合错误堆栈和源码定位问题根源

4. 生成分析报告
   - 总结主要发现
   - 提供具体案例（包含源码片段）
   - 给出精确的优化建议

请根据实际数据情况，灵活选择合适的分析方法和工具。
记住：用代码分析，不要试图一次性读取整个文件到内存。
"""
```

#### 焦点分析Prompts
```python
FOCUS_PROMPTS = {
    "general": DEFAULT_ANALYSIS_PROMPT,  # 默认综合分析
    
    "memory_leak": """
        专注于内存泄漏分析，结合源代码深度诊断：
        
        1. 分析heap_sampling.jsonl中的内存分配数据
           - 统计哪些函数分配了最多内存
           - 识别持续增长的分配模式
           - 注意使用流式处理，不要一次性加载整个文件
           
        2. 源代码级内存泄漏定位
           - 根据heap_sampling中的函数名，在sources/目录查找对应源代码
           - 分析高内存占用函数的具体实现
           - 识别潜在的内存泄漏模式：
             * 未清理的事件监听器
             * 闭包引用的大对象
             * 循环引用
             * 未销毁的定时器
           
        3. 内存增长趋势与代码关联
           - 分析memory.jsonl中的JS Heap增长率
           - 关联DOM节点数增长与具体的组件代码
           - 检查事件监听器泄漏的代码位置
           
        4. 提供源码级优化建议
           - 基于具体代码给出内存优化方案
           - 指出需要添加的清理逻辑
           - 推荐内存管理最佳实践
    """,
    
    "performance": """
        专注于性能瓶颈分析：
        
        1. 分析longtask.jsonl中的长任务数据
           - 统计长任务的数量、持续时间分布
           - 识别最耗时的操作类型
           - 找出频繁出现的长任务模式
           
        2. 分析gc.jsonl中的垃圾回收情况
           - 计算GC频率和总耗时
           - 识别内存压力大的时段
           - 分析GC与性能问题的关联
           
        3. 综合性能指标分析
           - 检查脚本执行时间
           - 分析布局和样式重计算
           - 识别主线程阻塞情况
           
        4. 提供性能优化建议
           - 基于发现的瓶颈提出改进方案
           - 推荐代码分割、异步处理等策略
    """,
    
    "network": """
        专注于网络性能分析：
        
        1. 分析network.jsonl中的请求数据
           - 统计请求成功率、失败原因
           - 计算响应时间分布（P50/P95/P99）
           - 识别慢接口和超时请求
           
        2. 资源加载性能分析
           - 找出大文件传输（如>500KB的资源）
           - 检测重复请求和无效请求
           - 分析请求并发情况
           
        3. API性能深入分析
           - 对慢接口进行详细分析
           - 检查错误率变化趋势
           - 分析网络瀑布图模式
           
        4. 提供网络优化建议
           - 基于分析结果推荐CDN、缓存策略
           - 建议请求合并或分片方案
    """,
    
    "errors": """
        专注于错误和异常分析，充分利用源代码：
        
        1. 分析console.jsonl中的错误日志
           - 统计错误类型、级别和频率
           - 识别高频错误消息
           - 提取错误堆栈中的文件位置和行号
           
        2. 源代码级别的错误定位
           - 读取source_maps/metadata.jsonl找到scriptId映射
           - 在sources/目录中查看出错代码的具体实现
           - 分析错误发生的代码上下文
           - 识别代码模式问题（如未处理的Promise、空值检查等）
           
        3. 错误根因分析
           - 结合堆栈信息和源码，精确定位问题
           - 分析错误传播路径
           - 检查相关联的组件和模块
           
        4. 提供精准的修复建议
           - 基于源码给出具体的代码修改建议
           - 指出需要添加的错误处理
           - 推荐防御性编程实践
    """
}
```


### 3. 实现架构

```python
# browserfairy/analysis/ai_analyzer.py
import os
import asyncio
import subprocess
from pathlib import Path
from typing import Optional, Tuple
from claude_code_sdk import query, ClaudeCodeOptions

class PerformanceAnalyzer:
    def __init__(self, session_dir: Path):
        self.session_dir = session_dir
        self.api_key_available = self.check_api_key()
        self.node_available, self.node_version = self.check_nodejs()
        
    def check_api_key(self) -> bool:
        """检查API Key配置"""
        if not os.getenv("ANTHROPIC_API_KEY"):
            print("⚠️  AI分析功能需要配置 ANTHROPIC_API_KEY")
            print("   1. 访问 https://console.anthropic.com 注册账号")
            print("   2. 获取API Key")
            print("   3. 设置环境变量：export ANTHROPIC_API_KEY='your-key-here'")
            print("\n   您仍可以使用 --analyze-sites 进行基础数据分析")
            return False
        return True
    
    def check_nodejs(self) -> Tuple[bool, str]:
        """检查Node.js环境"""
        try:
            result = subprocess.run(
                ['node', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                version = result.stdout.strip()  # 格式如 v18.12.0
                major_version = int(version.split('.')[0][1:])  # 提取主版本号
                if major_version >= 18:
                    return True, version
                else:
                    print(f"⚠️  Node.js版本过低: {version}")
                    print("   需要Node.js 18或更高版本")
                    print("   请升级Node.js: https://nodejs.org/")
                    return False, version
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception) as e:
            print("⚠️  未检测到Node.js环境")
            print("   Claude Code SDK需要Node.js 18+")
            print("   请安装Node.js: https://nodejs.org/")
            return False, ""
        
        return False, ""
    
    def build_prompt(self, 
                    focus: str = "general") -> tuple[str, str]:
        """构建系统提示词和分析提示词
        
        Returns:
            (system_prompt, analysis_prompt)
        """
        # 基础系统提示词
        system_prompt = DEFAULT_SYSTEM_PROMPT
        
        # 获取焦点分析提示词
        analysis_prompt = FOCUS_PROMPTS.get(focus, DEFAULT_ANALYSIS_PROMPT)
        
        return system_prompt, analysis_prompt
    
    async def analyze(self,
                     focus: str = "general", 
                     custom_prompt: str = None):
        """执行AI分析"""
        
        # 检查前置条件
        if not self.api_key_available:
            print("\n无法使用AI分析，缺少API Key")
            print("提示：可以使用 --analyze-sites 进行基础数据分析")
            return False
            
        if not self.node_available:
            print("\n无法使用AI分析，Node.js环境不满足要求")
            print("提示：可以使用 --analyze-sites 进行基础数据分析")
            return False
        
        # 构建prompt
        if custom_prompt:
            # 自定义模式
            system_prompt = DEFAULT_SYSTEM_PROMPT
            analysis_prompt = custom_prompt
        else:
            # 预设模式
            system_prompt, analysis_prompt = self.build_prompt(focus)
        
        # 添加数据目录上下文
        full_prompt = f"""
        监控数据目录：{self.session_dir}
        
        {analysis_prompt}
        """
        
        options = ClaudeCodeOptions(
            system_prompt=system_prompt,
            working_directory=str(self.session_dir),
            allowed_tools=["Read", "Write", "Bash"],
            auto_approve_file_writes=True
        )
        
        async for message in query(full_prompt, options=options):
            if hasattr(message, 'result'):
                print(message.result)
```

### 4. CLI集成设计

```python
# cli.py 新增analyze_with_ai函数
async def analyze_with_ai(session_dir: Optional[str] = None,
                          focus: str = "general",
                          custom_prompt: Optional[str] = None) -> int:
    """使用AI分析监控数据"""
    from .analysis.ai_analyzer import PerformanceAnalyzer
    from .data.site_manager import SiteDataManager
    
    try:
        # 确定要分析的session目录
        if not session_dir:
            # 不指定时，使用最新的session
            manager = SiteDataManager()
            sessions = manager.get_all_sessions()
            if not sessions:
                print("没有找到监控数据。请先运行监控命令收集数据。")
                return 1
            # 获取最新session（按时间排序）
            session_dir = str(sorted(sessions)[-1])
        else:
            # 处理用户提供的路径
            session_path = Path(session_dir).expanduser()
            if not session_path.exists():
                print(f"错误：指定的session目录不存在: {session_path}")
                return 1
            session_dir = str(session_path)
        
        print(f"分析session: {Path(session_dir).name}")
        print("启动AI分析器...")
        
        # 创建分析器并执行分析
        analyzer = PerformanceAnalyzer(Path(session_dir))
        
        # 检查前置条件
        if not analyzer.api_key_available or not analyzer.node_available:
            print("\nAI分析功能暂不可用，请参考上述提示配置环境")
            return 1
            
        # 执行分析
        result = await analyzer.analyze(focus=focus, custom_prompt=custom_prompt)
        if not result:
            return 1
            
        return 0
        
    except KeyboardInterrupt:
        print("\n分析被用户中断")
        return 0
    except Exception as e:
        print(f"AI分析失败: {e}", file=sys.stderr)
        return 1

# cli.py main函数中的参数定义
parser.add_argument(
    "--analyze-with-ai",
    type=str,
    nargs="?",
    const="",  # 不带参数时使用最新session
    help="使用AI分析监控数据（默认分析最新session）"
)

parser.add_argument(
    "--focus",
    type=str,
    choices=["general", "memory_leak", "performance", "network", "errors"],
    default="general",
    help="分析焦点（默认：general综合分析）"
)

parser.add_argument(
    "--custom-prompt",
    type=str,
    help="自定义分析需求（替代预设的分析焦点）"
)

# main函数中添加处理逻辑
if args.analyze_with_ai is not None:
    session_dir = args.analyze_with_ai if args.analyze_with_ai else None
    exit_code = await analyze_with_ai(
        session_dir=session_dir,
        focus=args.focus,
        custom_prompt=args.custom_prompt
    )
    sys.exit(exit_code)
```

### 5. 使用示例

```bash
# 默认综合分析（最常用）
python -m browserfairy --analyze-with-ai

# 分析特定session
python -m browserfairy --analyze-with-ai ~/BrowserFairyData/session_2025-08-16_143022

# 专注于内存泄漏分析
python -m browserfairy --analyze-with-ai --focus memory_leak

# 自定义分析需求
python -m browserfairy --analyze-with-ai --custom-prompt "只分析最近1小时的数据，重点看network.jsonl中失败的请求"
```

## Tests

### 1. 单元测试

```python
# tests/test_ai_analyzer.py
import pytest
import asyncio
from pathlib import Path
from unittest.mock import Mock, patch, AsyncMock
from browserfairy.analysis.ai_analyzer import PerformanceAnalyzer


class TestPerformanceAnalyzer:
    """PerformanceAnalyzer单元测试"""
    
    @pytest.fixture
    def temp_session_dir(self, tmp_path):
        """创建临时session目录结构"""
        session_dir = tmp_path / "session_2025-08-20_100000"
        session_dir.mkdir()
        
        # 创建模拟数据文件
        site_dir = session_dir / "example.com"
        site_dir.mkdir()
        
        # 写入模拟JSONL数据
        memory_file = site_dir / "memory.jsonl"
        memory_file.write_text('{"type":"memory","timestamp":"2025-08-20T10:00:00","memory":{"jsHeap":{"used":10485760}}}\n')
        
        return session_dir
    
    def test_init_with_valid_dir(self, temp_session_dir):
        """测试使用有效目录初始化"""
        analyzer = PerformanceAnalyzer(temp_session_dir)
        assert analyzer.session_dir == temp_session_dir
    
    def test_init_with_invalid_dir(self, tmp_path):
        """测试使用无效目录初始化"""
        invalid_dir = tmp_path / "non_existent"
        with pytest.raises(FileNotFoundError):
            PerformanceAnalyzer(invalid_dir)
    
    @patch.dict('os.environ', {}, clear=True)
    def test_check_api_key_missing(self, temp_session_dir, capsys):
        """测试API Key缺失时的提示"""
        analyzer = PerformanceAnalyzer(temp_session_dir)
        assert analyzer.api_key_available == False
        
        captured = capsys.readouterr()
        assert "ANTHROPIC_API_KEY" in captured.out
        assert "https://console.anthropic.com" in captured.out
    
    @patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'})
    @patch('subprocess.run')
    def test_check_api_key_present(self, mock_run, temp_session_dir):
        """测试API Key存在时的检查"""
        # 模拟Node.js 18+
        mock_run.return_value.returncode = 0
        mock_run.return_value.stdout = 'v18.12.0'
        
        analyzer = PerformanceAnalyzer(temp_session_dir)
        assert analyzer.api_key_available == True
    
    @patch('subprocess.run')
    def test_check_nodejs_present(self, mock_run, temp_session_dir):
        """测试Node.js检测 - 版本满足要求"""
        mock_run.return_value.returncode = 0
        mock_run.return_value.stdout = 'v20.11.0'
        
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            assert analyzer.node_available == True
            assert analyzer.node_version == 'v20.11.0'
    
    @patch('subprocess.run')
    def test_check_nodejs_version_too_low(self, mock_run, temp_session_dir, capsys):
        """测试Node.js检测 - 版本过低"""
        mock_run.return_value.returncode = 0
        mock_run.return_value.stdout = 'v16.14.0'
        
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            assert analyzer.node_available == False
            
            captured = capsys.readouterr()
            assert "版本过低" in captured.out
            assert "v16.14.0" in captured.out
    
    @patch('subprocess.run', side_effect=FileNotFoundError)
    def test_check_nodejs_not_installed(self, mock_run, temp_session_dir, capsys):
        """测试Node.js检测 - 未安装"""
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            assert analyzer.node_available == False
            
            captured = capsys.readouterr()
            assert "未检测到Node.js" in captured.out
    
    def test_build_prompt_default(self, temp_session_dir):
        """测试默认prompt构建"""
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            system_prompt, analysis_prompt = analyzer.build_prompt()
            
            assert "浏览器性能分析专家" in system_prompt
            assert "综合分析" in analysis_prompt
    
    def test_build_prompt_memory_focus(self, temp_session_dir):
        """测试内存焦点prompt构建"""
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            system_prompt, analysis_prompt = analyzer.build_prompt(focus="memory_leak")
            
            assert "浏览器性能分析专家" in system_prompt
            assert "heap_sampling.jsonl" in analysis_prompt
            assert "内存泄漏" in analysis_prompt
    
    @pytest.mark.asyncio
    @patch('browserfairy.analysis.ai_analyzer.query')
    async def test_analyze_with_default_params(self, mock_query, temp_session_dir):
        """测试默认参数分析"""
        # 模拟query返回
        mock_message = Mock()
        mock_message.result = "分析完成：发现3个问题"
        mock_query.return_value = AsyncMock()
        mock_query.return_value.__aiter__.return_value = [mock_message]
        
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            await analyzer.analyze()
            
            # 验证query被调用
            mock_query.assert_called_once()
            call_args = mock_query.call_args
            assert str(temp_session_dir) in call_args[0][0]  # prompt包含目录
    
    @pytest.mark.asyncio
    @patch('browserfairy.analysis.ai_analyzer.query')
    async def test_analyze_with_custom_prompt(self, mock_query, temp_session_dir):
        """测试自定义prompt分析"""
        mock_message = Mock()
        mock_message.result = "自定义分析结果"
        mock_query.return_value = AsyncMock()
        mock_query.return_value.__aiter__.return_value = [mock_message]
        
        with patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'}):
            analyzer = PerformanceAnalyzer(temp_session_dir)
            await analyzer.analyze(custom_prompt="只分析内存数据")
            
            # 验证使用了自定义prompt
            call_args = mock_query.call_args
            assert "只分析内存数据" in call_args[0][0]
```

### 2. 集成测试

```python
# tests/test_cli_ai_integration.py
import pytest
import asyncio
from pathlib import Path
from unittest.mock import patch, AsyncMock
from browserfairy.cli import analyze_with_ai


class TestCLIAIIntegration:
    """CLI AI分析集成测试"""
    
    @pytest.fixture
    def mock_session_structure(self, tmp_path):
        """创建模拟的完整session结构"""
        data_dir = tmp_path / "BrowserFairyData"
        data_dir.mkdir()
        
        session1 = data_dir / "session_2025-08-19_100000"
        session1.mkdir()
        
        session2 = data_dir / "session_2025-08-20_100000"  # 更新的session
        session2.mkdir()
        
        # 在新session中创建数据
        site_dir = session2 / "example.com"
        site_dir.mkdir()
        (site_dir / "memory.jsonl").write_text('{"type":"memory"}\n')
        
        return data_dir, session2
    
    @pytest.mark.asyncio
    @patch('browserfairy.cli.SiteDataManager')
    @patch('browserfairy.analysis.ai_analyzer.query')
    @patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'})
    async def test_analyze_latest_session(self, mock_query, mock_manager, mock_session_structure):
        """测试分析最新session"""
        data_dir, latest_session = mock_session_structure
        
        # 模拟SiteDataManager返回sessions
        mock_manager.return_value.get_all_sessions.return_value = [
            data_dir / "session_2025-08-19_100000",
            latest_session
        ]
        
        # 模拟query返回
        mock_message = Mock()
        mock_message.result = "分析结果"
        mock_query.return_value = AsyncMock()
        mock_query.return_value.__aiter__.return_value = [mock_message]
        
        # 执行分析
        result = await analyze_with_ai()
        
        assert result == 0
        mock_query.assert_called_once()
    
    @pytest.mark.asyncio
    @patch('browserfairy.analysis.ai_analyzer.query')
    @patch.dict('os.environ', {'ANTHROPIC_API_KEY': 'test-key'})
    async def test_analyze_specific_session(self, mock_query, mock_session_structure):
        """测试分析指定session"""
        data_dir, session_dir = mock_session_structure
        
        # 模拟query返回
        mock_message = Mock()
        mock_message.result = "分析结果"
        mock_query.return_value = AsyncMock()
        mock_query.return_value.__aiter__.return_value = [mock_message]
        
        # 分析指定目录
        result = await analyze_with_ai(session_dir=str(session_dir))
        
        assert result == 0
        call_args = mock_query.call_args
        assert str(session_dir) in call_args[0][0]
    
    @pytest.mark.asyncio
    @patch.dict('os.environ', {}, clear=True)
    async def test_analyze_without_api_key(self, mock_session_structure, capsys):
        """测试无API Key时的处理"""
        data_dir, session_dir = mock_session_structure
        
        result = await analyze_with_ai(session_dir=str(session_dir))
        
        assert result == 1
        captured = capsys.readouterr()
        assert "ANTHROPIC_API_KEY" in captured.out
```

### 3. 端到端测试（手动验证）

```bash
# 1. 环境准备测试
export ANTHROPIC_API_KEY="your-test-key"
python -m browserfairy --analyze-with-ai --help

# 2. 无数据时的错误处理
python -m browserfairy --analyze-with-ai
# 预期：提示没有找到监控数据

# 3. 模拟数据分析测试
# 先收集一些数据
python -m browserfairy --monitor-comprehensive --duration 30
# 然后分析
python -m browserfairy --analyze-with-ai

# 4. 焦点分析测试
python -m browserfairy --analyze-with-ai --focus memory_leak

# 5. 自定义prompt测试
python -m browserfairy --analyze-with-ai --custom-prompt "只统计错误数量"

# 6. 指定session测试
python -m browserfairy --analyze-with-ai ~/BrowserFairyData/session_2025-08-20_100000

# 7. 中断处理测试（启动后按Ctrl+C）
python -m browserfairy --analyze-with-ai
# 按Ctrl+C，预期：优雅退出
```

### 4. 性能测试要求

- AI分析响应时间应在30秒内开始输出第一条结果
- 支持分析至少100MB的JSONL数据文件
- 内存使用不应超过500MB（不包括Claude SDK本身）