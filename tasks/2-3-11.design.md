# Design 2-3-11 - å®ç°é•¿ä»»åŠ¡æ£€æµ‹

## Requirements

åŸºäºæŠ€æœ¯ä¸“å®¶è¯„å®¡å’Œç”¨æˆ·åé¦ˆï¼Œå®ç°é•¿ä»»åŠ¡æ£€æµ‹åŠŸèƒ½ä»¥å®šä½é¡µé¢å¡é¡¿æ ¹å› ã€‚

### æ ¸å¿ƒé—®é¢˜

å¼€å‘åŒäº‹åœ¨å®é™…ä½¿ç”¨ä¸­åé¦ˆçš„å…³é”®ç—›ç‚¹ï¼š
- **ä¸»çº¿ç¨‹é˜»å¡æ— æ³•è¿½è¸ª**ï¼šé¡µé¢å¡é¡¿æ—¶æ— æ³•ç¡®å®šæ˜¯å“ªä¸ªJavaScriptä»»åŠ¡é˜»å¡äº†>50ms
- **å¡é¡¿æ ¹å› éš¾å®šä½**ï¼šçŸ¥é“é¡µé¢å¡é¡¿ä½†ä¸çŸ¥é“å…·ä½“å‡½æ•°æˆ–æ“ä½œå¯¼è‡´
- **æ€§èƒ½ç›‘æ§æ•°æ®ä¸å®Œæ•´**ï¼šç°æœ‰MemoryCollectoråªèƒ½çœ‹å†…å­˜ï¼Œæ— æ³•çœ‹æ‰§è¡Œé˜»å¡

### æŠ€æœ¯ä¸“å®¶è¯„å®¡ç»“è®º

**éœ€æ±‚2 - é•¿ä»»åŠ¡æ£€æµ‹**çš„æŠ€æœ¯å¯è¡Œæ€§åˆ†æï¼š
- **æŠ€æœ¯è·¯çº¿è°ƒæ•´**ï¼šä½¿ç”¨`PerformanceObserver('longtask')`æ³¨å…¥æ–¹æ¡ˆ
- **åŸæ–¹æ¡ˆä¸å¯è¡Œ**ï¼š`Performance.metrics`æ— æ³•è·å–é•¿ä»»åŠ¡è¯¦æƒ…
- **è°ƒç”¨æ ˆé™åˆ¶**ï¼šå…ˆè®°å½•scriptURLå’Œframeï¼Œè°ƒç”¨æ ˆè·å–æœ‰æŠ€æœ¯é™åˆ¶
- **å®ç°å¤æ‚åº¦**ï¼šä¸­ç­‰ï¼Œéœ€è¦å¤„ç†CSPç­‰å¤æ‚æ€§

### åŠŸèƒ½éœ€æ±‚

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
1. æ£€æµ‹>50msçš„JavaScriptæ‰§è¡Œä»»åŠ¡
2. è®°å½•é•¿ä»»åŠ¡çš„åŸºæœ¬ä¿¡æ¯ï¼ˆæŒç»­æ—¶é—´ã€å¼€å§‹æ—¶é—´ã€ç±»å‹ï¼‰
3. è®°å½•æ‰§è¡Œæºå¤´ä¿¡æ¯ï¼ˆscriptURLã€frameç­‰å¯è·å–çš„ä¿¡æ¯ï¼‰
4. æŒ‰ç½‘ç«™ç»´åº¦ç»„ç»‡æ•°æ®ï¼Œé›†æˆåˆ°ç°æœ‰æ•°æ®æµ

**æ•°æ®è¦æ±‚**ï¼š
- æ—¶é—´æˆ³ï¼šä»»åŠ¡å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´
- æŒç»­æ—¶é—´ï¼šä»»åŠ¡æ‰§è¡Œè€—æ—¶ï¼ˆ>50msçš„è®°å½•ï¼‰
- æºå¤´ä¿¡æ¯ï¼šè„šæœ¬URLã€å¸§ä¿¡æ¯ï¼ˆåœ¨æŠ€æœ¯é™åˆ¶å†…å°½å¯èƒ½å¤šï¼‰
- ä»»åŠ¡ç±»å‹ï¼šå¦‚æœèƒ½è·å–åˆ°ä»»åŠ¡ç±»å‹ä¿¡æ¯

**æ€§èƒ½è¦æ±‚**ï¼š
- æ³¨å…¥è„šæœ¬ä¸å½±å“é¡µé¢æ­£å¸¸æ‰§è¡Œ
- ç›‘æ§å¼€é”€æ§åˆ¶åœ¨å¯æ¥å—èŒƒå›´å†…
- å¤„ç†CSPï¼ˆå†…å®¹å®‰å…¨æ”¿ç­–ï¼‰é™åˆ¶
- æ”¯æŒå¤šæ ‡ç­¾é¡µç‹¬ç«‹ç›‘æ§

**é›†æˆè¦æ±‚**ï¼š
- é›†æˆåˆ°ç°æœ‰MemoryCollectorçš„ç»¼åˆç›‘æ§æ¨¡å¼
- é€šè¿‡event_queueæœºåˆ¶ä¸å…¶ä»–ç›‘æ§å™¨åä½œ
- æ•°æ®é€šè¿‡DataManagerå†™å…¥ï¼ŒæŒ‰ç½‘ç«™ç»´åº¦å­˜å‚¨
- æ”¯æŒç°æœ‰çš„é¢‘ç‡æ§åˆ¶å’Œä¼˜é›…é™çº§æœºåˆ¶

### æŠ€æœ¯çº¦æŸ

**æŠ€æœ¯é™åˆ¶**ï¼š
1. **CSPé™åˆ¶**ï¼šæŸäº›ç½‘ç«™çš„å†…å®¹å®‰å…¨æ”¿ç­–å¯èƒ½é˜»æ­¢è„šæœ¬æ³¨å…¥
2. **è°ƒç”¨æ ˆè·å–é™åˆ¶**ï¼šå®Œæ•´è°ƒç”¨æ ˆè·å–å¯èƒ½æœ‰é™åˆ¶ï¼Œå…ˆå®ç°åŸºç¡€ä¿¡æ¯
3. **æ€§èƒ½å½±å“**ï¼šPerformanceObserveræœ¬èº«éœ€è¦æ¶ˆè€—èµ„æº
4. **å…¼å®¹æ€§**ï¼šéœ€è¦ç¡®ä¿åœ¨ä¸åŒChromeç‰ˆæœ¬ä¸‹å·¥ä½œ

**è®¾è®¡åŸåˆ™**ï¼š
1. **ä¼˜é›…é™çº§**ï¼šå¦‚æœæ³¨å…¥å¤±è´¥ï¼Œä¸å½±å“å…¶ä»–ç›‘æ§åŠŸèƒ½
2. **é¢‘ç‡æ§åˆ¶**ï¼šé¿å…é•¿ä»»åŠ¡äº‹ä»¶è¿‡å¤šå¯¼è‡´æ•°æ®æ´ªæµ
3. **åŸå§‹æ•°æ®å¯¼å‘**ï¼šä¸“æ³¨æ•°æ®æ”¶é›†ï¼Œåˆ†æç•™ç»™åç»­AIå·¥å…·
4. **å‘ä¸‹å…¼å®¹**ï¼šä¸å½±å“ç°æœ‰75%å·²å®ŒæˆåŠŸèƒ½çš„ç¨³å®šæ€§

### é¢„æœŸä»·å€¼

**è¯Šæ–­ä»·å€¼**ï¼š
- ç›´æ¥å®šä½é¡µé¢å¡é¡¿çš„æ ¹æœ¬åŸå› 
- å‘ç°å“ªä¸ªJavaScriptå‡½æ•°/æ“ä½œå¯¼è‡´ä¸»çº¿ç¨‹é˜»å¡
- å®é™…æ¡ˆä¾‹ï¼šç”µå•†é¡µé¢å›¾ç‰‡åŠ è½½å¤„ç†å‡½æ•°æ‰§è¡Œ280mså¯¼è‡´æ»šåŠ¨å¡é¡¿
- ä¸å¯æ›¿ä»£æ€§ï¼šæ— å…¶ä»–æ–¹å¼èƒ½ç²¾ç¡®å®šä½é•¿ä»»åŠ¡

**åº”ç”¨åœºæ™¯**ï¼š
- ä¼ä¸šçº§Webåº”ç”¨æ€§èƒ½è¯Šæ–­
- ä»ªè¡¨æ¿é¡µé¢å¡é¡¿åˆ†æ
- äº¤æ˜“ç³»ç»Ÿå“åº”å»¶è¿Ÿé—®é¢˜å®šä½
- å¤æ‚SPAåº”ç”¨çš„æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

## Solution

### æŠ€æœ¯æ–¹æ¡ˆæ¦‚è¿°

**æ ¸å¿ƒç­–ç•¥**ï¼šé€šè¿‡Runtime.evaluateæ³¨å…¥PerformanceObserverè„šæœ¬ï¼Œé›†æˆåˆ°ç°æœ‰MemoryCollectorçš„ç»¼åˆç›‘æ§æ¶æ„ä¸­ï¼Œå€Ÿé‰´NetworkMonitorçš„æˆç†Ÿè°ƒç”¨æ ˆå¤„ç†ç»éªŒã€‚

### è¯¦ç»†å®ç°è®¾è®¡

#### 1. é›†æˆç‚¹è®¾è®¡

**åœ¨MemoryCollectorä¸­æ·»åŠ é•¿ä»»åŠ¡ç›‘æ§**ï¼š
```python
# browserfairy/monitors/memory.py - MemoryCollectorç±»æ‰©å±•
# ğŸ”§ ä¿®æ­£ï¼šæ·»åŠ ç¼ºå¤±çš„æ ‡å‡†åº“å¯¼å…¥ï¼ˆåœ¨ç°æœ‰å¯¼å…¥åŒºåŸŸï¼‰
import re    # æ–°å¢å¯¼å…¥ï¼Œç”¨äºè°ƒç”¨æ ˆè§£æ
import time  # æ–°å¢å¯¼å…¥ï¼Œç”¨äºé¢‘ç‡æ§åˆ¶
# æ³¨æ„ï¼šjsonæ¨¡å—å·²å­˜åœ¨ï¼Œmake_event_idå‡½æ•°å®Œå…¨æ”¯æŒè®¾è®¡ä¸­çš„å‚æ•°ç»„åˆ

class MemoryCollector:
    def __init__(self, connector: ChromeConnector, target_id: str, hostname: str,
                 data_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
                 enable_comprehensive: bool = False,
                 status_callback: Optional[Callable] = None):
        # ç°æœ‰ä»£ç ä¿æŒä¸å˜
        ...
        # ğŸ”§ ä¿®æ­£ï¼šåœ¨__init__ä¸­æ­£ç¡®åˆå§‹åŒ–é•¿ä»»åŠ¡ç›‘æ§å±æ€§
        self.longtask_observer_injected = False
        self.longtask_callback_registered = False
        self._longtask_timestamps = []  # é¢‘ç‡æ§åˆ¶æ—¶é—´æˆ³
```

**é›†æˆåˆ°ç°æœ‰_enable_comprehensive_monitoring()æ–¹æ³•**ï¼š
```python
async def _enable_comprehensive_monitoring(self):
    """ç°æœ‰æ–¹æ³•æ‰©å±• - æ·»åŠ é•¿ä»»åŠ¡ç›‘æ§"""
    # ç°æœ‰ä»£ç ï¼šRuntime.enableå·²ç»è°ƒç”¨ï¼Œç›´æ¥å¤ç”¨
    # await self.connector.call("Runtime.enable", session_id=self.session_id)
    # ç°æœ‰ä»£ç ï¼ševent_queueå·²åˆ›å»ºï¼Œnetwork_monitorç­‰å·²åˆå§‹åŒ–
    ...
    
    # æ–°å¢ï¼šé•¿ä»»åŠ¡ç›‘æ§æ³¨å…¥ï¼ˆåœ¨æ‰€æœ‰Monitoråˆå§‹åŒ–ä¹‹åï¼‰
    await self._inject_longtask_observer()
```

#### 2. PerformanceObserveræ³¨å…¥å®ç°

**æ³¨å…¥è„šæœ¬è®¾è®¡**ï¼ˆä¿®æ­£å…³é”®é—®é¢˜ï¼‰ï¼š
```javascript
// æ³¨å…¥åˆ°é¡µé¢çš„PerformanceObserverè„šæœ¬ï¼ˆå…¼å®¹æ€§+payloadä¿®æ­£ï¼‰
if ('PerformanceObserver' in window) {
    try {
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'longtask' && entry.duration >= 50) {
                    const taskData = {
                        timestamp: Date.now(),
                        startTime: entry.startTime,
                        duration: entry.duration,
                        name: entry.name || 'unknown',
                        // ä¼˜å…ˆé‡‡é›†å½’å› ä¿¡æ¯ï¼ˆæ›´æœ‰ä»·å€¼ï¼‰
                        attribution: entry.attribution?.map(attr => ({
                            containerType: attr.containerType || 'unknown',
                            containerName: attr.containerName || '',
                            containerSrc: (attr.containerSrc || '').slice(0, 200)
                        }))?.slice(0, 5) || [],
                        // å¤‡é€‰è°ƒç”¨æ ˆï¼ˆä»…åœ¨æ— å½’å› ä¿¡æ¯æ—¶é‡‡é›†ï¼‰
                        stack: entry.attribution?.length ? null : (() => {
                            try {
                                return new Error().stack;
                            } catch (e) {
                                return null;
                            }
                        })()
                    };
                    
                    // ğŸ”§ å…³é”®ä¿®æ­£ï¼šå¿…é¡»JSON.stringifyï¼Œå¦åˆ™payloadå˜æˆ"[object Object]"
                    if (window.__browserFairyLongtaskCallback) {
                        window.__browserFairyLongtaskCallback(JSON.stringify(taskData));
                    }
                }
            }
        });
        
        // ğŸ”§ buffered:true èƒ½è¡¥æŠ“æ³¨å…¥å‰çš„é•¿ä»»åŠ¡
        observer.observe({entryTypes: ['longtask'], buffered: true});
    } catch (e) {
        // ä¼˜é›…é™çº§ï¼šæ³¨å…¥é”™è¯¯ä¸å½±å“é¡µé¢
        console.debug('BrowserFairy longtask observer injection failed:', e);
    }
}
```

**æ³¨å…¥æ–¹æ³•å®ç°**ï¼ˆä¿®æ­£å¯¼èˆªæŒä¹…æ€§é—®é¢˜ï¼‰ï¼š
```python
async def _inject_longtask_observer(self) -> None:
    """æ³¨å…¥PerformanceObserveré•¿ä»»åŠ¡ç›‘æ§ï¼ˆä¿®æ­£å¯¼èˆªæŒä¹…æ€§ï¼‰"""
    try:
        # 1. å…ˆæ³¨å†ŒCDPå›è°ƒå¤„ç†å™¨
        await self._register_longtask_callback()
        
        # 2. æ„å»ºæ³¨å…¥è„šæœ¬
        injection_script = self._build_longtask_observer_script()
        
        # ğŸ”§ å…³é”®ä¿®æ­£ï¼šä¼˜å…ˆä½¿ç”¨Page.addScriptToEvaluateOnNewDocumentç¡®ä¿å¯¼èˆªæŒä¹…æ€§
        try:
            await self.connector.call(
                "Page.enable",
                session_id=self.session_id,
                timeout=5.0
            )
            await self.connector.call(
                "Page.addScriptToEvaluateOnNewDocument",
                {"source": injection_script},
                session_id=self.session_id,
                timeout=10.0
            )
            logger.debug("Long task observer added via addScriptToEvaluateOnNewDocument")
        except Exception as e:
            logger.debug(f"Page.addScriptToEvaluateOnNewDocument failed: {e}")
        
        # 3. å…¼å®¹æ€§å…œåº•ï¼šRuntime.evaluateæ³¨å…¥ä¸€æ¬¡ï¼ˆå½“å‰é¡µé¢ç«‹å³ç”Ÿæ•ˆï¼‰
        await self.connector.call(
            "Runtime.evaluate",
            {
                "expression": injection_script,
                "returnByValue": False
            },
            session_id=self.session_id,
            timeout=10.0
        )
        
        self.longtask_observer_injected = True
        logger.info(f"Long task observer injected for session {self.session_id}")
        
    except Exception as e:
        logger.warning(f"Failed to inject longtask observer: {e}")
        # ä¼˜é›…é™çº§ï¼šä¸å½±å“å…¶ä»–ç›‘æ§åŠŸèƒ½
        self.longtask_observer_injected = False

def _build_longtask_observer_script(self) -> str:
    """æ„å»ºé•¿ä»»åŠ¡ç›‘æ§æ³¨å…¥è„šæœ¬"""
    # æ³¨æ„ï¼šæ§åˆ¶è„šæœ¬å¤§å° <1.5KB
    script = '''
if ('PerformanceObserver' in window && !window.__browserFairyLongtaskObserverInstalled) {
    try {
        window.__browserFairyLongtaskObserverInstalled = true;
        const observer = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            let processed = 0;
            for (const entry of entries) {
                if (entry.entryType === 'longtask' && entry.duration >= 50) {
                    // é™åˆ¶bufferedäº‹ä»¶å¤„ç†æ•°é‡
                    if (++processed > 50) break;
                    
                    const taskData = {
                        timestamp: Date.now(),
                        startTime: entry.startTime,
                        duration: entry.duration,
                        name: entry.name || 'unknown',
                        attribution: entry.attribution?.map(attr => ({
                            containerType: attr.containerType || 'unknown',
                            containerName: attr.containerName || '',
                            containerSrc: (attr.containerSrc || '').slice(0, 200)
                        }))?.slice(0, 5) || [],
                        stack: entry.attribution?.length ? null : (() => {
                            try { return new Error().stack; } catch (e) { return null; }
                        })()
                    };
                    
                    if (window.__browserFairyLongtaskCallback) {
                        window.__browserFairyLongtaskCallback(JSON.stringify(taskData));
                    }
                }
            }
        });
        observer.observe({entryTypes: ['longtask'], buffered: true});
    } catch (e) {
        console.debug('BrowserFairy longtask observer injection failed:', e);
    }
}
'''
    return script
```

#### 3. æ•°æ®å›è°ƒå’Œå¤„ç†æœºåˆ¶

**æ³¨å†ŒRuntimeæ¶ˆæ¯å›è°ƒ**ï¼ˆå¤ç”¨ç°æœ‰Runtime.enableï¼‰ï¼š
```python
async def _register_longtask_callback(self) -> None:
    """æ³¨å†Œé•¿ä»»åŠ¡æ•°æ®å›è°ƒ"""
    try:
        # Runtime.enableåœ¨_enable_comprehensive_monitoring()ä¸­å·²è°ƒç”¨ï¼Œç›´æ¥å¤ç”¨
        
        # æ³¨å†Œå…¨å±€å›è°ƒå‡½æ•°
        await self.connector.call(
            "Runtime.addBinding",
            {"name": "__browserFairyLongtaskCallback"},
            session_id=self.session_id
        )
        
        # ç›‘å¬bindingCalledäº‹ä»¶
        self.connector.on_event("Runtime.bindingCalled", self._on_longtask_data)
        self.longtask_callback_registered = True
        
    except Exception as e:
        logger.warning(f"Failed to register longtask callback: {e}")
```

**é•¿ä»»åŠ¡æ•°æ®å¤„ç†**ï¼ˆä¿®æ­£äº‹ä»¶å­—æ®µä¸€è‡´æ€§ï¼‰ï¼š
```python
async def _on_longtask_data(self, params: dict) -> None:
    """å¤„ç†é•¿ä»»åŠ¡æ•°æ®å›è°ƒ"""
    # sessionIdè¿‡æ»¤
    if params.get("sessionId") != self.session_id:
        return
        
    if params.get("name") != "__browserFairyLongtaskCallback":
        return
        
    try:
        # ğŸ”§ ä¿®æ­£ï¼šJSONè§£æï¼ˆç°åœ¨payloadæ˜¯æ­£ç¡®çš„JSONå­—ç¬¦ä¸²ï¼‰
        task_data = json.loads(params.get("payload", "{}"))
        
        # ğŸ”§ ä¿®æ­£ï¼šæ„å»ºæ ‡å‡†äº‹ä»¶æ ¼å¼ï¼Œæ·»åŠ å¿…è¦å­—æ®µ
        longtask_event = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "type": "longtask",
            # ğŸ”§ äº‹ä»¶å­—æ®µä¸€è‡´æ€§ï¼šæ·»åŠ sessionId/targetId
            "sessionId": self.session_id,
            "targetId": self.target_id,
            # ğŸ”§ å¢å¼ºevent_idç”Ÿæˆ
            "event_id": make_event_id(
                "longtask", 
                self.hostname, 
                task_data.get("timestamp", ""),
                str(task_data.get("duration", 0)),
                self.current_url[:50],
                str(task_data.get("startTime", 0))
            ),
            "hostname": self.hostname,
            "url": self.current_url,
            "title": self.current_title,
            # é•¿ä»»åŠ¡æ ¸å¿ƒæ•°æ®
            "duration": task_data.get("duration", 0),
            "startTime": task_data.get("startTime", 0),
            "name": task_data.get("name", "unknown"),
            # ğŸ”§ ä¼˜å…ˆå¤„ç†attributionï¼Œå¤‡é€‰stack
            "attribution": task_data.get("attribution", []),
            "stack": self._process_longtask_stack(task_data.get("stack")) if task_data.get("stack") else None
        }
        
        # ğŸ”§ ä¿®æ­£ï¼šé¢‘ç‡æ§åˆ¶è°ƒæ•´ä¸º20 eps
        if self._should_emit_longtask_event():
            self.event_queue.put_nowait(("longtask", longtask_event))
            
    except Exception as e:
        logger.warning(f"Error processing longtask data: {e}")
```

#### 4. è°ƒç”¨æ ˆå¤„ç†

**å€Ÿé‰´NetworkMonitorçš„è°ƒç”¨æ ˆå¤„ç†**ï¼š
```python
def _process_longtask_stack(self, raw_stack: str) -> dict:
    """å¤„ç†é•¿ä»»åŠ¡è°ƒç”¨æ ˆï¼ˆå€Ÿé‰´NetworkMonitorç»éªŒï¼‰"""
    if not raw_stack:
        return {"available": False, "reason": "no_stack"}
        
    try:
        # è§£æError().stackæ ¼å¼çš„è°ƒç”¨æ ˆ
        lines = raw_stack.strip().split('\n')
        frames = []
        
        for line in lines[1:31]:  # è·³è¿‡Errorè¡Œï¼Œæœ€å¤š30å¸§
            frame = self._parse_stack_line(line.strip())
            if frame:
                frames.append(frame)
                
        return {
            "available": True,
            "frames": frames,
            "truncated": len(lines) > 31,
            "source": "Error().stack"
        }
        
    except Exception as e:
        logger.debug(f"Failed to process longtask stack: {e}")
        return {"available": False, "reason": f"parse_error: {str(e)}"}

def _parse_stack_line(self, line: str) -> Optional[dict]:
    """è§£æå•è¡Œè°ƒç”¨æ ˆ"""
    # è§£ææ ¼å¼ï¼šat functionName (url:line:column)
    # æˆ–ï¼šat url:line:column
    # æ³¨æ„ï¼šreæ¨¡å—å·²åœ¨æ–‡ä»¶é¡¶éƒ¨å¯¼å…¥
    
    patterns = [
        r'at\s+(\w+)\s+\(([^:]+):(\d+):(\d+)\)',  # at func (url:line:col)
        r'at\s+([^:]+):(\d+):(\d+)'               # at url:line:col
    ]
    
    for pattern in patterns:
        match = re.match(pattern, line)
        if match:
            if len(match.groups()) == 4:
                return {
                    "functionName": match.group(1)[:150],
                    "url": match.group(2)[:300],
                    "lineNumber": int(match.group(3)),
                    "columnNumber": int(match.group(4))
                }
            elif len(match.groups()) == 3:
                return {
                    "functionName": "anonymous",
                    "url": match.group(1)[:300],
                    "lineNumber": int(match.group(2)),
                    "columnNumber": int(match.group(3))
                }
                
    return None
```

#### 5. é¢‘ç‡æ§åˆ¶å’Œæ€§èƒ½ä¿æŠ¤

```python
def _should_emit_longtask_event(self) -> bool:
    """é•¿ä»»åŠ¡äº‹ä»¶é¢‘ç‡æ§åˆ¶ï¼ˆè°ƒæ•´ä¸º20 epsï¼‰"""
    current_time = time.time()
    
    # æ¸…ç†1ç§’å‰çš„è®°å½•
    if not hasattr(self, '_longtask_timestamps'):
        self._longtask_timestamps = []
    
    self._longtask_timestamps = [
        ts for ts in self._longtask_timestamps
        if current_time - ts < 1.0
    ]
    
    # ğŸ”§ ä¿®æ­£ï¼šæ¯ç§’æœ€å¤š20ä¸ªé•¿ä»»åŠ¡äº‹ä»¶ï¼ˆæé«˜é‡‡æ ·ç‡ï¼‰
    LONGTASK_RATE_LIMIT = 20  # å¯é…ç½®å¸¸é‡
    if len(self._longtask_timestamps) >= LONGTASK_RATE_LIMIT:
        return False
        
    self._longtask_timestamps.append(current_time)
    return True
```

#### 6. CSPå’Œé”™è¯¯å¤„ç†

**ä¼˜é›…é™çº§ç­–ç•¥**ï¼š
```python
async def _inject_longtask_observer(self) -> None:
    """æ³¨å…¥PerformanceObserveré•¿ä»»åŠ¡ç›‘æ§ï¼ˆåˆå¹¶CSPå¤„ç†é€»è¾‘ï¼‰"""
    try:
        # 1. å…ˆæ³¨å†ŒCDPå›è°ƒå¤„ç†å™¨
        await self._register_longtask_callback()
        
        # 2. æ„å»ºæ³¨å…¥è„šæœ¬
        injection_script = self._build_longtask_observer_script()
        
        # 3. ğŸ”§ ä¿®æ­£ï¼šä¼˜å…ˆä½¿ç”¨Page.addScriptToEvaluateOnNewDocumentç¡®ä¿å¯¼èˆªæŒä¹…æ€§
        try:
            await self.connector.call(
                "Page.enable",
                session_id=self.session_id,
                timeout=5.0
            )
            await self.connector.call(
                "Page.addScriptToEvaluateOnNewDocument",
                {"source": injection_script},
                session_id=self.session_id,
                timeout=10.0
            )
            logger.debug("Long task observer added via addScriptToEvaluateOnNewDocument")
        except Exception as e:
            logger.debug(f"Page.addScriptToEvaluateOnNewDocument failed: {e}")
        
        # 4. å…¼å®¹æ€§å…œåº•ï¼šRuntime.evaluateæ³¨å…¥ä¸€æ¬¡ï¼ˆå½“å‰é¡µé¢ç«‹å³ç”Ÿæ•ˆï¼‰
        await self.connector.call(
            "Runtime.evaluate",
            {
                "expression": injection_script,
                "returnByValue": False
            },
            session_id=self.session_id,
            timeout=10.0
        )
        
        self.longtask_observer_injected = True
        logger.info(f"Long task observer injected for session {self.session_id}")
        
    except Exception as e:
        # ğŸ”§ ä¿®æ­£ï¼šä¸åšè„†å¼±çš„CSPå­—ç¬¦ä¸²åŒ¹é…ï¼Œç»Ÿä¸€è®°å½•å¤±è´¥åŸå› 
        logger.warning(f"Failed to inject longtask observer: {e}")
        self._record_injection_limitation(str(e)[:200])  # æˆªæ–­é”™è¯¯ä¿¡æ¯
        self.longtask_observer_injected = False

def _record_injection_limitation(self, error_message: str) -> None:
    """è®°å½•æ³¨å…¥å¤±è´¥æƒ…å†µï¼ˆä¸åšè„†å¼±çš„CSPåˆ¤æ–­ï¼‰"""
    limitation_event = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "type": "longtask_limitation",
        "event_id": make_event_id("longtask_injection_failed", self.hostname),
        "hostname": self.hostname,
        "reason": f"injection_failed: {error_message}",  # ğŸ”§ ä¿®æ­£ï¼šè®°å½•å®é™…é”™è¯¯ä¿¡æ¯
        "url": self.current_url
    }
    
    try:
        self.event_queue.put_nowait(("longtask_limitation", limitation_event))
    except:
        pass  # ä¸å½±å“ä¸»æµç¨‹
```

#### 7. æ•°æ®å­˜å‚¨é›†æˆ

**ğŸ”§ ä¿®æ­£ï¼šé›†æˆåˆ°CLI comprehensive_data_callbackè·¯ç”±**ï¼š
```python
# åœ¨browserfairy/cli.pyçš„comprehensive_data_callbackä¸­æ·»åŠ è·¯ç”±
async def comprehensive_data_callback(data_manager, data: dict):
    """Unified data routing callback - single exit point for comprehensive monitoring."""
    hostname = data.get("hostname", "unknown")
    data_type = data.get("type", "unknown")
    
    logger.debug(f"comprehensive_data_callback: type={data_type}, hostname={hostname}")
    
    try:
        if data_type == "memory":
            await data_manager.write_memory_data(hostname, data)
        elif data_type in ["console", "exception"]:
            await data_manager.write_console_data(hostname, data)
        elif data_type in ["network_request_complete", "network_request_failed", "network_request_start"]:
            await data_manager.write_network_data(hostname, data)
        # ğŸ”§ æ–°å¢ï¼šé•¿ä»»åŠ¡æ•°æ®è·¯ç”±
        elif data_type == "longtask":
            await data_manager.write_longtask_data(hostname, data)
        elif data_type == "longtask_limitation":
            await data_manager.write_longtask_data(hostname, data)  # åŒä¸€æ–‡ä»¶
        # å…¶ä»–ç°æœ‰è·¯ç”±...
        else:
            logger.warning(f"Unknown data type: {data_type}")
    except Exception as e:
        logger.error(f"Error writing {data_type} data: {e}")
```

**åœ¨DataManagerä¸­æ·»åŠ write_longtask_dataæ–¹æ³•**ï¼š
```python
# ğŸ”§ ä¿®æ­£ï¼šåœ¨browserfairy/data/manager.pyä¸­æ·»åŠ ï¼Œä½¿ç”¨æ­£ç¡®çš„å†™å…¥æ¥å£
async def write_longtask_data(self, hostname: str, data: dict):
    """å†™å…¥é•¿ä»»åŠ¡æ•°æ®ï¼ˆä¿®æ­£ï¼šä½¿ç”¨æ­£ç¡®çš„DataManageræ¥å£ï¼‰"""
    if not self.running:
        return
    # ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ç°æœ‰çš„data_writer.append_jsonlæ¨¡å¼ï¼Œä¸è¦å¼•å…¥self.writers
    file_path = f"{hostname}/longtask.jsonl"
    await self.data_writer.append_jsonl(file_path, data)

# ğŸ”§ ä¿®æ­£ï¼šåœ¨ç°æœ‰_create_session_overviewæ–¹æ³•ä¸­æ·»åŠ æè¿°
async def _create_session_overview(self):
    """Create session overview file with data type descriptions."""
    overview = {
        "session_start": datetime.now().isoformat(),
        "session_dir": str(self.session_dir),
        "data_types": {  # ğŸ”§ ä¿®æ­£ï¼šä¿æŒç°æœ‰é”®ådata_typesï¼Œä¸æ˜¯dataTypes
            "memory.jsonl": "Memory usage metrics per hostname",
            "console.jsonl": "Console logs and exceptions per hostname", 
            "network.jsonl": "Network request details per hostname",
            "gc.jsonl": "Garbage collection events per hostname",
            "storage.jsonl": "DOM storage events per hostname",
            "correlations.jsonl": "Event correlation analysis per hostname",
            "longtask.jsonl": "Long task events (>50ms) per hostname",  # ğŸ”§ æ–°å¢
            "storage_global.jsonl": "Global storage quota monitoring"
        }
    }
    
    overview_path = self.session_dir / "overview.json"
    with open(overview_path, 'w', encoding='utf-8') as f:
        json.dump(overview, f, indent=2, ensure_ascii=False)
```

**æ¸…ç†ä¸åæ³¨å†Œæœºåˆ¶**ï¼š
```python
async def stop_collection(self) -> None:
    """Stop collection and cleanup - æ·»åŠ é•¿ä»»åŠ¡ç›‘æ§æ¸…ç†"""
    self.running = False
    
    # ç°æœ‰æ¸…ç†ä»£ç ...
    
    # ğŸ”§ æ–°å¢ï¼šé•¿ä»»åŠ¡ç›‘æ§æ¸…ç†
    if self.longtask_callback_registered:
        try:
            self.connector.off_event("Runtime.bindingCalled", self._on_longtask_data)
            # å¯é€‰ï¼šç§»é™¤bindingï¼ˆé¿å…è·¨tabå¹²æ‰°ï¼‰
            try:
                await self.connector.call(
                    "Runtime.removeBinding",
                    {"name": "__browserFairyLongtaskCallback"},
                    session_id=self.session_id,
                    timeout=3.0
                )
            except Exception:
                pass  # å¿½ç•¥ç§»é™¤å¤±è´¥
        except Exception as e:
            logger.debug(f"Failed to cleanup longtask callback: {e}")
        
        self.longtask_callback_registered = False
```

### è®¾è®¡åŸåˆ™éµå¾ª

âœ… **ä¸ç ´åç°æœ‰åŠŸèƒ½**ï¼š
- åªåœ¨MemoryCollectorçš„enable_comprehensive=Trueæ—¶å¯ç”¨
- æ³¨å…¥å¤±è´¥æ—¶ä¼˜é›…é™çº§ï¼Œä¸å½±å“å…¶ä»–ç›‘æ§
- å®Œå…¨å¤ç”¨ç°æœ‰çš„event_queueå’ŒDataManageræ¶æ„

âœ… **ä¸è¿‡åº¦è®¾è®¡**ï¼š
- å¤ç”¨ç°æœ‰çš„Debugger.enableé€»è¾‘ï¼ˆå¦‚æœå·²å¯ç”¨ï¼‰
- å€Ÿé‰´NetworkMonitorçš„æˆç†Ÿè°ƒç”¨æ ˆå¤„ç†æ–¹æ¡ˆ
- ä½¿ç”¨ç°æœ‰çš„é¢‘ç‡æ§åˆ¶å’Œæ•°æ®å†™å…¥æœºåˆ¶

âœ… **TDDå‹å¥½**ï¼š
- æ¯ä¸ªæ–¹æ³•èŒè´£å•ä¸€ï¼Œæ˜“äºæµ‹è¯•
- æ¸…æ™°çš„æˆåŠŸ/å¤±è´¥çŠ¶æ€è·Ÿè¸ª
- å¯Mockçš„å¤–éƒ¨ä¾èµ–ï¼ˆconnector.callç­‰ï¼‰

## Tests

### æµ‹è¯•ç­–ç•¥è®¾è®¡

#### 1. å•å…ƒæµ‹è¯•è®¾è®¡

**æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•**ï¼š
```python
# tests/test_longtask_detection.py

class TestLongtaskDetection:
    
    @pytest.fixture
    def longtask_collector(self):
        """åˆ›å»ºå¯ç”¨é•¿ä»»åŠ¡ç›‘æ§çš„MemoryCollector"""
        mock_connector = AsyncMock()
        event_queue = asyncio.Queue()
        collector = MemoryCollector(
            mock_connector, "target_123", "example.com",
            enable_comprehensive=True,
            data_callback=None
        )
        collector.session_id = "session_123"
        collector.event_queue = event_queue
        return collector
    
    @pytest.mark.asyncio
    async def test_longtask_observer_injection_success(self, longtask_collector):
        """æµ‹è¯•PerformanceObserveræˆåŠŸæ³¨å…¥ï¼ˆä¿®æ­£éªŒè¯é€»è¾‘ï¼‰"""
        # MockæˆåŠŸçš„CDPè°ƒç”¨
        longtask_collector.connector.call.return_value = {}
        
        await longtask_collector._inject_longtask_observer()
        
        # ğŸ”§ ä¿®æ­£ï¼šéªŒè¯æ­£ç¡®çš„CDPè°ƒç”¨é¡ºåº
        calls = longtask_collector.connector.call.call_args_list
        # Runtime.enableå·²åœ¨_enable_comprehensive_monitoringè°ƒç”¨ï¼Œä¸é‡å¤
        assert any("Runtime.addBinding" in str(call) for call in calls)
        # ğŸ”§ éªŒè¯Page.addScriptToEvaluateOnNewDocument + Runtime.evaluate
        assert any("Page.addScriptToEvaluateOnNewDocument" in str(call) for call in calls)
        assert any("Runtime.evaluate" in str(call) for call in calls)
        
        # éªŒè¯çŠ¶æ€
        assert longtask_collector.longtask_observer_injected is True
    
    @pytest.mark.asyncio 
    async def test_longtask_observer_injection_csp_failure(self, longtask_collector):
        """æµ‹è¯•CSPé˜»æ­¢æ³¨å…¥æ—¶çš„ä¼˜é›…é™çº§"""
        # Mock CSPé”™è¯¯
        longtask_collector.connector.call.side_effect = Exception("Content Security Policy")
        
        await longtask_collector._inject_longtask_observer()
        
        # éªŒè¯ä¼˜é›…é™çº§
        assert longtask_collector.longtask_observer_injected is False
        # ä¸åº”è¯¥æŠ›å‡ºå¼‚å¸¸
    
    def test_longtask_data_processing(self, longtask_collector):
        """æµ‹è¯•é•¿ä»»åŠ¡æ•°æ®å¤„ç†ï¼ˆä¿®æ­£æ•°æ®æ ¼å¼ï¼‰"""
        # Mocké•¿ä»»åŠ¡æ•°æ®ï¼ˆåŒ…å«attributionä¿¡æ¯ï¼‰
        params = {
            "sessionId": "session_123",
            "name": "__browserFairyLongtaskCallback",
            # ğŸ”§ ä¿®æ­£ï¼šæ¨¡æ‹Ÿæ­£ç¡®çš„JSON payloadæ ¼å¼
            "payload": json.dumps({
                "timestamp": 1625097600000,
                "startTime": 1000.5,
                "duration": 150.7,
                "name": "task-1",
                # ğŸ”§ æ–°å¢ï¼šattributionä¼˜å…ˆäºstack
                "attribution": [
                    {
                        "containerType": "iframe",
                        "containerName": "ads-frame",
                        "containerSrc": "https://ads.example.com/widget.html"
                    }
                ],
                "stack": None  # attributionå­˜åœ¨æ—¶stackä¸ºnull
            })
        }
        
        # æ¨¡æ‹Ÿäº‹ä»¶é˜Ÿåˆ—å’Œå¿…è¦å±æ€§
        longtask_collector.event_queue = asyncio.Queue()
        longtask_collector.hostname = "example.com"
        longtask_collector.target_id = "target_123"  # ğŸ”§ æ–°å¢
        longtask_collector.current_url = "https://example.com/test"
        longtask_collector.current_title = "Test Page"
        longtask_collector._longtask_timestamps = []
        
        # å¤„ç†æ•°æ®
        asyncio.run(longtask_collector._on_longtask_data(params))
        
        # éªŒè¯äº‹ä»¶å…¥é˜Ÿ
        assert longtask_collector.event_queue.qsize() == 1
        event_type, event_data = longtask_collector.event_queue.get_nowait()
        
        assert event_type == "longtask"
        assert event_data["duration"] == 150.7
        assert event_data["type"] == "longtask"
        # ğŸ”§ ä¿®æ­£ï¼šéªŒè¯æ–°å­—æ®µ
        assert event_data["sessionId"] == "session_123"
        assert event_data["targetId"] == "target_123"
        assert len(event_data["attribution"]) == 1
        assert event_data["attribution"][0]["containerType"] == "iframe"
        assert event_data["stack"] is None  # attributionå­˜åœ¨æ—¶æ— stack
    
    def test_stack_parsing(self, longtask_collector):
        """æµ‹è¯•è°ƒç”¨æ ˆè§£æ"""
        raw_stack = "Error\n    at func1 (script.js:10:5)\n    at func2 (app.js:25:15)"
        
        result = longtask_collector._process_longtask_stack(raw_stack)
        
        assert result["available"] is True
        assert len(result["frames"]) == 2
        assert result["frames"][0]["functionName"] == "func1"
        assert result["frames"][0]["url"] == "script.js"
        assert result["frames"][0]["lineNumber"] == 10
        assert result["frames"][1]["functionName"] == "func2"
    
    def test_frequency_control(self, longtask_collector):
        """æµ‹è¯•é•¿ä»»åŠ¡é¢‘ç‡æ§åˆ¶ï¼ˆä¿®æ­£ä¸º20 epsï¼‰"""
        longtask_collector._longtask_timestamps = []
        
        # ğŸ”§ ä¿®æ­£ï¼šå‰20ä¸ªåº”è¯¥é€šè¿‡
        for i in range(20):
            assert longtask_collector._should_emit_longtask_event() is True
        
        # ğŸ”§ ä¿®æ­£ï¼šç¬¬21ä¸ªåº”è¯¥è¢«é™åˆ¶
        assert longtask_collector._should_emit_longtask_event() is False
```

#### 2. é›†æˆæµ‹è¯•è®¾è®¡

**ç«¯åˆ°ç«¯æ•°æ®æµæµ‹è¯•**ï¼š
```python
@pytest.mark.asyncio
async def test_longtask_end_to_end_integration():
    """æµ‹è¯•é•¿ä»»åŠ¡ç›‘æ§ç«¯åˆ°ç«¯é›†æˆ"""
    # åˆ›å»ºå®Œæ•´çš„ç›‘æ§æ ˆ
    mock_connector = AsyncMock()
    mock_connector.call.return_value = {}
    
    # åˆ›å»ºMemoryCollectorï¼ˆç»¼åˆæ¨¡å¼ï¼‰
    event_queue = asyncio.Queue()
    collector = MemoryCollector(
        mock_connector, "target_123", "example.com",
        enable_comprehensive=True
    )
    collector.session_id = "session_123"
    collector.event_queue = event_queue
    
    # æ¨¡æ‹Ÿæ³¨å…¥æˆåŠŸ
    await collector._inject_longtask_observer()
    
    # æ¨¡æ‹Ÿæ¥æ”¶é•¿ä»»åŠ¡æ•°æ®
    longtask_params = {
        "sessionId": "session_123", 
        "name": "__browserFairyLongtaskCallback",
        "payload": json.dumps({
            "duration": 75.5,
            "startTime": 1000,
            "name": "render-task"
        })
    }
    
    await collector._on_longtask_data(longtask_params)
    
    # éªŒè¯æ•°æ®æµ
    assert event_queue.qsize() == 1
    event_type, event_data = event_queue.get_nowait()
    assert event_type == "longtask"
    assert event_data["duration"] == 75.5
```

#### 3. é”™è¯¯åœºæ™¯æµ‹è¯•

**è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†**ï¼š
```python
def test_invalid_longtask_data_handling(longtask_collector):
    """æµ‹è¯•æ— æ•ˆé•¿ä»»åŠ¡æ•°æ®å¤„ç†"""
    # æ— æ•ˆJSON
    invalid_params = {
        "sessionId": "session_123",
        "name": "__browserFairyLongtaskCallback", 
        "payload": "invalid json"
    }
    
    # ä¸åº”è¯¥æŠ›å‡ºå¼‚å¸¸
    asyncio.run(longtask_collector._on_longtask_data(invalid_params))
    assert longtask_collector.event_queue.qsize() == 0

def test_session_id_filtering(longtask_collector):
    """æµ‹è¯•sessionIdè¿‡æ»¤"""
    wrong_session_params = {
        "sessionId": "wrong_session",
        "name": "__browserFairyLongtaskCallback",
        "payload": json.dumps({"duration": 100})
    }
    
    asyncio.run(longtask_collector._on_longtask_data(wrong_session_params))
    
    # åº”è¯¥è¢«è¿‡æ»¤ï¼Œä¸å…¥é˜Ÿ
    assert longtask_collector.event_queue.qsize() == 0
```

#### 4. æ€§èƒ½æµ‹è¯•

**ç›‘æ§å¼€é”€éªŒè¯**ï¼š
```python
def test_longtask_monitoring_performance_impact():
    """éªŒè¯é•¿ä»»åŠ¡ç›‘æ§çš„æ€§èƒ½å¼€é”€ï¼ˆæ›´ä¸¥æ ¼æ ‡å‡†ï¼‰"""
    # ğŸ”§ ä¿®æ­£ï¼šæµ‹è¯•æ³¨å…¥è„šæœ¬å¤§å°ï¼ˆä¿®æ­£å®ä¾‹åŒ–æ–¹å¼ï¼‰
    from browserfairy.core.connector import ChromeConnector
    from unittest.mock import MagicMock
    
    mock_connector = MagicMock()
    collector = MemoryCollector(mock_connector, "test_target", "test.com", enable_comprehensive=True)
    script = collector._build_longtask_observer_script()
    
    # ğŸ”§ ä¿®æ­£ï¼šè„šæœ¬åº”è¯¥æ›´å°ï¼ˆ<1.5KBï¼‰
    assert len(script.encode('utf-8')) < 1536
    
    # æµ‹è¯•è„šæœ¬å†…å®¹æ­£ç¡®æ€§
    assert 'PerformanceObserver' in script
    assert 'JSON.stringify' in script
    assert 'buffered: true' in script
    assert '__browserFairyLongtaskObserverInstalled' in script
    
    # æµ‹è¯•é¢‘ç‡æ§åˆ¶æ•ˆæœ
    collector._longtask_timestamps = []
    start_time = time.time()
    
    # è¿ç»­è°ƒç”¨é¢‘ç‡æ§åˆ¶
    for _ in range(1000):
        collector._should_emit_longtask_event()
    
    elapsed = time.time() - start_time
    # é¢‘ç‡æ§åˆ¶æœ¬èº«åº”è¯¥å¾ˆå¿«ï¼ˆ<10msï¼‰
    assert elapsed < 0.01
    
def test_comprehensive_data_callback_routing():
    """æµ‹è¯•CLIæ•°æ®è·¯ç”±çš„é•¿ä»»åŠ¡å¤„ç†"""
    from browserfairy.cli import comprehensive_data_callback
    from unittest.mock import AsyncMock
    
    # Mock DataManager
    mock_data_manager = AsyncMock()
    
    # é•¿ä»»åŠ¡æ•°æ®
    longtask_data = {
        "type": "longtask",
        "hostname": "example.com",
        "duration": 120.5,
        "sessionId": "session_123"
    }
    
    # è°ƒç”¨è·¯ç”±
    asyncio.run(comprehensive_data_callback(mock_data_manager, longtask_data))
    
    # éªŒè¯è°ƒç”¨äº†æ­£ç¡®çš„å†™å…¥æ–¹æ³•
    mock_data_manager.write_longtask_data.assert_called_once_with("example.com", longtask_data)
```

#### 5. TDDé©±åŠ¨çš„å¼€å‘é¡ºåºï¼ˆä¿®æ­£å¼€å‘æ­¥éª¤ï¼‰

**æµ‹è¯•é©±åŠ¨çš„å®ç°æ­¥éª¤**ï¼š
1. **è„šæœ¬æ„å»ºæµ‹è¯•**ï¼šå…ˆå†™`test_longtask_monitoring_performance_impact`éªŒè¯è„šæœ¬ç”Ÿæˆ
2. **å®ç°è„šæœ¬æ„å»º**ï¼š`_build_longtask_observer_script`æ–¹æ³•ï¼ˆé™æ€ï¼Œæ˜“æµ‹è¯•ï¼‰
3. **å›è°ƒæ³¨å†Œæµ‹è¯•**ï¼š`test_longtask_observer_injection_success`éªŒè¯CDPè°ƒç”¨
4. **å®ç°å›è°ƒæ³¨å†Œ**ï¼š`_register_longtask_callback`å’Œ`_inject_longtask_observer`
5. **æ•°æ®å¤„ç†æµ‹è¯•**ï¼š`test_longtask_data_processing`ï¼ˆåŒ…å«attributionä¼˜å…ˆé€»è¾‘ï¼‰
6. **å®ç°æ•°æ®å¤„ç†**ï¼š`_on_longtask_data`å’Œäº‹ä»¶å­—æ®µæ„å»º
7. **é¢‘ç‡æ§åˆ¶æµ‹è¯•**ï¼š`test_frequency_control`éªŒè¯20 epsé™åˆ¶
8. **å®ç°é¢‘ç‡æ§åˆ¶**ï¼š`_should_emit_longtask_event`æ–¹æ³•
9. **é”™è¯¯å¤„ç†æµ‹è¯•**ï¼š`test_longtask_observer_injection_csp_failure`
10. **å®ç°é”™è¯¯å¤„ç†**ï¼šCSPä¼˜é›…é™çº§å’Œæ¸…ç†æœºåˆ¶
11. **é›†æˆè·¯ç”±æµ‹è¯•**ï¼š`test_comprehensive_data_callback_routing`
12. **å®ç°CLIè·¯ç”±**ï¼šåœ¨`comprehensive_data_callback`ä¸­æ·»åŠ åˆ†æ”¯
13. **ç«¯åˆ°ç«¯æµ‹è¯•**ï¼šå®Œæ•´æ•°æ®æµéªŒè¯

**å…³é”®æµ‹è¯•å¢å¼º**ï¼š
```python
def test_attribution_priority_over_stack():
    """æµ‹è¯•attributionä¼˜å…ˆäºstackçš„é€»è¾‘"""
    # æœ‰attributionæ—¶ï¼Œstackåº”è¯¥ä¸ºnull
    # æ— attributionæ—¶ï¼Œstackåº”è¯¥è¢«é‡‡é›†
    
def test_buffered_events_limit():
    """æµ‹è¯•bufferedäº‹ä»¶æ•°é‡é™åˆ¶"""
    # éªŒè¯æœ€å¤šå¤„ç†50ä¸ªbufferedäº‹ä»¶
    
def test_cleanup_mechanism():
    """æµ‹è¯•æ¸…ç†å’Œåæ³¨å†Œæœºåˆ¶"""
    # éªŒè¯off_eventå’ŒremoveBindingè°ƒç”¨
```

è¿™æ ·ç¡®ä¿æ¯ä¸€æ­¥éƒ½æœ‰æµ‹è¯•è¦†ç›–ï¼Œä¼˜å…ˆå¤„ç†æ ¸å¿ƒé€»è¾‘ï¼Œæœ€åé›†æˆåˆ°ç°æœ‰æ¶æ„ã€‚