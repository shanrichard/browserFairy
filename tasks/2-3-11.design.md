# Design 2-3-11 - 实现长任务检测

## Requirements

基于技术专家评审和用户反馈，实现长任务检测功能以定位页面卡顿根因。

### 核心问题

开发同事在实际使用中反馈的关键痛点：
- **主线程阻塞无法追踪**：页面卡顿时无法确定是哪个JavaScript任务阻塞了>50ms
- **卡顿根因难定位**：知道页面卡顿但不知道具体函数或操作导致
- **性能监控数据不完整**：现有MemoryCollector只能看内存，无法看执行阻塞

### 技术专家评审结论

**需求2 - 长任务检测**的技术可行性分析：
- **技术路线调整**：使用`PerformanceObserver('longtask')`注入方案
- **原方案不可行**：`Performance.metrics`无法获取长任务详情
- **调用栈限制**：先记录scriptURL和frame，调用栈获取有技术限制
- **实现复杂度**：中等，需要处理CSP等复杂性

### 功能需求

**核心功能**：
1. 检测>50ms的JavaScript执行任务
2. 记录长任务的基本信息（持续时间、开始时间、类型）
3. 记录执行源头信息（scriptURL、frame等可获取的信息）
4. 按网站维度组织数据，集成到现有数据流

**数据要求**：
- 时间戳：任务开始时间和结束时间
- 持续时间：任务执行耗时（>50ms的记录）
- 源头信息：脚本URL、帧信息（在技术限制内尽可能多）
- 任务类型：如果能获取到任务类型信息

**性能要求**：
- 注入脚本不影响页面正常执行
- 监控开销控制在可接受范围内
- 处理CSP（内容安全政策）限制
- 支持多标签页独立监控

**集成要求**：
- 集成到现有MemoryCollector的综合监控模式
- 通过event_queue机制与其他监控器协作
- 数据通过DataManager写入，按网站维度存储
- 支持现有的频率控制和优雅降级机制

### 技术约束

**技术限制**：
1. **CSP限制**：某些网站的内容安全政策可能阻止脚本注入
2. **调用栈获取限制**：完整调用栈获取可能有限制，先实现基础信息
3. **性能影响**：PerformanceObserver本身需要消耗资源
4. **兼容性**：需要确保在不同Chrome版本下工作

**设计原则**：
1. **优雅降级**：如果注入失败，不影响其他监控功能
2. **频率控制**：避免长任务事件过多导致数据洪流
3. **原始数据导向**：专注数据收集，分析留给后续AI工具
4. **向下兼容**：不影响现有75%已完成功能的稳定性

### 预期价值

**诊断价值**：
- 直接定位页面卡顿的根本原因
- 发现哪个JavaScript函数/操作导致主线程阻塞
- 实际案例：电商页面图片加载处理函数执行280ms导致滚动卡顿
- 不可替代性：无其他方式能精确定位长任务

**应用场景**：
- 企业级Web应用性能诊断
- 仪表板页面卡顿分析
- 交易系统响应延迟问题定位
- 复杂SPA应用的性能瓶颈识别

## Solution

### 技术方案概述

**核心策略**：通过Runtime.evaluate注入PerformanceObserver脚本，集成到现有MemoryCollector的综合监控架构中，借鉴NetworkMonitor的成熟调用栈处理经验。

### 详细实现设计

#### 1. 集成点设计

**在MemoryCollector中添加长任务监控**：
```python
# browserfairy/monitors/memory.py - MemoryCollector类扩展
# 🔧 修正：添加缺失的标准库导入（在现有导入区域）
import re    # 新增导入，用于调用栈解析
import time  # 新增导入，用于频率控制
# 注意：json模块已存在，make_event_id函数完全支持设计中的参数组合

class MemoryCollector:
    def __init__(self, connector: ChromeConnector, target_id: str, hostname: str,
                 data_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
                 enable_comprehensive: bool = False,
                 status_callback: Optional[Callable] = None):
        # 现有代码保持不变
        ...
        # 🔧 修正：在__init__中正确初始化长任务监控属性
        self.longtask_observer_injected = False
        self.longtask_callback_registered = False
        self._longtask_timestamps = []  # 频率控制时间戳
```

**集成到现有_enable_comprehensive_monitoring()方法**：
```python
async def _enable_comprehensive_monitoring(self):
    """现有方法扩展 - 添加长任务监控"""
    # 现有代码：Runtime.enable已经调用，直接复用
    # await self.connector.call("Runtime.enable", session_id=self.session_id)
    # 现有代码：event_queue已创建，network_monitor等已初始化
    ...
    
    # 新增：长任务监控注入（在所有Monitor初始化之后）
    await self._inject_longtask_observer()
```

#### 2. PerformanceObserver注入实现

**注入脚本设计**（修正关键问题）：
```javascript
// 注入到页面的PerformanceObserver脚本（兼容性+payload修正）
if ('PerformanceObserver' in window) {
    try {
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'longtask' && entry.duration >= 50) {
                    const taskData = {
                        timestamp: Date.now(),
                        startTime: entry.startTime,
                        duration: entry.duration,
                        name: entry.name || 'unknown',
                        // 优先采集归因信息（更有价值）
                        attribution: entry.attribution?.map(attr => ({
                            containerType: attr.containerType || 'unknown',
                            containerName: attr.containerName || '',
                            containerSrc: (attr.containerSrc || '').slice(0, 200)
                        }))?.slice(0, 5) || [],
                        // 备选调用栈（仅在无归因信息时采集）
                        stack: entry.attribution?.length ? null : (() => {
                            try {
                                return new Error().stack;
                            } catch (e) {
                                return null;
                            }
                        })()
                    };
                    
                    // 🔧 关键修正：必须JSON.stringify，否则payload变成"[object Object]"
                    if (window.__browserFairyLongtaskCallback) {
                        window.__browserFairyLongtaskCallback(JSON.stringify(taskData));
                    }
                }
            }
        });
        
        // 🔧 buffered:true 能补抓注入前的长任务
        observer.observe({entryTypes: ['longtask'], buffered: true});
    } catch (e) {
        // 优雅降级：注入错误不影响页面
        console.debug('BrowserFairy longtask observer injection failed:', e);
    }
}
```

**注入方法实现**（修正导航持久性问题）：
```python
async def _inject_longtask_observer(self) -> None:
    """注入PerformanceObserver长任务监控（修正导航持久性）"""
    try:
        # 1. 先注册CDP回调处理器
        await self._register_longtask_callback()
        
        # 2. 构建注入脚本
        injection_script = self._build_longtask_observer_script()
        
        # 🔧 关键修正：优先使用Page.addScriptToEvaluateOnNewDocument确保导航持久性
        try:
            await self.connector.call(
                "Page.enable",
                session_id=self.session_id,
                timeout=5.0
            )
            await self.connector.call(
                "Page.addScriptToEvaluateOnNewDocument",
                {"source": injection_script},
                session_id=self.session_id,
                timeout=10.0
            )
            logger.debug("Long task observer added via addScriptToEvaluateOnNewDocument")
        except Exception as e:
            logger.debug(f"Page.addScriptToEvaluateOnNewDocument failed: {e}")
        
        # 3. 兼容性兜底：Runtime.evaluate注入一次（当前页面立即生效）
        await self.connector.call(
            "Runtime.evaluate",
            {
                "expression": injection_script,
                "returnByValue": False
            },
            session_id=self.session_id,
            timeout=10.0
        )
        
        self.longtask_observer_injected = True
        logger.info(f"Long task observer injected for session {self.session_id}")
        
    except Exception as e:
        logger.warning(f"Failed to inject longtask observer: {e}")
        # 优雅降级：不影响其他监控功能
        self.longtask_observer_injected = False

def _build_longtask_observer_script(self) -> str:
    """构建长任务监控注入脚本"""
    # 注意：控制脚本大小 <1.5KB
    script = '''
if ('PerformanceObserver' in window && !window.__browserFairyLongtaskObserverInstalled) {
    try {
        window.__browserFairyLongtaskObserverInstalled = true;
        const observer = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            let processed = 0;
            for (const entry of entries) {
                if (entry.entryType === 'longtask' && entry.duration >= 50) {
                    // 限制buffered事件处理数量
                    if (++processed > 50) break;
                    
                    const taskData = {
                        timestamp: Date.now(),
                        startTime: entry.startTime,
                        duration: entry.duration,
                        name: entry.name || 'unknown',
                        attribution: entry.attribution?.map(attr => ({
                            containerType: attr.containerType || 'unknown',
                            containerName: attr.containerName || '',
                            containerSrc: (attr.containerSrc || '').slice(0, 200)
                        }))?.slice(0, 5) || [],
                        stack: entry.attribution?.length ? null : (() => {
                            try { return new Error().stack; } catch (e) { return null; }
                        })()
                    };
                    
                    if (window.__browserFairyLongtaskCallback) {
                        window.__browserFairyLongtaskCallback(JSON.stringify(taskData));
                    }
                }
            }
        });
        observer.observe({entryTypes: ['longtask'], buffered: true});
    } catch (e) {
        console.debug('BrowserFairy longtask observer injection failed:', e);
    }
}
'''
    return script
```

#### 3. 数据回调和处理机制

**注册Runtime消息回调**（复用现有Runtime.enable）：
```python
async def _register_longtask_callback(self) -> None:
    """注册长任务数据回调"""
    try:
        # Runtime.enable在_enable_comprehensive_monitoring()中已调用，直接复用
        
        # 注册全局回调函数
        await self.connector.call(
            "Runtime.addBinding",
            {"name": "__browserFairyLongtaskCallback"},
            session_id=self.session_id
        )
        
        # 监听bindingCalled事件
        self.connector.on_event("Runtime.bindingCalled", self._on_longtask_data)
        self.longtask_callback_registered = True
        
    except Exception as e:
        logger.warning(f"Failed to register longtask callback: {e}")
```

**长任务数据处理**（修正事件字段一致性）：
```python
async def _on_longtask_data(self, params: dict) -> None:
    """处理长任务数据回调"""
    # sessionId过滤
    if params.get("sessionId") != self.session_id:
        return
        
    if params.get("name") != "__browserFairyLongtaskCallback":
        return
        
    try:
        # 🔧 修正：JSON解析（现在payload是正确的JSON字符串）
        task_data = json.loads(params.get("payload", "{}"))
        
        # 🔧 修正：构建标准事件格式，添加必要字段
        longtask_event = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "type": "longtask",
            # 🔧 事件字段一致性：添加sessionId/targetId
            "sessionId": self.session_id,
            "targetId": self.target_id,
            # 🔧 增强event_id生成
            "event_id": make_event_id(
                "longtask", 
                self.hostname, 
                task_data.get("timestamp", ""),
                str(task_data.get("duration", 0)),
                self.current_url[:50],
                str(task_data.get("startTime", 0))
            ),
            "hostname": self.hostname,
            "url": self.current_url,
            "title": self.current_title,
            # 长任务核心数据
            "duration": task_data.get("duration", 0),
            "startTime": task_data.get("startTime", 0),
            "name": task_data.get("name", "unknown"),
            # 🔧 优先处理attribution，备选stack
            "attribution": task_data.get("attribution", []),
            "stack": self._process_longtask_stack(task_data.get("stack")) if task_data.get("stack") else None
        }
        
        # 🔧 修正：频率控制调整为20 eps
        if self._should_emit_longtask_event():
            self.event_queue.put_nowait(("longtask", longtask_event))
            
    except Exception as e:
        logger.warning(f"Error processing longtask data: {e}")
```

#### 4. 调用栈处理

**借鉴NetworkMonitor的调用栈处理**：
```python
def _process_longtask_stack(self, raw_stack: str) -> dict:
    """处理长任务调用栈（借鉴NetworkMonitor经验）"""
    if not raw_stack:
        return {"available": False, "reason": "no_stack"}
        
    try:
        # 解析Error().stack格式的调用栈
        lines = raw_stack.strip().split('\n')
        frames = []
        
        for line in lines[1:31]:  # 跳过Error行，最多30帧
            frame = self._parse_stack_line(line.strip())
            if frame:
                frames.append(frame)
                
        return {
            "available": True,
            "frames": frames,
            "truncated": len(lines) > 31,
            "source": "Error().stack"
        }
        
    except Exception as e:
        logger.debug(f"Failed to process longtask stack: {e}")
        return {"available": False, "reason": f"parse_error: {str(e)}"}

def _parse_stack_line(self, line: str) -> Optional[dict]:
    """解析单行调用栈"""
    # 解析格式：at functionName (url:line:column)
    # 或：at url:line:column
    # 注意：re模块已在文件顶部导入
    
    patterns = [
        r'at\s+(\w+)\s+\(([^:]+):(\d+):(\d+)\)',  # at func (url:line:col)
        r'at\s+([^:]+):(\d+):(\d+)'               # at url:line:col
    ]
    
    for pattern in patterns:
        match = re.match(pattern, line)
        if match:
            if len(match.groups()) == 4:
                return {
                    "functionName": match.group(1)[:150],
                    "url": match.group(2)[:300],
                    "lineNumber": int(match.group(3)),
                    "columnNumber": int(match.group(4))
                }
            elif len(match.groups()) == 3:
                return {
                    "functionName": "anonymous",
                    "url": match.group(1)[:300],
                    "lineNumber": int(match.group(2)),
                    "columnNumber": int(match.group(3))
                }
                
    return None
```

#### 5. 频率控制和性能保护

```python
def _should_emit_longtask_event(self) -> bool:
    """长任务事件频率控制（调整为20 eps）"""
    current_time = time.time()
    
    # 清理1秒前的记录
    if not hasattr(self, '_longtask_timestamps'):
        self._longtask_timestamps = []
    
    self._longtask_timestamps = [
        ts for ts in self._longtask_timestamps
        if current_time - ts < 1.0
    ]
    
    # 🔧 修正：每秒最多20个长任务事件（提高采样率）
    LONGTASK_RATE_LIMIT = 20  # 可配置常量
    if len(self._longtask_timestamps) >= LONGTASK_RATE_LIMIT:
        return False
        
    self._longtask_timestamps.append(current_time)
    return True
```

#### 6. CSP和错误处理

**优雅降级策略**：
```python
async def _inject_longtask_observer(self) -> None:
    """注入PerformanceObserver长任务监控（合并CSP处理逻辑）"""
    try:
        # 1. 先注册CDP回调处理器
        await self._register_longtask_callback()
        
        # 2. 构建注入脚本
        injection_script = self._build_longtask_observer_script()
        
        # 3. 🔧 修正：优先使用Page.addScriptToEvaluateOnNewDocument确保导航持久性
        try:
            await self.connector.call(
                "Page.enable",
                session_id=self.session_id,
                timeout=5.0
            )
            await self.connector.call(
                "Page.addScriptToEvaluateOnNewDocument",
                {"source": injection_script},
                session_id=self.session_id,
                timeout=10.0
            )
            logger.debug("Long task observer added via addScriptToEvaluateOnNewDocument")
        except Exception as e:
            logger.debug(f"Page.addScriptToEvaluateOnNewDocument failed: {e}")
        
        # 4. 兼容性兜底：Runtime.evaluate注入一次（当前页面立即生效）
        await self.connector.call(
            "Runtime.evaluate",
            {
                "expression": injection_script,
                "returnByValue": False
            },
            session_id=self.session_id,
            timeout=10.0
        )
        
        self.longtask_observer_injected = True
        logger.info(f"Long task observer injected for session {self.session_id}")
        
    except Exception as e:
        # 🔧 修正：不做脆弱的CSP字符串匹配，统一记录失败原因
        logger.warning(f"Failed to inject longtask observer: {e}")
        self._record_injection_limitation(str(e)[:200])  # 截断错误信息
        self.longtask_observer_injected = False

def _record_injection_limitation(self, error_message: str) -> None:
    """记录注入失败情况（不做脆弱的CSP判断）"""
    limitation_event = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "type": "longtask_limitation",
        "event_id": make_event_id("longtask_injection_failed", self.hostname),
        "hostname": self.hostname,
        "reason": f"injection_failed: {error_message}",  # 🔧 修正：记录实际错误信息
        "url": self.current_url
    }
    
    try:
        self.event_queue.put_nowait(("longtask_limitation", limitation_event))
    except:
        pass  # 不影响主流程
```

#### 7. 数据存储集成

**🔧 修正：集成到CLI comprehensive_data_callback路由**：
```python
# 在browserfairy/cli.py的comprehensive_data_callback中添加路由
async def comprehensive_data_callback(data_manager, data: dict):
    """Unified data routing callback - single exit point for comprehensive monitoring."""
    hostname = data.get("hostname", "unknown")
    data_type = data.get("type", "unknown")
    
    logger.debug(f"comprehensive_data_callback: type={data_type}, hostname={hostname}")
    
    try:
        if data_type == "memory":
            await data_manager.write_memory_data(hostname, data)
        elif data_type in ["console", "exception"]:
            await data_manager.write_console_data(hostname, data)
        elif data_type in ["network_request_complete", "network_request_failed", "network_request_start"]:
            await data_manager.write_network_data(hostname, data)
        # 🔧 新增：长任务数据路由
        elif data_type == "longtask":
            await data_manager.write_longtask_data(hostname, data)
        elif data_type == "longtask_limitation":
            await data_manager.write_longtask_data(hostname, data)  # 同一文件
        # 其他现有路由...
        else:
            logger.warning(f"Unknown data type: {data_type}")
    except Exception as e:
        logger.error(f"Error writing {data_type} data: {e}")
```

**在DataManager中添加write_longtask_data方法**：
```python
# 🔧 修正：在browserfairy/data/manager.py中添加，使用正确的写入接口
async def write_longtask_data(self, hostname: str, data: dict):
    """写入长任务数据（修正：使用正确的DataManager接口）"""
    if not self.running:
        return
    # 🔧 修正：使用现有的data_writer.append_jsonl模式，不要引入self.writers
    file_path = f"{hostname}/longtask.jsonl"
    await self.data_writer.append_jsonl(file_path, data)

# 🔧 修正：在现有_create_session_overview方法中添加描述
async def _create_session_overview(self):
    """Create session overview file with data type descriptions."""
    overview = {
        "session_start": datetime.now().isoformat(),
        "session_dir": str(self.session_dir),
        "data_types": {  # 🔧 修正：保持现有键名data_types，不是dataTypes
            "memory.jsonl": "Memory usage metrics per hostname",
            "console.jsonl": "Console logs and exceptions per hostname", 
            "network.jsonl": "Network request details per hostname",
            "gc.jsonl": "Garbage collection events per hostname",
            "storage.jsonl": "DOM storage events per hostname",
            "correlations.jsonl": "Event correlation analysis per hostname",
            "longtask.jsonl": "Long task events (>50ms) per hostname",  # 🔧 新增
            "storage_global.jsonl": "Global storage quota monitoring"
        }
    }
    
    overview_path = self.session_dir / "overview.json"
    with open(overview_path, 'w', encoding='utf-8') as f:
        json.dump(overview, f, indent=2, ensure_ascii=False)
```

**清理与反注册机制**：
```python
async def stop_collection(self) -> None:
    """Stop collection and cleanup - 添加长任务监控清理"""
    self.running = False
    
    # 现有清理代码...
    
    # 🔧 新增：长任务监控清理
    if self.longtask_callback_registered:
        try:
            self.connector.off_event("Runtime.bindingCalled", self._on_longtask_data)
            # 可选：移除binding（避免跨tab干扰）
            try:
                await self.connector.call(
                    "Runtime.removeBinding",
                    {"name": "__browserFairyLongtaskCallback"},
                    session_id=self.session_id,
                    timeout=3.0
                )
            except Exception:
                pass  # 忽略移除失败
        except Exception as e:
            logger.debug(f"Failed to cleanup longtask callback: {e}")
        
        self.longtask_callback_registered = False
```

### 设计原则遵循

✅ **不破坏现有功能**：
- 只在MemoryCollector的enable_comprehensive=True时启用
- 注入失败时优雅降级，不影响其他监控
- 完全复用现有的event_queue和DataManager架构

✅ **不过度设计**：
- 复用现有的Debugger.enable逻辑（如果已启用）
- 借鉴NetworkMonitor的成熟调用栈处理方案
- 使用现有的频率控制和数据写入机制

✅ **TDD友好**：
- 每个方法职责单一，易于测试
- 清晰的成功/失败状态跟踪
- 可Mock的外部依赖（connector.call等）

## Tests

### 测试策略设计

#### 1. 单元测试设计

**核心功能测试**：
```python
# tests/test_longtask_detection.py

class TestLongtaskDetection:
    
    @pytest.fixture
    def longtask_collector(self):
        """创建启用长任务监控的MemoryCollector"""
        mock_connector = AsyncMock()
        event_queue = asyncio.Queue()
        collector = MemoryCollector(
            mock_connector, "target_123", "example.com",
            enable_comprehensive=True,
            data_callback=None
        )
        collector.session_id = "session_123"
        collector.event_queue = event_queue
        return collector
    
    @pytest.mark.asyncio
    async def test_longtask_observer_injection_success(self, longtask_collector):
        """测试PerformanceObserver成功注入（修正验证逻辑）"""
        # Mock成功的CDP调用
        longtask_collector.connector.call.return_value = {}
        
        await longtask_collector._inject_longtask_observer()
        
        # 🔧 修正：验证正确的CDP调用顺序
        calls = longtask_collector.connector.call.call_args_list
        # Runtime.enable已在_enable_comprehensive_monitoring调用，不重复
        assert any("Runtime.addBinding" in str(call) for call in calls)
        # 🔧 验证Page.addScriptToEvaluateOnNewDocument + Runtime.evaluate
        assert any("Page.addScriptToEvaluateOnNewDocument" in str(call) for call in calls)
        assert any("Runtime.evaluate" in str(call) for call in calls)
        
        # 验证状态
        assert longtask_collector.longtask_observer_injected is True
    
    @pytest.mark.asyncio 
    async def test_longtask_observer_injection_csp_failure(self, longtask_collector):
        """测试CSP阻止注入时的优雅降级"""
        # Mock CSP错误
        longtask_collector.connector.call.side_effect = Exception("Content Security Policy")
        
        await longtask_collector._inject_longtask_observer()
        
        # 验证优雅降级
        assert longtask_collector.longtask_observer_injected is False
        # 不应该抛出异常
    
    def test_longtask_data_processing(self, longtask_collector):
        """测试长任务数据处理（修正数据格式）"""
        # Mock长任务数据（包含attribution信息）
        params = {
            "sessionId": "session_123",
            "name": "__browserFairyLongtaskCallback",
            # 🔧 修正：模拟正确的JSON payload格式
            "payload": json.dumps({
                "timestamp": 1625097600000,
                "startTime": 1000.5,
                "duration": 150.7,
                "name": "task-1",
                # 🔧 新增：attribution优先于stack
                "attribution": [
                    {
                        "containerType": "iframe",
                        "containerName": "ads-frame",
                        "containerSrc": "https://ads.example.com/widget.html"
                    }
                ],
                "stack": None  # attribution存在时stack为null
            })
        }
        
        # 模拟事件队列和必要属性
        longtask_collector.event_queue = asyncio.Queue()
        longtask_collector.hostname = "example.com"
        longtask_collector.target_id = "target_123"  # 🔧 新增
        longtask_collector.current_url = "https://example.com/test"
        longtask_collector.current_title = "Test Page"
        longtask_collector._longtask_timestamps = []
        
        # 处理数据
        asyncio.run(longtask_collector._on_longtask_data(params))
        
        # 验证事件入队
        assert longtask_collector.event_queue.qsize() == 1
        event_type, event_data = longtask_collector.event_queue.get_nowait()
        
        assert event_type == "longtask"
        assert event_data["duration"] == 150.7
        assert event_data["type"] == "longtask"
        # 🔧 修正：验证新字段
        assert event_data["sessionId"] == "session_123"
        assert event_data["targetId"] == "target_123"
        assert len(event_data["attribution"]) == 1
        assert event_data["attribution"][0]["containerType"] == "iframe"
        assert event_data["stack"] is None  # attribution存在时无stack
    
    def test_stack_parsing(self, longtask_collector):
        """测试调用栈解析"""
        raw_stack = "Error\n    at func1 (script.js:10:5)\n    at func2 (app.js:25:15)"
        
        result = longtask_collector._process_longtask_stack(raw_stack)
        
        assert result["available"] is True
        assert len(result["frames"]) == 2
        assert result["frames"][0]["functionName"] == "func1"
        assert result["frames"][0]["url"] == "script.js"
        assert result["frames"][0]["lineNumber"] == 10
        assert result["frames"][1]["functionName"] == "func2"
    
    def test_frequency_control(self, longtask_collector):
        """测试长任务频率控制（修正为20 eps）"""
        longtask_collector._longtask_timestamps = []
        
        # 🔧 修正：前20个应该通过
        for i in range(20):
            assert longtask_collector._should_emit_longtask_event() is True
        
        # 🔧 修正：第21个应该被限制
        assert longtask_collector._should_emit_longtask_event() is False
```

#### 2. 集成测试设计

**端到端数据流测试**：
```python
@pytest.mark.asyncio
async def test_longtask_end_to_end_integration():
    """测试长任务监控端到端集成"""
    # 创建完整的监控栈
    mock_connector = AsyncMock()
    mock_connector.call.return_value = {}
    
    # 创建MemoryCollector（综合模式）
    event_queue = asyncio.Queue()
    collector = MemoryCollector(
        mock_connector, "target_123", "example.com",
        enable_comprehensive=True
    )
    collector.session_id = "session_123"
    collector.event_queue = event_queue
    
    # 模拟注入成功
    await collector._inject_longtask_observer()
    
    # 模拟接收长任务数据
    longtask_params = {
        "sessionId": "session_123", 
        "name": "__browserFairyLongtaskCallback",
        "payload": json.dumps({
            "duration": 75.5,
            "startTime": 1000,
            "name": "render-task"
        })
    }
    
    await collector._on_longtask_data(longtask_params)
    
    # 验证数据流
    assert event_queue.qsize() == 1
    event_type, event_data = event_queue.get_nowait()
    assert event_type == "longtask"
    assert event_data["duration"] == 75.5
```

#### 3. 错误场景测试

**边界条件和错误处理**：
```python
def test_invalid_longtask_data_handling(longtask_collector):
    """测试无效长任务数据处理"""
    # 无效JSON
    invalid_params = {
        "sessionId": "session_123",
        "name": "__browserFairyLongtaskCallback", 
        "payload": "invalid json"
    }
    
    # 不应该抛出异常
    asyncio.run(longtask_collector._on_longtask_data(invalid_params))
    assert longtask_collector.event_queue.qsize() == 0

def test_session_id_filtering(longtask_collector):
    """测试sessionId过滤"""
    wrong_session_params = {
        "sessionId": "wrong_session",
        "name": "__browserFairyLongtaskCallback",
        "payload": json.dumps({"duration": 100})
    }
    
    asyncio.run(longtask_collector._on_longtask_data(wrong_session_params))
    
    # 应该被过滤，不入队
    assert longtask_collector.event_queue.qsize() == 0
```

#### 4. 性能测试

**监控开销验证**：
```python
def test_longtask_monitoring_performance_impact():
    """验证长任务监控的性能开销（更严格标准）"""
    # 🔧 修正：测试注入脚本大小（修正实例化方式）
    from browserfairy.core.connector import ChromeConnector
    from unittest.mock import MagicMock
    
    mock_connector = MagicMock()
    collector = MemoryCollector(mock_connector, "test_target", "test.com", enable_comprehensive=True)
    script = collector._build_longtask_observer_script()
    
    # 🔧 修正：脚本应该更小（<1.5KB）
    assert len(script.encode('utf-8')) < 1536
    
    # 测试脚本内容正确性
    assert 'PerformanceObserver' in script
    assert 'JSON.stringify' in script
    assert 'buffered: true' in script
    assert '__browserFairyLongtaskObserverInstalled' in script
    
    # 测试频率控制效果
    collector._longtask_timestamps = []
    start_time = time.time()
    
    # 连续调用频率控制
    for _ in range(1000):
        collector._should_emit_longtask_event()
    
    elapsed = time.time() - start_time
    # 频率控制本身应该很快（<10ms）
    assert elapsed < 0.01
    
def test_comprehensive_data_callback_routing():
    """测试CLI数据路由的长任务处理"""
    from browserfairy.cli import comprehensive_data_callback
    from unittest.mock import AsyncMock
    
    # Mock DataManager
    mock_data_manager = AsyncMock()
    
    # 长任务数据
    longtask_data = {
        "type": "longtask",
        "hostname": "example.com",
        "duration": 120.5,
        "sessionId": "session_123"
    }
    
    # 调用路由
    asyncio.run(comprehensive_data_callback(mock_data_manager, longtask_data))
    
    # 验证调用了正确的写入方法
    mock_data_manager.write_longtask_data.assert_called_once_with("example.com", longtask_data)
```

#### 5. TDD驱动的开发顺序（修正开发步骤）

**测试驱动的实现步骤**：
1. **脚本构建测试**：先写`test_longtask_monitoring_performance_impact`验证脚本生成
2. **实现脚本构建**：`_build_longtask_observer_script`方法（静态，易测试）
3. **回调注册测试**：`test_longtask_observer_injection_success`验证CDP调用
4. **实现回调注册**：`_register_longtask_callback`和`_inject_longtask_observer`
5. **数据处理测试**：`test_longtask_data_processing`（包含attribution优先逻辑）
6. **实现数据处理**：`_on_longtask_data`和事件字段构建
7. **频率控制测试**：`test_frequency_control`验证20 eps限制
8. **实现频率控制**：`_should_emit_longtask_event`方法
9. **错误处理测试**：`test_longtask_observer_injection_csp_failure`
10. **实现错误处理**：CSP优雅降级和清理机制
11. **集成路由测试**：`test_comprehensive_data_callback_routing`
12. **实现CLI路由**：在`comprehensive_data_callback`中添加分支
13. **端到端测试**：完整数据流验证

**关键测试增强**：
```python
def test_attribution_priority_over_stack():
    """测试attribution优先于stack的逻辑"""
    # 有attribution时，stack应该为null
    # 无attribution时，stack应该被采集
    
def test_buffered_events_limit():
    """测试buffered事件数量限制"""
    # 验证最多处理50个buffered事件
    
def test_cleanup_mechanism():
    """测试清理和反注册机制"""
    # 验证off_event和removeBinding调用
```

这样确保每一步都有测试覆盖，优先处理核心逻辑，最后集成到现有架构。