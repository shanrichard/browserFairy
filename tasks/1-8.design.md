# Design 1-8 - 完整监控服务

## Requirements

### 项目背景
BrowserFairy项目经过前7个任务的开发，已实现：
- ✅ 1-1: Chrome连接和实例管理（ChromeConnector + ChromeInstanceManager）
- ✅ 1-2: Chrome基础信息获取
- ✅ 1-3: 标签页实时监控
- ✅ 1-4: 内存性能收集
- ✅ 1-5: 数据文件写入和存储监控
- ✅ 1-6: 综合监控（Console + Network + 关联分析）
- ✅ 1-7: 网站数据分析和分组
- ✅ 2-1: I/O优化

现在需要实现1-8作为最后一个任务，将所有功能整合为用户友好的完整监控服务。

### 核心目标
- **一键启动监控**：用户执行一个命令，自动完成所有设置
- **独立Chrome实例集成**：使用1-1-1的ChromeInstanceManager自动启动Chrome
- **全功能监控整合**：集成1-1到1-7的所有监控能力
- **后台daemon运行**：程序在后台静默运行，不占用终端
- **优雅的生命周期管理**：Chrome关闭即停止监控，自动清理资源

### 用户体验需求
- **简单启动**：`browserfairy --start-monitoring`
- **后台运行**：启动后立即回到命令行，可继续工作
- **日志查看**：`tail -f ~/BrowserFairyData/monitor.log` 查看状态
- **自动停止**：关闭Chrome窗口，监控自动结束
- **PID管理**：自动管理后台进程，Chrome关闭后自动清理
- **状态反馈**：启动时显示数据目录、日志位置等关键信息

### 技术集成需求
- **复用现有模块**：不重新实现，直接集成已完成的监控器
- **统一状态回调**：所有监控事件通过统一接口反馈给用户
- **数据流完整性**：确保所有监控数据正确写入文件系统
- **错误处理**：网络断开、Chrome崩溃等异常情况的优雅处理
- **跨平台兼容**：在macOS/Windows上都能正常工作

## Solution

### 核心设计原则
- **极简集成**：复用现有`monitor_comprehensive`函数，最小化新增代码
- **不破坏现有功能**：所有现有CLI命令保持完全不变
- **TDD驱动**：先写测试，确保新功能可验证
- **渐进式实现**：分步骤实现，每步都可独立测试

### 完整监控服务架构
**基于现有组件的极简协调模式**：
```
BrowserFairyService (新增协调器)
├── ChromeInstanceManager (1-1-1) - 复用：独立Chrome实例管理
├── monitor_comprehensive() (现有) - 复用：完整监控逻辑
│   ├── ChromeConnector (1-1) - CDP连接管理  
│   ├── TabMonitor (1-3) - 标签页监控
│   ├── MemoryMonitor (1-4) - 内存监控
│   ├── DataManager (1-5) - 数据写入和存储监控
│   └── ComprehensiveCollector (1-6) - Console/Network/JS监控
└── SiteDataManager (1-7) - 数据分析（独立使用）
```

### 1. BrowserFairyService类（极简协调器）

```python
# browserfairy/service.py (新文件)
from datetime import datetime
from typing import Optional, Callable
import asyncio
import importlib

class BrowserFairyService:
    """完整监控服务 - 极简协调器模式"""
    
    def __init__(self, log_file: Optional[str] = None):
        self.chrome_manager = None
        self.exit_event = asyncio.Event()
        self.log_file = log_file
        
    async def start_monitoring(self, duration: Optional[int] = None) -> int:
        """一键启动完整监控服务"""
        try:
            # 1. 启动独立Chrome实例
            from .core.chrome_instance import ChromeInstanceManager
            self.chrome_manager = ChromeInstanceManager()
            host_port = await self.chrome_manager.launch_isolated_chrome()
            host, port = host_port.split(":")
            
            # 2. 记录启动日志
            if self.log_file:
                self._log_message(f"Chrome started on port {port}")
                self._log_message("Monitoring started")
            
            # 3. 调用现有监控（使用动态导入避免循环依赖）
            return await self._run_monitoring(host, int(port), duration)
            
        except Exception as e:
            if self.log_file:
                self._log_message(f"ERROR: Service startup failed: {e}")
            return 1
        finally:
            await self._cleanup()
    
    async def _run_monitoring(self, host: str, port: int, duration: Optional[int]) -> int:
        """调用现有监控逻辑（避免循环导入）"""
        # 动态导入避免循环依赖
        cli_module = importlib.import_module('browserfairy.cli')
        monitor_func = getattr(cli_module, 'monitor_comprehensive')
        
        # 创建状态回调（只处理实际会触发的事件）
        status_callback = self._create_log_callback() if self.log_file else None
        
        return await monitor_func(
            host=host,
            port=port,
            duration=duration,
            status_callback=status_callback,
            exit_event=self.exit_event
        )
    
    def _create_log_callback(self) -> Callable:
        """创建日志回调函数 - 只处理monitor_comprehensive实际发送的事件"""
        def log_callback(event_type: str, payload: dict):
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # 只处理现有monitor_comprehensive实际会发送的事件
            if event_type == "console_error":
                message = f"Console Error: {payload.get('message', '')}"
            elif event_type == "large_request":
                message = f"Large Request: {payload.get('url', '')} ({payload.get('size_mb', 0):.1f}MB)"
            elif event_type == "large_response":
                message = f"Large Response: {payload.get('url', '')} ({payload.get('size_mb', 0):.1f}MB)"
            elif event_type == "correlation_found":
                message = f"Correlation: {payload.get('count', 0)} events correlated"
            else:
                message = f"{event_type}: {payload}"
            
            try:
                with open(self.log_file, "a", encoding="utf-8") as f:
                    f.write(f"[{timestamp}] {message}\n")
            except:
                pass
        
        return log_callback
    
    def _log_message(self, message: str):
        """记录简单日志消息"""
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(f"[{timestamp}] {message}\n")
        except:
            pass
    
    async def _cleanup(self):
        """清理资源"""
        try:
            if self.chrome_manager:
                await self.chrome_manager.cleanup()
        except:
            pass  # 静默清理
```

### 2. CLI集成（修正daemon支持）

```python
# cli.py 新增函数
async def start_monitoring_service(log_file: Optional[str] = None, 
                                 duration: Optional[int] = None) -> int:
    """启动完整监控服务 - 极简封装"""
    from .service import BrowserFairyService
    from .utils.paths import ensure_data_directory
    
    # 设置默认日志文件
    if not log_file:
        data_dir = ensure_data_directory()
        log_file = str(data_dir / "monitor.log")
    
    # 创建并启动服务
    service = BrowserFairyService(log_file=log_file)
    
    print("BrowserFairy starting comprehensive monitoring...")
    print(f"Monitor log: {log_file}")
    print("Chrome will be launched automatically.")
    print("Close Chrome browser to stop monitoring.")
    
    return await service.start_monitoring(duration)

async def run_daemon_start_monitoring(log_file: Optional[str] = None, 
                                    duration: Optional[int] = None) -> int:
    """daemon模式的start_monitoring - 复用现有daemon框架"""
    import atexit
    from pathlib import Path
    
    # 设置文件路径（复用现有逻辑）
    data_dir = ensure_data_directory()
    pid_path = data_dir / "monitor.pid"
    if not log_file:
        log_file = str(data_dir / "monitor.log")
    else:
        log_file = os.path.expanduser(log_file)
    
    # 简单fork（复用现有daemon代码）
    pid = os.fork()
    if pid > 0:
        print("BrowserFairy daemon starting...")
        print(f"Monitor log: {log_file}")
        print("Close Chrome browser to stop monitoring.")
        sys.exit(0)
    
    # Child process: daemonize（复用现有逻辑）
    os.setsid()
    os.chdir('/')
    os.umask(0)
    
    # Redirect stdio（复用现有逻辑）
    with open('/dev/null', 'r') as dev_null_r, open('/dev/null', 'w') as dev_null_w:
        os.dup2(dev_null_r.fileno(), sys.stdin.fileno())
        os.dup2(dev_null_w.fileno(), sys.stdout.fileno())
        os.dup2(dev_null_w.fileno(), sys.stderr.fileno())
    
    # Write PID file（复用现有逻辑）
    with open(pid_path, 'w') as f:
        f.write(str(os.getpid()))
    
    # Register cleanup（复用现有逻辑）
    def cleanup():
        try:
            if pid_path.exists():
                pid_path.unlink()
        except:
            pass
    atexit.register(cleanup)
    
    # 调用start_monitoring_service而不是monitor_comprehensive
    return await start_monitoring_service(log_file, duration)

# 在main()函数中修正daemon支持
elif args.start_monitoring:
    if args.daemon:
        # daemon模式处理
        if os.name != 'posix':
            print("Daemon mode not supported on Windows, running in foreground...")
            exit_code = await start_monitoring_service(args.log_file, args.duration)
        else:
            exit_code = await run_daemon_start_monitoring(args.log_file, args.duration)
    else:
        # 前台模式
        exit_code = await start_monitoring_service(args.log_file, args.duration)
    sys.exit(exit_code)
```

### 3. Chrome生命周期绑定（不修改现有代码）

```python
# 完全不修改monitor_comprehensive函数
# 利用现有机制：
# - connection_lost_callback 已经能检测Chrome关闭
# - exit_event 机制已经足够处理优雅退出
# - 不需要传入chrome_manager或添加进程检查
# 
# 现有的monitor_comprehensive函数已经通过以下方式处理Chrome关闭：
# 1. WebSocket连接断开触发connection_lost_callback
# 2. exit_event.set() 通知监控循环退出
# 3. 各组件按依赖关系逆序清理
```

### 4. 用户工作流程（修正后的实际体验）

**基础启动**：
```bash
$ browserfairy --start-monitoring
BrowserFairy starting comprehensive monitoring...
Monitor log: /Users/user/BrowserFairyData/monitor.log
Chrome will be launched automatically.
Close Chrome browser to stop monitoring.

# 查看日志文件（只记录实际发生的事件）：
$ tail -f ~/BrowserFairyData/monitor.log
[2025-08-16 14:30:25] Chrome started on port 9222
[2025-08-16 14:30:28] Monitoring started
[2025-08-16 14:35:12] Console Error: TypeError: Cannot read property 'value' of null
[2025-08-16 14:36:33] Large Request: https://api.trading.com/data (5.2MB)
[2025-08-16 14:37:15] Large Response: https://cdn.example.com/bundle.js (3.1MB)
[2025-08-16 14:42:18] Correlation: 5 events correlated
# Chrome关闭时monitor_comprehensive会自动退出，无额外日志
```

**自定义选项**：
```bash
# 后台daemon模式（复用现有--daemon）
$ browserfairy --start-monitoring --daemon

# 自定义日志文件
$ browserfairy --start-monitoring --log-file /tmp/my-monitor.log

# 限时监控
$ browserfairy --start-monitoring --duration 3600  # 1小时
```

**与现有命令对比**：
```bash
# 现有方式：用户手动启动Chrome
$ google-chrome --remote-debugging-port=9222  # 手动启动
$ browserfairy --monitor-comprehensive        # 连接监控

# 新方式：一键自动启动
$ browserfairy --start-monitoring             # 自动启动Chrome + 监控
```

### 技术实现要点（修正后）

**复用现有架构**：
- 使用动态导入调用`monitor_comprehensive`函数，避免循环依赖
- 直接使用现有ChromeInstanceManager启动独立Chrome实例  
- 完全复用现有daemon框架（fork、PID管理、stdio重定向）

**修正关键问题**：
- **事件类型匹配**：只处理`console_error`、`large_request`、`large_response`、`correlation_found`等实际会触发的事件
- **daemon集成**：在`--start-monitoring`分支正确处理`--daemon`参数，复用现有daemon逻辑
- **循环导入解决**：使用`importlib.import_module`动态导入避免模块依赖问题
- **不修改核心**：完全不修改`monitor_comprehensive`函数，利用现有连接断开检测机制

**最小化代码变更**：
- 新增service.py文件（~80行代码）
- cli.py新增2个函数和条件分支（~60行代码）
- 对现有函数零破坏性修改

**Chrome生命周期绑定（现有机制）**：
- 利用现有`connection_lost_callback` + `exit_event`机制
- WebSocket断开自动触发监控退出
- 不需要添加进程检查或修改监控循环

## Tests

### TDD测试策略（优先级顺序）

**阶段1：服务基础功能测试**
```python
# tests/test_service.py (新文件)
class TestBrowserFairyService:
    @pytest.fixture
    def service(self):
        return BrowserFairyService()
    
    def test_service_initialization(self, service):
        """测试服务初始化"""
        assert service.chrome_manager is None
        assert service.exit_event is not None
        assert service.log_file is None
        
    def test_service_with_log_file(self, tmp_path):
        """测试带日志文件的服务初始化"""
        log_file = str(tmp_path / "test.log")
        service = BrowserFairyService(log_file=log_file)
        assert service.log_file == log_file
        
    def test_log_callback_creation(self, tmp_path):
        """测试日志回调功能"""
        log_file = tmp_path / "test.log"
        service = BrowserFairyService(log_file=str(log_file))
        callback = service._create_log_callback()
        
        # 测试各种事件类型的日志输出
        callback("chrome_launched", {"port": 9222})
        callback("monitoring_active", {"data_dir": "/test/path"})
        callback("site_discovered", {"hostname": "example.com"})
        callback("chrome_closed", {})
        
        assert log_file.exists()
        content = log_file.read_text()
        assert "Chrome started on port 9222" in content
        assert "Monitoring active. Data: /test/path" in content
        assert "Site discovered: example.com" in content
        assert "Chrome closed, stopping monitoring" in content
```

**阶段2：Chrome集成测试**
```python
@pytest.mark.asyncio
async def test_chrome_instance_integration():
    """测试ChromeInstanceManager集成"""
    service = BrowserFairyService()
    
    # Mock ChromeInstanceManager
    with patch('browserfairy.core.chrome_instance.ChromeInstanceManager') as mock_manager:
        mock_manager.return_value.launch_isolated_chrome.return_value = "127.0.0.1:9222"
        mock_manager.return_value.cleanup = AsyncMock()
        
        # Mock monitor_comprehensive
        with patch('browserfairy.cli.monitor_comprehensive') as mock_monitor:
            mock_monitor.return_value = 0
            
            result = await service.start_monitoring()
            
            # 验证Chrome启动调用
            mock_manager.return_value.launch_isolated_chrome.assert_called_once()
            
            # 验证monitor_comprehensive调用参数
            mock_monitor.assert_called_once_with(
                host="127.0.0.1",
                port=9222,
                duration=None,
                status_callback=None,
                exit_event=service.exit_event
            )
            
            assert result == 0

@pytest.mark.asyncio
async def test_cleanup_on_error():
    """测试异常情况下的资源清理"""
    service = BrowserFairyService()
    
    with patch('browserfairy.core.chrome_instance.ChromeInstanceManager') as mock_manager:
        mock_manager.return_value.launch_isolated_chrome.side_effect = Exception("Chrome startup failed")
        mock_manager.return_value.cleanup = AsyncMock()
        
        result = await service.start_monitoring()
        
        # 验证异常处理和清理
        assert result == 1
        mock_manager.return_value.cleanup.assert_called_once()
```

**阶段3：CLI集成测试**
```python
def test_start_monitoring_cli_parsing():
    """测试--start-monitoring参数解析"""
    # 测试CLI参数解析逻辑
    from browserfairy.cli import main
    import sys
    
    # Mock sys.argv
    test_args = ["browserfairy", "--start-monitoring"]
    with patch.object(sys, 'argv', test_args):
        # 验证参数解析不报错
        pass

@pytest.mark.asyncio
async def test_start_monitoring_service_function():
    """测试start_monitoring_service函数"""
    from browserfairy.cli import start_monitoring_service
    
    with patch('browserfairy.service.BrowserFairyService') as mock_service_class:
        mock_service = AsyncMock()
        mock_service.start_monitoring.return_value = 0
        mock_service_class.return_value = mock_service
        
        with patch('browserfairy.utils.paths.ensure_data_directory') as mock_ensure_dir:
            mock_data_dir = MagicMock()
            mock_data_dir.__truediv__.return_value = "/test/path/monitor.log"
            mock_ensure_dir.return_value = mock_data_dir
            
            result = await start_monitoring_service()
            
            assert result == 0
            mock_service.start_monitoring.assert_called_once_with(None)
```

**阶段4：端到端集成测试**
```python
@pytest.mark.integration
@pytest.mark.asyncio
async def test_complete_service_workflow():
    """端到端完整服务流程测试（需要真实Chrome环境）"""
    # 这个测试需要在有Chrome的环境中运行
    # 验证完整的启动->监控->停止流程
    
@pytest.mark.integration  
def test_daemon_mode_integration():
    """测试daemon模式集成"""
    # 测试--daemon参数与--start-monitoring的结合使用
```

### 验收测试标准
**功能验收**：
- ✅ 服务能正确启动独立Chrome实例
- ✅ 监控功能与现有`--monitor-comprehensive`完全一致  
- ✅ Chrome关闭时服务自动停止
- ✅ 日志文件正确记录关键事件
- ✅ 所有现有CLI命令功能不受影响

**兼容性验收**：
- ✅ 不破坏现有任何功能
- ✅ 与现有daemon模式兼容
- ✅ 处理各种异常情况不崩溃

**性能验收**：
- ✅ 启动时间合理(<5秒完成Chrome启动和连接)
- ✅ 资源开销与现有comprehensive监控一致
- ✅ Chrome进程生命周期绑定可靠