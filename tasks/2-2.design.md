# Design 2-2: 极简架构 - 单域名定向监控

## Requirements

### 核心理念转变
**从"监控所有网站"改为"监控特定网站"**
- 用户的真实需求：定位特定Web应用（如t.signalplus.com）的性能问题
- 不是漫无目的地收集所有网站数据
- 专注于一个域名，深度分析

### 功能需求
1. **单域名监控模式**
   - 默认监控域名：t.signalplus.com
   - 可通过配置文件或命令行参数修改
   - 程序启动时自动打开目标网站

2. **自动化Chrome管理**
   - 启动时自动拉起Chrome调试实例
   - 自动导航到目标网站
   - Chrome关闭时监控程序自动退出

3. **精准数据收集**
   - 只收集目标域名的数据
   - 过滤掉其他域名的请求（如CDN、广告）
   - 但保留第三方资源的统计（用于分析依赖）

4. **简化的数据结构**
   - 不需要按hostname分目录
   - 所有数据直接写入session根目录
   - 清晰的文件命名即可

## Solution

### 极简架构

```
用户执行命令:
browserFairy --target=t.signalplus.com
    ↓
1. 启动Chrome: chrome --remote-debugging-port=9222
2. 自动导航: Page.navigate({url: "https://t.signalplus.com"})
3. 开始监控
    ↓
┌──────────────────────────────────────┐
│     BrowserFairy (单进程)            │
├──────────────────────────────────────┤
│ config:                              │
│   target_domain: t.signalplus.com    │
│   monitor_interval: 5s               │
│   chrome_port: 9222                  │
└──────────────────────────────────────┘
                 ↓
┌──────────────────────────────────────┐
│       SingleDomainMonitor            │
│   (所有监控逻辑集中在一个类)          │
├──────────────────────────────────────┤
│ async monitor_loop():                │
│   - 每5秒收集内存                     │
│   - 实时监听console                  │
│   - 实时监听network                  │
│   - 每10秒收集performance            │
└──────────────────────────────────────┘
                 ↓
┌──────────────────────────────────────┐
│          数据文件                     │
├──────────────────────────────────────┤
│ ~/BrowserFairyData/                  │
│   └── t.signalplus.com_2025-01-01/   │
│       ├── config.json                │
│       ├── memory.jsonl               │
│       ├── console.jsonl              │
│       ├── network.jsonl              │
│       ├── performance.jsonl          │
│       └── storage.jsonl              │
└──────────────────────────────────────┘
```

### 核心实现

#### 1. 主程序入口（极简）
```python
# browserfairy/main.py
class BrowserFairy:
    def __init__(self, target_domain: str = "t.signalplus.com"):
        self.target_domain = target_domain
        self.target_url = f"https://{target_domain}"
        self.chrome = None
        self.monitor = None
        
    async def start(self):
        """一键启动"""
        # 1. 启动Chrome
        self.chrome = await self.launch_chrome()
        
        # 2. 连接CDP
        connector = ChromeConnector()
        await connector.connect()
        
        # 3. 打开目标网站
        await self.open_target_site(connector)
        
        # 4. 启动监控
        self.monitor = SingleDomainMonitor(
            connector=connector,
            target_domain=self.target_domain
        )
        await self.monitor.start()
        
        # 5. 等待Chrome关闭
        await self.wait_for_chrome_exit()
        
    async def launch_chrome(self):
        """启动Chrome调试实例"""
        cmd = [
            "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            "--remote-debugging-port=9222",
            "--user-data-dir=/tmp/browserfairy-profile",
            "--no-first-run",
            "--no-default-browser-check"
        ]
        process = await asyncio.create_subprocess_exec(*cmd)
        await asyncio.sleep(2)  # 等待Chrome启动
        return process
        
    async def open_target_site(self, connector):
        """打开目标网站"""
        # 获取第一个标签页
        targets = await connector.call("Target.getTargets")
        page_target = targets["targetInfos"][0]
        
        # 导航到目标网站
        await connector.call("Page.navigate", {
            "url": self.target_url
        }, target_id=page_target["targetId"])
```

#### 2. 单域名监控器（核心逻辑）
```python
# browserfairy/monitor.py
class SingleDomainMonitor:
    """针对单一域名的监控器"""
    
    def __init__(self, connector, target_domain):
        self.connector = connector
        self.target_domain = target_domain
        self.data_dir = self.create_session_dir()
        
    def create_session_dir(self):
        """创建数据目录"""
        timestamp = datetime.now().strftime("%Y-%m-%d_%H%M%S")
        dir_name = f"{self.target_domain}_{timestamp}"
        data_dir = Path.home() / "BrowserFairyData" / dir_name
        data_dir.mkdir(parents=True, exist_ok=True)
        
        # 保存配置
        config = {
            "target_domain": self.target_domain,
            "start_time": timestamp,
            "version": "2.2.0"
        }
        (data_dir / "config.json").write_text(json.dumps(config, indent=2))
        
        return data_dir
        
    async def start(self):
        """启动所有监控任务"""
        # 启用必要的CDP域
        await self.connector.call("Runtime.enable")
        await self.connector.call("Network.enable")
        await self.connector.call("Performance.enable")
        
        # 注册事件监听
        self.connector.on_event("Runtime.consoleAPICalled", self.on_console)
        self.connector.on_event("Network.requestWillBeSent", self.on_network)
        
        # 启动定期任务
        asyncio.create_task(self.collect_memory_loop())
        asyncio.create_task(self.collect_performance_loop())
        
    async def collect_memory_loop(self):
        """定期收集内存数据"""
        while True:
            try:
                # 获取当前标签页
                targets = await self.connector.call("Target.getTargets")
                for target in targets["targetInfos"]:
                    if self.target_domain in target["url"]:
                        # 收集内存数据
                        result = await self.connector.call("Runtime.evaluate", {
                            "expression": """({
                                timestamp: new Date().toISOString(),
                                url: location.href,
                                memory: performance.memory,
                                domNodes: document.querySelectorAll('*').length
                            })""",
                            "targetId": target["targetId"]
                        })
                        
                        # 写入文件
                        if "result" in result:
                            data = result["result"]["value"]
                            await self.write_data("memory", data)
                            
            except Exception as e:
                print(f"Memory collection error: {e}")
                
            await asyncio.sleep(5)  # 每5秒收集一次
            
    async def on_console(self, params):
        """处理console事件"""
        # 简单过滤：只记录我们关心的日志
        message = params.get("args", [{}])[0].get("value", "")
        
        data = {
            "timestamp": datetime.now().isoformat(),
            "level": params.get("type"),
            "message": str(message)[:500]  # 截断长消息
        }
        
        await self.write_data("console", data)
        
    async def on_network(self, params):
        """处理网络请求"""
        request = params["request"]
        url = request["url"]
        
        # 判断是否是目标域名的请求
        is_target = self.target_domain in url
        
        data = {
            "timestamp": datetime.now().isoformat(),
            "url": url,
            "method": request["method"],
            "is_target_domain": is_target,
            "type": params.get("type", "")
        }
        
        await self.write_data("network", data)
        
    async def write_data(self, data_type, data):
        """写入数据到文件"""
        file_path = self.data_dir / f"{data_type}.jsonl"
        
        # 简单追加写入
        async with aiofiles.open(file_path, 'a') as f:
            await f.write(json.dumps(data) + '\n')
```

#### 3. 命令行接口（极简）
```python
# browserfairy/cli.py
import argparse
import asyncio

def main():
    parser = argparse.ArgumentParser(description="BrowserFairy - 专注的性能监控工具")
    parser.add_argument(
        "--target",
        default="t.signalplus.com",
        help="要监控的域名 (默认: t.signalplus.com)"
    )
    parser.add_argument(
        "--duration",
        type=int,
        help="监控时长(秒)，不指定则持续监控直到Chrome关闭"
    )
    
    args = parser.parse_args()
    
    # 启动监控
    fairy = BrowserFairy(target_domain=args.target)
    asyncio.run(fairy.start())

if __name__ == "__main__":
    main()
```

### 使用示例

```bash
# 监控默认网站 (t.signalplus.com)
browserfairy

# 监控指定网站
browserfairy --target=myapp.example.com

# 监控10分钟
browserfairy --target=myapp.example.com --duration=600
```

### 数据分析（简化版）

```python
# 分析脚本
def analyze_session(session_dir):
    """分析一个监控会话的数据"""
    
    # 读取内存数据
    memory_data = read_jsonl(session_dir / "memory.jsonl")
    avg_memory = statistics.mean([d["memory"]["usedJSHeapSize"] for d in memory_data])
    
    # 读取console错误
    console_data = read_jsonl(session_dir / "console.jsonl")
    errors = [d for d in console_data if d["level"] == "error"]
    
    # 读取网络请求
    network_data = read_jsonl(session_dir / "network.jsonl")
    third_party = [d for d in network_data if not d["is_target_domain"]]
    
    print(f"平均内存使用: {avg_memory / 1024 / 1024:.2f} MB")
    print(f"Console错误数: {len(errors)}")
    print(f"第三方请求数: {len(third_party)}")
```

## Tests

### 验收标准
- [ ] 一行命令启动，自动打开目标网站
- [ ] 只监控指定域名的数据
- [ ] 数据文件清晰简洁
- [ ] Chrome关闭时自动停止监控
- [ ] 代码量减少70%以上

### 测试用例
1. **基本功能测试**
   - 启动监控t.signalplus.com
   - 验证数据文件生成
   - 验证只有目标域名的数据

2. **稳定性测试**
   - 运行1小时
   - 验证无内存泄漏
   - 验证数据完整性

3. **易用性测试**
   - 新用户5分钟内上手
   - 无需阅读文档即可使用