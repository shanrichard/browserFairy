# Design 1-1-1 - ç‹¬ç«‹Chromeå®ä¾‹ç®¡ç†å™¨

## Requirements

### æ ¸å¿ƒç›®æ ‡
- **ç‹¬ç«‹Chromeå®ä¾‹å¯åŠ¨**ï¼šè‡ªåŠ¨å¯åŠ¨ä¸“é—¨ç”¨äºç›‘æ§çš„Chromeå®ä¾‹
- **ç”¨æˆ·æ•°æ®ç›®å½•éš”ç¦»**ï¼šä¸ç”¨æˆ·æ—¥å¸¸Chromeå®Œå…¨åˆ†ç¦»ï¼Œé¿å…å¹²æ‰°
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šChromeå®ä¾‹ä¸ç›‘æ§ç¨‹åºç”Ÿå‘½å‘¨æœŸç»‘å®š
- **è·¨å¹³å°æ”¯æŒ**ï¼šWindowsã€macOSçš„Chromeè·¯å¾„è‡ªåŠ¨æ£€æµ‹
- **å®‰å…¨æ€§ä¿è¯**ï¼šä»…åœ¨ç›‘æ§æœŸé—´å¼€å¯è°ƒè¯•æ¨¡å¼ï¼Œç»“æŸåå®Œå…¨æ¸…ç†

### æŠ€æœ¯çº¦æŸ
- **ä¸å½±å“ç”¨æˆ·Chrome**ï¼šç‹¬ç«‹å®ä¾‹ï¼Œä¸å¹²æ‰°ç”¨æˆ·æ­£å¸¸æµè§ˆ
- **è‡ªåŠ¨ç«¯å£åˆ†é…**ï¼šè‡ªåŠ¨æŸ¥æ‰¾å¯ç”¨è°ƒè¯•ç«¯å£ï¼Œé¿å…å†²çª
- **å®Œå…¨æ¸…ç†**ï¼šç¨‹åºç»“æŸåè‡ªåŠ¨æ¸…ç†ä¸´æ—¶ç›®å½•å’Œè¿›ç¨‹
- **å®¹é”™å¤„ç†**ï¼šChromeå¯åŠ¨å¤±è´¥æ—¶çš„ä¼˜é›…é™çº§å’Œé”™è¯¯æç¤º

## Solution

### ä¸“å®¶è¯„å®¡æ„è§åº”å¯¹

**ğŸ”’ è‡´å‘½é—®é¢˜ä¿®å¤ï¼ˆç¬¬äºŒè½®ï¼‰**ï¼š
- âœ… **å®‰å…¨æ¼æ´** â†’ æ·»åŠ `--remote-debugging-address=127.0.0.1`å¼ºåˆ¶æœ¬åœ°ç»‘å®š
- âœ… **Windowså…¼å®¹** â†’ stderræ–‡ä»¶å…ˆclose()å†unlink()ï¼Œé¿å…å¥æŸ„å†²çª

**ğŸ›¡ï¸ é«˜é£é™©ä¼˜åŒ–ï¼ˆç¬¬äºŒè½®ï¼‰**ï¼š
- âœ… **æ–¹æ³•è®¾è®¡æ˜ç¡®** â†’ `_wait_for_chrome_ready`å’Œ`_register_cleanup`è¯¦ç»†è®¾è®¡è¦ç‚¹
- âœ… **é‡è¯•é€»è¾‘æ”¹è¿›** â†’ å¯åŠ¨è¶…æ—¶ä¹Ÿèµ°ç«¯å£é‡è¯•è·¯å¾„ï¼Œæé«˜æˆåŠŸç‡  
- âœ… **URLç¼–ç ä¸¥è°¨** â†’ ä½¿ç”¨`Path.as_uri()`å’Œæ­£ç¡®çš„safeå­—ç¬¦é›†
- âœ… **å‚æ•°ä¿å®ˆè°ƒæ•´** â†’ ç§»é™¤å¯èƒ½æœ‰é£é™©çš„`--disable-ipc-flooding-protection`

**ç¬¬ä¸€è½®é£é™©æ§åˆ¶**ï¼š
- âœ… **ç«¯å£ç«æ€** â†’ å¯åŠ¨å¤±è´¥é‡è¯•æœºåˆ¶ï¼Œæœ€å¤š5æ¬¡å°è¯•ä¸åŒç«¯å£
- âœ… **è·¯å¾„ç¡¬ç¼–ç ** â†’ ç¯å¢ƒå˜é‡è¦†ç›– + æ„é€ å™¨å‚æ•°ä¼ å…¥
- âœ… **å¯åŠ¨è¯Šæ–­** â†’ Verboseæ¨¡å¼stderrä¿ç•™åˆ°æ—¥å¿—æ–‡ä»¶
- âœ… **èµ„æºé—ç•™** â†’ atexitå…œåº• + async context manager + ä¸‰é‡æ¸…ç†ä¿é™©

### æ ¸å¿ƒç±»è®¾è®¡

**ChromeInstanceManagerç±»ï¼ˆç”Ÿäº§çº§ç‹¬ç«‹å®ä¾‹ç®¡ç†å™¨ï¼‰**
```python
import os
import sys
import tempfile
import subprocess
import socket
import shutil
import asyncio
import atexit
import logging
import urllib.parse
from pathlib import Path
from typing import Optional, List

class ChromeInstanceManager:
    """ç”Ÿäº§çº§Chromeç‹¬ç«‹å®ä¾‹ç®¡ç†å™¨"""
    
    def __init__(self, chrome_path: Optional[str] = None, max_port_attempts: int = 5):
        self.chrome_process: Optional[subprocess.Popen] = None
        self.temp_user_data_dir: Optional[str] = None
        self.debug_port: Optional[int] = None
        self.chrome_path = chrome_path  # æ”¯æŒæ„é€ å™¨ä¼ å…¥
        self.max_port_attempts = max_port_attempts
        self._cleanup_registered = False
        self._stderr_file: Optional[tempfile._TemporaryFileWrapper] = None
        
    async def launch_isolated_chrome(self) -> str:
        """å¯åŠ¨ç‹¬ç«‹Chromeå®ä¾‹ï¼Œè¿”å›è¿æ¥åœ°å€"""
        for attempt in range(self.max_port_attempts):
            try:
                # æ¯æ¬¡å°è¯•éƒ½é‡æ–°å‡†å¤‡ç¯å¢ƒï¼ˆé¿å…ç«¯å£ç«æ€ï¼‰
                await self._prepare_launch_environment(attempt)
                await self._launch_chrome_process()
                await self._wait_for_chrome_ready(timeout=15)
                
                # å¯åŠ¨æˆåŠŸï¼Œæ³¨å†Œæ¸…ç†æœºåˆ¶
                self._register_cleanup()
                return f"127.0.0.1:{self.debug_port}"
                
            except (ChromeStartupError, OSError, ConnectionError) as e:
                # æ¸…ç†å½“å‰å°è¯•çš„èµ„æº
                await self._cleanup_current_attempt()
                
                # ğŸ”§ æ”¹è¿›ï¼šæ‰©å±•é‡è¯•æ¡ä»¶ï¼ŒåŒ…æ‹¬å¯åŠ¨è¶…æ—¶
                should_retry = (
                    "port" in str(e).lower() or 
                    "address already in use" in str(e).lower() or
                    "startup timeout" in str(e).lower() or  # æ–°å¢ï¼šå¯åŠ¨è¶…æ—¶ä¹Ÿé‡è¯•
                    "connection" in str(e).lower()
                )
                
                if should_retry:
                    logging.debug(f"Chrome launch failed (attempt {attempt + 1}/{self.max_port_attempts}): {e}")
                    if attempt == self.max_port_attempts - 1:
                        raise ChromeInstanceError(f"All {self.max_port_attempts} attempts failed. Last error: {e}")
                    continue
                else:
                    # éå¯é‡è¯•é”™è¯¯ï¼Œç›´æ¥æŠ›å‡º
                    raise
        
        raise ChromeInstanceError("Maximum retry attempts exceeded")
    
    async def _prepare_launch_environment(self, attempt: int):
        """å‡†å¤‡å¯åŠ¨ç¯å¢ƒï¼ˆç«¯å£å’Œç›®å½•ï¼‰"""
        # 1. æ£€æµ‹Chromeè·¯å¾„ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡è¦†ç›–ï¼‰
        if not self.chrome_path:
            self.chrome_path = self._detect_chrome_path()
            if not self.chrome_path:
                raise ChromeInstanceError("Chrome executable not found")
        
        # 2. åˆ›å»ºç‹¬ç«‹çš„ç”¨æˆ·æ•°æ®ç›®å½•
        self.temp_user_data_dir = tempfile.mkdtemp(
            prefix=f"browserfairy_chrome_{attempt}_"
        )
        
        # 3. é€‰æ‹©ç«¯å£ï¼ˆæ¯æ¬¡å°è¯•é€’å¢é¿å…è¿ç»­ç«¯å£å†²çªï¼‰
        base_port = 9222 + (attempt * 10)
        self.debug_port = self._select_port_carefully(base_port)
    
    def _detect_chrome_path(self) -> Optional[str]:
        """æ£€æµ‹Chromeè·¯å¾„ï¼Œæ”¯æŒç¯å¢ƒå˜é‡è¦†ç›–"""
        # 1. ä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡
        env_chrome_path = os.environ.get("BROWSERFAIRY_CHROME_PATH")
        if env_chrome_path and os.path.exists(env_chrome_path) and os.access(env_chrome_path, os.X_OK):
            logging.info(f"Using Chrome path from environment: {env_chrome_path}")
            return env_chrome_path
        
        # 2. æ£€æµ‹ç³»ç»Ÿé»˜è®¤è·¯å¾„
        if sys.platform == "darwin":  # macOSä¼˜å…ˆæ”¯æŒ
            possible_paths = [
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
                "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
                # ç”¨æˆ·å®‰è£…è·¯å¾„
                os.path.expanduser("~/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"),
            ]
        elif sys.platform == "win32":  # Windowsæ”¯æŒ
            possible_paths = [
                os.path.expandvars(r"%ProgramFiles%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%ProgramFiles(x86)%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%LocalAppData%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%LocalAppData%\Google\Chrome Beta\Application\chrome.exe"),
                # ä¾¿æºç‰ˆè·¯å¾„
                os.path.expandvars(r"%LocalAppData%\Google\Chrome\chrome.exe"),
            ]
        else:
            raise ChromeInstanceError(f"Platform {sys.platform} is not supported. Please set BROWSERFAIRY_CHROME_PATH environment variable.")
        
        # æŸ¥æ‰¾å¯ç”¨è·¯å¾„
        for path in possible_paths:
            if os.path.exists(path) and os.access(path, os.X_OK):
                logging.debug(f"Found Chrome at: {path}")
                return path
        
        return None
    
    def _select_port_carefully(self, base_port: int, max_attempts: int = 10) -> int:
        """è°¨æ…é€‰æ‹©å¯ç”¨ç«¯å£"""
        for port in range(base_port, base_port + max_attempts):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('127.0.0.1', port))
                    return port
            except OSError:
                continue
        
        raise ChromeInstanceError(f"Ports {base_port}-{base_port + max_attempts - 1} are all busy. Please close other debugging applications.")
    
    async def _launch_chrome_process(self):
        """å¯åŠ¨Chromeè¿›ç¨‹ï¼Œä¿ç•™è¯Šæ–­ä¿¡æ¯"""
        chrome_cmd = self._build_chrome_command()
        
        # æ ¹æ®verboseæ¨¡å¼å¤„ç†stderr
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            # Debugæ¨¡å¼ï¼šä¿ç•™stderråˆ°ä¸´æ—¶æ–‡ä»¶ç”¨äºæ’é”™
            self._stderr_file = tempfile.NamedTemporaryFile(
                mode='w+', 
                prefix='browserfairy_chrome_stderr_', 
                suffix='.log', 
                delete=False
            )
            stderr_target = self._stderr_file
            logging.debug(f"Chrome stderr will be logged to: {self._stderr_file.name}")
        else:
            # æ­£å¸¸æ¨¡å¼ï¼šé™é»˜å¯åŠ¨
            stderr_target = subprocess.DEVNULL
        
        try:
            self.chrome_process = subprocess.Popen(
                chrome_cmd,
                stdout=subprocess.DEVNULL,
                stderr=stderr_target,
                # POSIXå¹³å°ç‹¬ç«‹è¿›ç¨‹ç»„ï¼Œä¾¿äºæ¸…ç†
                start_new_session=(os.name == 'posix')
            )
            logging.info(f"Chrome process started with PID: {self.chrome_process.pid}")
            
        except Exception as e:
            # å¯åŠ¨å¤±è´¥æ—¶ï¼Œå°è¯•è¯»å–é”™è¯¯ä¿¡æ¯
            error_info = ""
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.seek(0)
                    error_info = f"\nChrome stderr: {self._stderr_file.read()}"
                except:
                    pass
            
            raise ChromeStartupError(f"Failed to start Chrome process: {e}{error_info}")
    
    def _build_chrome_command(self) -> List[str]:
        """æ„å»ºChromeå¯åŠ¨å‘½ä»¤ï¼ˆå®‰å…¨çš„æœ¬åœ°ç»‘å®š + ä¿å®ˆä¼˜åŒ–å‚æ•°ï¼‰"""
        # åŸºç¡€è°ƒè¯•å‚æ•° - å®‰å…¨ç¬¬ä¸€
        base_args = [
            f"--remote-debugging-port={self.debug_port}",
            "--remote-debugging-address=127.0.0.1",  # ğŸ”’ è‡´å‘½ä¿®å¤ï¼šå¼ºåˆ¶æœ¬åœ°ç»‘å®š
            f"--user-data-dir={self.temp_user_data_dir}",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-default-apps",
            "--disable-extensions",
            "--disable-popup-blocking",
        ]
        
        # ä¿å®ˆçš„ä¼˜åŒ–å‚æ•°ï¼ˆç§»é™¤å¯èƒ½æœ‰é£é™©çš„é€‰é¡¹ï¼‰
        safe_optimization_args = [
            "--disable-background-networking",
            "--disable-component-update", 
            "--disable-features=Translate",
            "--disable-client-side-phishing-detection",
            "--disable-sync",
            "--disable-background-timer-throttling",
            "--disable-renderer-backgrounding",
            "--disable-backgrounding-occluded-windows",
            # ğŸ”§ ç§»é™¤ï¼š--disable-ipc-flooding-protectionï¼ˆå¯èƒ½é™ä½ç¨³å®šæ€§ï¼‰
            # å¦‚æœçœŸçš„é‡åˆ°ååç“¶é¢ˆï¼Œå†å•ç‹¬è¯„ä¼°æ·»åŠ 
        ]
        
        return [self.chrome_path] + base_args + safe_optimization_args + [self._get_startup_url()]
    
    def _get_startup_url(self) -> str:
        """è·å–å¯åŠ¨é¡µé¢URLï¼ˆä¸¥è°¨çš„URLç¼–ç ï¼‰"""
        data_dir = Path.home() / "BrowserFairyData"
        
        # ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨Path.as_uri()æ­£ç¡®æ„å»ºfile URL
        data_dir_uri = data_dir.as_uri()
        
        # ä¸¥è°¨çš„HTMLå†…å®¹æ„å»º
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserFairy Monitoring</title>
</head>
<body style="font-family: Arial, sans-serif; padding: 40px; text-align: center; background: #f5f5f5;">
    <h1 style="color: #2196F3;">ğŸ§š BrowserFairy Monitoring Active</h1>
    <p style="font-size: 18px; color: #333;">Please browse normally in this Chrome window.</p>
    <p style="color: #666;">Performance data is being collected automatically.</p>
    <hr style="margin: 30px 0; border: none; border-top: 1px solid #ddd;">
    <h3 style="color: #555;">Quick Access:</h3>
    <p><a href="{data_dir_uri}" style="color: #2196F3; text-decoration: none;">ğŸ“‚ View Data Directory</a></p>
    <p><small style="color: #999;">Close this Chrome window to stop monitoring</small></p>
</body>
</html>"""
        
        # ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„safeå­—ç¬¦é›†ç¼–ç data URL
        return "data:text/html;charset=utf-8," + urllib.parse.quote(html_content, safe=':/?#[]@!$&\'()*+,;=')
    
    async def _wait_for_chrome_ready(self, timeout: int = 15):
        """ç­‰å¾…Chromeå®Œå…¨å¯åŠ¨å¹¶å¯æ¥å—è¿æ¥
        
        è®¾è®¡è¦ç‚¹ï¼š
        - è½®è¯¢ http://127.0.0.1:port/json/version ç«¯ç‚¹
        - æ£€æµ‹é—´éš”ï¼šæ¯0.5ç§’ä¸€æ¬¡
        - HTTPè¶…æ—¶ï¼šå•æ¬¡è¯·æ±‚1ç§’è¶…æ—¶  
        - æ€»ä½“è¶…æ—¶ï¼šè¾¾åˆ°timeoutç§’åæŠ›å‡ºChromeStartupError
        - æˆåŠŸæ ‡å¿—ï¼šHTTP 200å“åº”ä¸”JSONæ ¼å¼æ­£ç¡®
        """
        import httpx
        
        start_time = asyncio.get_event_loop().time()
        while asyncio.get_event_loop().time() - start_time < timeout:
            try:
                async with httpx.AsyncClient(timeout=1.0) as client:  # å•æ¬¡1ç§’è¶…æ—¶
                    response = await client.get(f"http://127.0.0.1:{self.debug_port}/json/version")
                    if response.status_code == 200:
                        # éªŒè¯å“åº”æ˜¯æœ‰æ•ˆJSON
                        response.json()  # å¦‚æœä¸æ˜¯JSONä¼šæŠ›å¼‚å¸¸
                        logging.info(f"Chrome is ready on port {self.debug_port}")
                        return
            except Exception as e:
                logging.debug(f"Chrome not ready yet: {e}")
            
            await asyncio.sleep(0.5)  # 0.5ç§’æ£€æµ‹é—´éš”
        
        raise ChromeStartupError(f"Chrome startup timeout after {timeout}s")
    
    def _register_cleanup(self):
        """æ³¨å†Œæ¸…ç†ä¿é™©æœºåˆ¶
        
        è®¾è®¡è¦ç‚¹ï¼š
        - å¹‚ç­‰æ€§ï¼šå¤šæ¬¡è°ƒç”¨åªæ³¨å†Œä¸€æ¬¡atexité’©å­
        - é¿å…ç«æ€ï¼šatexitè°ƒç”¨åŒæ­¥ç‰ˆæœ¬ç´§æ€¥æ¸…ç†å‡½æ•°
        - è¿›ç¨‹é€€å‡ºå…œåº•ï¼šç¡®ä¿å¼‚å¸¸é€€å‡ºæ—¶ä¹Ÿèƒ½æ¸…ç†èµ„æº
        """
        if not self._cleanup_registered:
            atexit.register(self._emergency_cleanup)  # åŒæ­¥ç‰ˆæœ¬é¿å…å¼‚æ­¥ç«æ€
            self._cleanup_registered = True
            logging.debug("Cleanup mechanism registered")
    
    def _emergency_cleanup(self):
        """ç´§æ€¥æ¸…ç†ï¼ˆåŒæ­¥ç‰ˆæœ¬ï¼Œç”¨äºatexitï¼‰"""
        try:
            # æ¸…ç†Chromeè¿›ç¨‹
            if self.chrome_process and self.chrome_process.poll() is None:
                logging.warning("Emergency cleanup: terminating Chrome process")
                self.chrome_process.terminate()
                try:
                    self.chrome_process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    logging.warning("Emergency cleanup: force killing Chrome process")
                    self.chrome_process.kill()
                    
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                logging.warning(f"Emergency cleanup: removing temp directory {self.temp_user_data_dir}")
                shutil.rmtree(self.temp_user_data_dir, ignore_errors=True)
                
            # ğŸ”’ è‡´å‘½ä¿®å¤ï¼šå…ˆå…³é—­å†åˆ é™¤ï¼ˆWindowså…¼å®¹ï¼‰
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.close()
                    os.unlink(self._stderr_file.name)
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file in emergency: {e}")
                    
        except Exception as e:
            logging.error(f"Emergency cleanup failed: {e}")
    
    async def _cleanup_current_attempt(self):
        """æ¸…ç†å½“å‰å°è¯•çš„èµ„æº"""
        try:
            # æ¸…ç†è¿›ç¨‹
            if self.chrome_process:
                if self.chrome_process.poll() is None:
                    self.chrome_process.terminate()
                    try:
                        await asyncio.wait_for(
                            asyncio.to_thread(self.chrome_process.wait),
                            timeout=3.0
                        )
                    except asyncio.TimeoutError:
                        self.chrome_process.kill()
                self.chrome_process = None
            
            # æ¸…ç†ä¸´æ—¶ç›®å½•
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                await asyncio.to_thread(shutil.rmtree, self.temp_user_data_dir, ignore_errors=True)
                self.temp_user_data_dir = None
            
            # ğŸ”’ è‡´å‘½ä¿®å¤ï¼šå…ˆå…³é—­å†åˆ é™¤ï¼ˆWindowså…¼å®¹ï¼‰
            if self._stderr_file:
                try:
                    self._stderr_file.close()
                    await asyncio.to_thread(os.unlink, self._stderr_file.name)
                    self._stderr_file = None
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file: {e}")
                    
        except Exception as e:
            logging.debug(f"Cleanup current attempt error: {e}")
    
    def is_chrome_running(self) -> bool:
        """æ£€æŸ¥Chromeå®ä¾‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ"""
        if self.chrome_process is None:
            return False
        
        # æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
        poll_result = self.chrome_process.poll()
        return poll_result is None
    
    async def wait_for_chrome_exit(self):
        """ç­‰å¾…Chromeå®ä¾‹é€€å‡ºï¼ˆç”¨æˆ·å…³é—­æµè§ˆå™¨ï¼‰"""
        if not self.chrome_process:
            return
            
        while self.is_chrome_running():
            await asyncio.sleep(1.0)
    
    async def cleanup(self):
        """å®Œæ•´çš„èµ„æºæ¸…ç†"""
        try:
            # 1. ä¼˜é›…ç»ˆæ­¢Chromeè¿›ç¨‹
            if self.chrome_process and self.chrome_process.poll() is None:
                logging.info("Gracefully terminating Chrome process...")
                self.chrome_process.terminate()
                
                try:
                    await asyncio.wait_for(
                        asyncio.to_thread(self.chrome_process.wait), 
                        timeout=5.0
                    )
                    logging.info("Chrome process terminated gracefully")
                except asyncio.TimeoutError:
                    logging.warning("Chrome process didn't terminate gracefully, force killing...")
                    self.chrome_process.kill()
                    await asyncio.to_thread(self.chrome_process.wait)
            
            # 2. æ¸…ç†ä¸´æ—¶ç”¨æˆ·æ•°æ®ç›®å½•
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                logging.info(f"Cleaning up temp directory: {self.temp_user_data_dir}")
                await asyncio.to_thread(shutil.rmtree, self.temp_user_data_dir, ignore_errors=True)
            
            # 3. ğŸ”’ è‡´å‘½ä¿®å¤ï¼šå…ˆå…³é—­å†åˆ é™¤stderræ—¥å¿—æ–‡ä»¶ï¼ˆWindowså…¼å®¹ï¼‰
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.close()
                    await asyncio.to_thread(os.unlink, self._stderr_file.name)
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file: {e}")
                    
            # 4. é‡ç½®çŠ¶æ€
            self.chrome_process = None
            self.temp_user_data_dir = None
            self.debug_port = None
            
            logging.info("Chrome instance cleanup completed")
            
        except Exception as e:
            logging.error(f"Cleanup error (non-fatal): {e}")
    
    # æ”¯æŒasync context managerè¯­ä¹‰
    async def __aenter__(self):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨é€€å‡ºæ—¶è‡ªåŠ¨æ¸…ç†"""
        await self.cleanup()


class ChromeInstanceError(Exception):
    """Chromeå®ä¾‹ç®¡ç†ç›¸å…³é”™è¯¯"""
    pass


class ChromeStartupError(ChromeInstanceError):
    """Chromeå¯åŠ¨ç›¸å…³é”™è¯¯"""
    pass
```

### ä¸ç°æœ‰æ¶æ„é›†æˆ

**æ‰©å±•1-1çš„ChromeConnectorä½¿ç”¨ç‹¬ç«‹å®ä¾‹**ï¼š
```python
# åœ¨æœªæ¥çš„é›†æˆä¸­ï¼ŒChromeConnectorå¯ä»¥æ¥å—ChromeInstanceManager
class EnhancedChromeConnector(ChromeConnector):
    def __init__(self, chrome_manager: Optional[ChromeInstanceManager] = None, 
                 host: str = "127.0.0.1", port: int = 9222):
        if chrome_manager:
            # ä½¿ç”¨ç‹¬ç«‹Chromeå®ä¾‹
            self.chrome_manager = chrome_manager
            super().__init__(host="127.0.0.1", port=chrome_manager.debug_port)
        else:
            # ä½¿ç”¨ä¼ ç»Ÿæ–¹å¼ï¼ˆå…¼å®¹ç°æœ‰åŠŸèƒ½ï¼‰
            super().__init__(host, port)
            self.chrome_manager = None
    
    async def connect_with_managed_chrome(self):
        """è¿æ¥åˆ°æ‰˜ç®¡çš„Chromeå®ä¾‹"""
        if self.chrome_manager:
            host_port = await self.chrome_manager.launch_isolated_chrome()
            host, port = host_port.split(":")
            self.host = host
            self.port = int(port)
        
        await self.connect()
```

## Tests

### å•å…ƒæµ‹è¯•
1. **Chromeè·¯å¾„æ£€æµ‹æµ‹è¯•**
   - `test_detect_chrome_path_windows()` - Windowså¹³å°Chromeè·¯å¾„æ£€æµ‹
   - `test_detect_chrome_path_macos()` - macOSå¹³å°Chromeè·¯å¾„æ£€æµ‹  
   - `test_chrome_path_environment_override()` - ç¯å¢ƒå˜é‡è¦†ç›–è·¯å¾„æµ‹è¯•
   - `test_chrome_path_constructor_override()` - æ„é€ å™¨å‚æ•°è¦†ç›–è·¯å¾„æµ‹è¯•
   - `test_chrome_path_not_found()` - Chromeæœªå®‰è£…æ—¶çš„å¤„ç†

2. **ç«¯å£ç®¡ç†æµ‹è¯•**
   - `test_select_port_carefully()` - è°¨æ…ç«¯å£é€‰æ‹©
   - `test_port_conflict_resolution()` - ç«¯å£å†²çªè§£å†³
   - `test_no_available_ports()` - æ— å¯ç”¨ç«¯å£æ—¶çš„é”™è¯¯å¤„ç†
   - `test_port_race_condition_resilience()` - **ç«¯å£ç«æ€æ¡ä»¶æ¢å¤èƒ½åŠ›æµ‹è¯•**

3. **å®ä¾‹ç®¡ç†æµ‹è¯•**
   - `test_chrome_command_building()` - Chromeå¯åŠ¨å‘½ä»¤æ„å»º
   - `test_optimization_args_inclusion()` - ä¼˜åŒ–å‚æ•°åŒ…å«æµ‹è¯•
   - `test_user_data_directory_isolation()` - ç”¨æˆ·æ•°æ®ç›®å½•éš”ç¦»
   - `test_cleanup_resources()` - èµ„æºæ¸…ç†å®Œæ•´æ€§
   - `test_url_encoding_correctness()` - **URLç¼–ç æ­£ç¡®æ€§æµ‹è¯•**

4. **é”™è¯¯è¯Šæ–­æµ‹è¯•**
   - `test_chrome_startup_error_diagnosis()` - **Chromeå¯åŠ¨é”™è¯¯è¯Šæ–­ä¿¡æ¯ä¿ç•™**
   - `test_stderr_logging_in_debug_mode()` - Debugæ¨¡å¼stderræ—¥å¿—è®°å½•
   - `test_stderr_silent_in_normal_mode()` - æ­£å¸¸æ¨¡å¼é™é»˜å¯åŠ¨

### é›†æˆæµ‹è¯•ï¼ˆéœ€è¦Chromeå®‰è£…ï¼‰
1. **Chromeå®ä¾‹ç”Ÿå‘½å‘¨æœŸæµ‹è¯•**
   - `test_launch_isolated_chrome()` - ç‹¬ç«‹Chromeå®ä¾‹å¯åŠ¨
   - `test_chrome_ready_detection()` - Chromeå°±ç»ªçŠ¶æ€æ£€æµ‹
   - `test_chrome_connection()` - CDPè¿æ¥å»ºç«‹
   - `test_graceful_shutdown()` - ä¼˜é›…å…³é—­å¤„ç†

2. **å¤šå®ä¾‹å¹¶è¡Œæµ‹è¯•**
   - `test_multiple_instances_isolation()` - **å¤šä¸ªç‹¬ç«‹å®ä¾‹å®Œå…¨éš”ç¦»æµ‹è¯•**
   - `test_port_auto_assignment()` - è‡ªåŠ¨ç«¯å£åˆ†é…
   - `test_user_data_isolation()` - ç”¨æˆ·æ•°æ®å®Œå…¨éš”ç¦»
   - `test_concurrent_startup()` - å¹¶å‘å¯åŠ¨æµ‹è¯•

3. **é”™è¯¯æ¢å¤æµ‹è¯•**
   - `test_chrome_crash_recovery()` - Chromeå´©æºƒæ—¶çš„å¤„ç†
   - `test_startup_timeout()` - å¯åŠ¨è¶…æ—¶å¤„ç†
   - `test_cleanup_on_failure()` - å¯åŠ¨å¤±è´¥æ—¶çš„èµ„æºæ¸…ç†
   - `test_port_retry_mechanism()` - **ç«¯å£é‡è¯•æœºåˆ¶æµ‹è¯•**

4. **èµ„æºç®¡ç†æµ‹è¯•**
   - `test_resource_cleanup_completeness()` - **èµ„æºæ¸…ç†å®Œæ•´æ€§æµ‹è¯•**
   - `test_emergency_cleanup_mechanism()` - **ç´§æ€¥æ¸…ç†æœºåˆ¶æµ‹è¯•**
   - `test_async_context_manager()` - async context manageræµ‹è¯•
   - `test_atexit_cleanup()` - atexitæ¸…ç†æœºåˆ¶æµ‹è¯•

### é«˜é£é™©åœºæ™¯æµ‹è¯•ï¼ˆä¸“å®¶è¯„å®¡è¦†ç›–ï¼‰
```python
# ä¸“å®¶å»ºè®®çš„å…³é”®æµ‹è¯•ç”¨ä¾‹

async def test_port_race_condition_resilience():
    """æµ‹è¯•ç«¯å£ç«æ€æ¡ä»¶çš„æ¢å¤èƒ½åŠ›"""
    # åŒæ—¶å¯åŠ¨å¤šä¸ªå®ä¾‹ï¼ŒéªŒè¯ç«¯å£å†²çªé‡è¯•
    managers = [ChromeInstanceManager() for _ in range(3)]
    tasks = [manager.launch_isolated_chrome() for manager in managers]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # è‡³å°‘ä¸€ä¸ªæˆåŠŸï¼Œå…¶ä»–çš„åº”è¯¥èƒ½è‡ªåŠ¨é‡è¯•åˆ°å…¶ä»–ç«¯å£
    successful = [r for r in results if isinstance(r, str)]
    assert len(successful) >= 1, "At least one instance should start successfully"

async def test_chrome_path_environment_override():
    """æµ‹è¯•ç¯å¢ƒå˜é‡è¦†ç›–Chromeè·¯å¾„"""
    with patch.dict(os.environ, {"BROWSERFAIRY_CHROME_PATH": "/fake/chrome/path"}):
        manager = ChromeInstanceManager()
        with pytest.raises(ChromeInstanceError, match="Chrome executable not found"):
            await manager.launch_isolated_chrome()

async def test_chrome_startup_error_diagnosis():
    """æµ‹è¯•Chromeå¯åŠ¨é”™è¯¯çš„è¯Šæ–­ä¿¡æ¯ä¿ç•™"""
    manager = ChromeInstanceManager(chrome_path="/nonexistent/chrome")
    
    with pytest.raises(ChromeStartupError) as exc_info:
        await manager.launch_isolated_chrome()
    
    assert "Failed to start Chrome process" in str(exc_info.value)

async def test_resource_cleanup_completeness():
    """æµ‹è¯•èµ„æºæ¸…ç†çš„å®Œæ•´æ€§"""
    manager = ChromeInstanceManager()
    
    # å¯åŠ¨å¹¶è®°å½•èµ„æº
    address = await manager.launch_isolated_chrome()
    temp_dir = manager.temp_user_data_dir
    chrome_pid = manager.chrome_process.pid
    
    # éªŒè¯èµ„æºå­˜åœ¨
    assert os.path.exists(temp_dir)
    assert manager.chrome_process.poll() is None
    
    # æ‰§è¡Œæ¸…ç†
    await manager.cleanup()
    
    # éªŒè¯èµ„æºå·²æ¸…ç†
    assert not os.path.exists(temp_dir)
    assert manager.chrome_process.poll() is not None

async def test_multiple_instances_isolation():
    """æµ‹è¯•å¤šå®ä¾‹çš„å®Œå…¨éš”ç¦»"""
    manager1 = ChromeInstanceManager()
    manager2 = ChromeInstanceManager()
    
    try:
        # åŒæ—¶å¯åŠ¨ä¸¤ä¸ªå®ä¾‹
        address1 = await manager1.launch_isolated_chrome()
        address2 = await manager2.launch_isolated_chrome()
        
        # éªŒè¯ä½¿ç”¨ä¸åŒç«¯å£
        port1 = int(address1.split(':')[1])
        port2 = int(address2.split(':')[1]) 
        assert port1 != port2, "Instances should use different ports"
        
        # éªŒè¯ä½¿ç”¨ä¸åŒçš„ç”¨æˆ·æ•°æ®ç›®å½•
        assert manager1.temp_user_data_dir != manager2.temp_user_data_dir
        assert os.path.exists(manager1.temp_user_data_dir)
        assert os.path.exists(manager2.temp_user_data_dir)
        
    finally:
        await manager1.cleanup()
        await manager2.cleanup()

def test_emergency_cleanup_mechanism():
    """æµ‹è¯•ç´§æ€¥æ¸…ç†æœºåˆ¶ï¼ˆatexitï¼‰"""
    manager = ChromeInstanceManager()
    
    # æ¨¡æ‹Ÿå¯åŠ¨è¿‡ç¨‹ä¸­çš„çŠ¶æ€è®¾ç½®
    manager.temp_user_data_dir = tempfile.mkdtemp(prefix="test_emergency_")
    manager.chrome_process = MockProcess(pid=12345)
    manager._cleanup_registered = True
    
    # è°ƒç”¨ç´§æ€¥æ¸…ç†
    manager._emergency_cleanup()
    
    # éªŒè¯æ¸…ç†æ•ˆæœ
    assert not os.path.exists(manager.temp_user_data_dir)
    assert manager.chrome_process.terminated
```

### éªŒæ”¶æµ‹è¯•
```bash
# æµ‹è¯•ç‹¬ç«‹Chromeå®ä¾‹å¯åŠ¨
python -c "
import asyncio
from browserfairy.core.chrome_instance import ChromeInstanceManager

async def test():
    manager = ChromeInstanceManager()
    try:
        address = await manager.launch_isolated_chrome()
        print(f'Chrome launched at: {address}')
        print('Chrome process ID:', manager.chrome_process.pid)
        print('Temp data dir:', manager.temp_user_data_dir)
        
        # ç­‰å¾…ç”¨æˆ·éªŒè¯
        input('Press Enter after verifying Chrome opened...')
        
    finally:
        await manager.cleanup()
        print('Cleanup completed')

asyncio.run(test())
"

# éªŒè¯äº‹é¡¹ï¼š
# 1. æ–°çš„Chromeçª—å£åº”è¯¥æ‰“å¼€ï¼ˆä¸ç”¨æˆ·å·²æœ‰Chromeåˆ†ç¦»ï¼‰
# 2. çª—å£æ ‡é¢˜æ˜¾ç¤ºè°ƒè¯•æ¨¡å¼
# 3. å¯åŠ¨é¡µé¢æ˜¾ç¤ºç›‘æ§çŠ¶æ€
# 4. è¿›ç¨‹ç»“æŸåä¸´æ—¶ç›®å½•è¢«æ¸…ç†
# 5. ç”¨æˆ·çš„æ­£å¸¸Chromeä¸å—å½±å“
```

### æ€§èƒ½åŸºå‡†
- **å¯åŠ¨æ—¶é—´**ï¼šChromeå®ä¾‹å¯åŠ¨åˆ°å°±ç»ª <10ç§’
- **å†…å­˜å¼€é”€**ï¼šç‹¬ç«‹Chromeå®ä¾‹é¢å¤–å†…å­˜å ç”¨ <200MB
- **æ¸…ç†æ•ˆç‡**ï¼šè¿›ç¨‹å’Œä¸´æ—¶æ–‡ä»¶æ¸…ç† <5ç§’
- **è·¨å¹³å°å…¼å®¹æ€§**ï¼šWindows/macOS/Linux Chromeè·¯å¾„æ£€æµ‹æˆåŠŸç‡ >95%