# Design 1-1-1 - 独立Chrome实例管理器

## Requirements

### 核心目标
- **独立Chrome实例启动**：自动启动专门用于监控的Chrome实例
- **用户数据目录隔离**：与用户日常Chrome完全分离，避免干扰
- **生命周期管理**：Chrome实例与监控程序生命周期绑定
- **跨平台支持**：Windows、macOS的Chrome路径自动检测
- **安全性保证**：仅在监控期间开启调试模式，结束后完全清理

### 技术约束
- **不影响用户Chrome**：独立实例，不干扰用户正常浏览
- **自动端口分配**：自动查找可用调试端口，避免冲突
- **完全清理**：程序结束后自动清理临时目录和进程
- **容错处理**：Chrome启动失败时的优雅降级和错误提示

## Solution

### 专家评审意见应对

**🔒 致命问题修复（第二轮）**：
- ✅ **安全漏洞** → 添加`--remote-debugging-address=127.0.0.1`强制本地绑定
- ✅ **Windows兼容** → stderr文件先close()再unlink()，避免句柄冲突

**🛡️ 高风险优化（第二轮）**：
- ✅ **方法设计明确** → `_wait_for_chrome_ready`和`_register_cleanup`详细设计要点
- ✅ **重试逻辑改进** → 启动超时也走端口重试路径，提高成功率  
- ✅ **URL编码严谨** → 使用`Path.as_uri()`和正确的safe字符集
- ✅ **参数保守调整** → 移除可能有风险的`--disable-ipc-flooding-protection`

**第一轮风险控制**：
- ✅ **端口竞态** → 启动失败重试机制，最多5次尝试不同端口
- ✅ **路径硬编码** → 环境变量覆盖 + 构造器参数传入
- ✅ **启动诊断** → Verbose模式stderr保留到日志文件
- ✅ **资源遗留** → atexit兜底 + async context manager + 三重清理保险

### 核心类设计

**ChromeInstanceManager类（生产级独立实例管理器）**
```python
import os
import sys
import tempfile
import subprocess
import socket
import shutil
import asyncio
import atexit
import logging
import urllib.parse
from pathlib import Path
from typing import Optional, List

class ChromeInstanceManager:
    """生产级Chrome独立实例管理器"""
    
    def __init__(self, chrome_path: Optional[str] = None, max_port_attempts: int = 5):
        self.chrome_process: Optional[subprocess.Popen] = None
        self.temp_user_data_dir: Optional[str] = None
        self.debug_port: Optional[int] = None
        self.chrome_path = chrome_path  # 支持构造器传入
        self.max_port_attempts = max_port_attempts
        self._cleanup_registered = False
        self._stderr_file: Optional[tempfile._TemporaryFileWrapper] = None
        
    async def launch_isolated_chrome(self) -> str:
        """启动独立Chrome实例，返回连接地址"""
        for attempt in range(self.max_port_attempts):
            try:
                # 每次尝试都重新准备环境（避免端口竞态）
                await self._prepare_launch_environment(attempt)
                await self._launch_chrome_process()
                await self._wait_for_chrome_ready(timeout=15)
                
                # 启动成功，注册清理机制
                self._register_cleanup()
                return f"127.0.0.1:{self.debug_port}"
                
            except (ChromeStartupError, OSError, ConnectionError) as e:
                # 清理当前尝试的资源
                await self._cleanup_current_attempt()
                
                # 🔧 改进：扩展重试条件，包括启动超时
                should_retry = (
                    "port" in str(e).lower() or 
                    "address already in use" in str(e).lower() or
                    "startup timeout" in str(e).lower() or  # 新增：启动超时也重试
                    "connection" in str(e).lower()
                )
                
                if should_retry:
                    logging.debug(f"Chrome launch failed (attempt {attempt + 1}/{self.max_port_attempts}): {e}")
                    if attempt == self.max_port_attempts - 1:
                        raise ChromeInstanceError(f"All {self.max_port_attempts} attempts failed. Last error: {e}")
                    continue
                else:
                    # 非可重试错误，直接抛出
                    raise
        
        raise ChromeInstanceError("Maximum retry attempts exceeded")
    
    async def _prepare_launch_environment(self, attempt: int):
        """准备启动环境（端口和目录）"""
        # 1. 检测Chrome路径（支持环境变量覆盖）
        if not self.chrome_path:
            self.chrome_path = self._detect_chrome_path()
            if not self.chrome_path:
                raise ChromeInstanceError("Chrome executable not found")
        
        # 2. 创建独立的用户数据目录
        self.temp_user_data_dir = tempfile.mkdtemp(
            prefix=f"browserfairy_chrome_{attempt}_"
        )
        
        # 3. 选择端口（每次尝试递增避免连续端口冲突）
        base_port = 9222 + (attempt * 10)
        self.debug_port = self._select_port_carefully(base_port)
    
    def _detect_chrome_path(self) -> Optional[str]:
        """检测Chrome路径，支持环境变量覆盖"""
        # 1. 优先使用环境变量
        env_chrome_path = os.environ.get("BROWSERFAIRY_CHROME_PATH")
        if env_chrome_path and os.path.exists(env_chrome_path) and os.access(env_chrome_path, os.X_OK):
            logging.info(f"Using Chrome path from environment: {env_chrome_path}")
            return env_chrome_path
        
        # 2. 检测系统默认路径
        if sys.platform == "darwin":  # macOS优先支持
            possible_paths = [
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
                "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
                "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
                # 用户安装路径
                os.path.expanduser("~/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"),
            ]
        elif sys.platform == "win32":  # Windows支持
            possible_paths = [
                os.path.expandvars(r"%ProgramFiles%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%ProgramFiles(x86)%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%LocalAppData%\Google\Chrome\Application\chrome.exe"),
                os.path.expandvars(r"%LocalAppData%\Google\Chrome Beta\Application\chrome.exe"),
                # 便携版路径
                os.path.expandvars(r"%LocalAppData%\Google\Chrome\chrome.exe"),
            ]
        else:
            raise ChromeInstanceError(f"Platform {sys.platform} is not supported. Please set BROWSERFAIRY_CHROME_PATH environment variable.")
        
        # 查找可用路径
        for path in possible_paths:
            if os.path.exists(path) and os.access(path, os.X_OK):
                logging.debug(f"Found Chrome at: {path}")
                return path
        
        return None
    
    def _select_port_carefully(self, base_port: int, max_attempts: int = 10) -> int:
        """谨慎选择可用端口"""
        for port in range(base_port, base_port + max_attempts):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('127.0.0.1', port))
                    return port
            except OSError:
                continue
        
        raise ChromeInstanceError(f"Ports {base_port}-{base_port + max_attempts - 1} are all busy. Please close other debugging applications.")
    
    async def _launch_chrome_process(self):
        """启动Chrome进程，保留诊断信息"""
        chrome_cmd = self._build_chrome_command()
        
        # 根据verbose模式处理stderr
        if logging.getLogger().isEnabledFor(logging.DEBUG):
            # Debug模式：保留stderr到临时文件用于排错
            self._stderr_file = tempfile.NamedTemporaryFile(
                mode='w+', 
                prefix='browserfairy_chrome_stderr_', 
                suffix='.log', 
                delete=False
            )
            stderr_target = self._stderr_file
            logging.debug(f"Chrome stderr will be logged to: {self._stderr_file.name}")
        else:
            # 正常模式：静默启动
            stderr_target = subprocess.DEVNULL
        
        try:
            self.chrome_process = subprocess.Popen(
                chrome_cmd,
                stdout=subprocess.DEVNULL,
                stderr=stderr_target,
                # POSIX平台独立进程组，便于清理
                start_new_session=(os.name == 'posix')
            )
            logging.info(f"Chrome process started with PID: {self.chrome_process.pid}")
            
        except Exception as e:
            # 启动失败时，尝试读取错误信息
            error_info = ""
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.seek(0)
                    error_info = f"\nChrome stderr: {self._stderr_file.read()}"
                except:
                    pass
            
            raise ChromeStartupError(f"Failed to start Chrome process: {e}{error_info}")
    
    def _build_chrome_command(self) -> List[str]:
        """构建Chrome启动命令（安全的本地绑定 + 保守优化参数）"""
        # 基础调试参数 - 安全第一
        base_args = [
            f"--remote-debugging-port={self.debug_port}",
            "--remote-debugging-address=127.0.0.1",  # 🔒 致命修复：强制本地绑定
            f"--user-data-dir={self.temp_user_data_dir}",
            "--no-first-run",
            "--no-default-browser-check",
            "--disable-default-apps",
            "--disable-extensions",
            "--disable-popup-blocking",
        ]
        
        # 保守的优化参数（移除可能有风险的选项）
        safe_optimization_args = [
            "--disable-background-networking",
            "--disable-component-update", 
            "--disable-features=Translate",
            "--disable-client-side-phishing-detection",
            "--disable-sync",
            "--disable-background-timer-throttling",
            "--disable-renderer-backgrounding",
            "--disable-backgrounding-occluded-windows",
            # 🔧 移除：--disable-ipc-flooding-protection（可能降低稳定性）
            # 如果真的遇到吞吐瓶颈，再单独评估添加
        ]
        
        return [self.chrome_path] + base_args + safe_optimization_args + [self._get_startup_url()]
    
    def _get_startup_url(self) -> str:
        """获取启动页面URL（严谨的URL编码）"""
        data_dir = Path.home() / "BrowserFairyData"
        
        # 🔧 修复：使用Path.as_uri()正确构建file URL
        data_dir_uri = data_dir.as_uri()
        
        # 严谨的HTML内容构建
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrowserFairy Monitoring</title>
</head>
<body style="font-family: Arial, sans-serif; padding: 40px; text-align: center; background: #f5f5f5;">
    <h1 style="color: #2196F3;">🧚 BrowserFairy Monitoring Active</h1>
    <p style="font-size: 18px; color: #333;">Please browse normally in this Chrome window.</p>
    <p style="color: #666;">Performance data is being collected automatically.</p>
    <hr style="margin: 30px 0; border: none; border-top: 1px solid #ddd;">
    <h3 style="color: #555;">Quick Access:</h3>
    <p><a href="{data_dir_uri}" style="color: #2196F3; text-decoration: none;">📂 View Data Directory</a></p>
    <p><small style="color: #999;">Close this Chrome window to stop monitoring</small></p>
</body>
</html>"""
        
        # 🔧 修复：使用正确的safe字符集编码data URL
        return "data:text/html;charset=utf-8," + urllib.parse.quote(html_content, safe=':/?#[]@!$&\'()*+,;=')
    
    async def _wait_for_chrome_ready(self, timeout: int = 15):
        """等待Chrome完全启动并可接受连接
        
        设计要点：
        - 轮询 http://127.0.0.1:port/json/version 端点
        - 检测间隔：每0.5秒一次
        - HTTP超时：单次请求1秒超时  
        - 总体超时：达到timeout秒后抛出ChromeStartupError
        - 成功标志：HTTP 200响应且JSON格式正确
        """
        import httpx
        
        start_time = asyncio.get_event_loop().time()
        while asyncio.get_event_loop().time() - start_time < timeout:
            try:
                async with httpx.AsyncClient(timeout=1.0) as client:  # 单次1秒超时
                    response = await client.get(f"http://127.0.0.1:{self.debug_port}/json/version")
                    if response.status_code == 200:
                        # 验证响应是有效JSON
                        response.json()  # 如果不是JSON会抛异常
                        logging.info(f"Chrome is ready on port {self.debug_port}")
                        return
            except Exception as e:
                logging.debug(f"Chrome not ready yet: {e}")
            
            await asyncio.sleep(0.5)  # 0.5秒检测间隔
        
        raise ChromeStartupError(f"Chrome startup timeout after {timeout}s")
    
    def _register_cleanup(self):
        """注册清理保险机制
        
        设计要点：
        - 幂等性：多次调用只注册一次atexit钩子
        - 避免竞态：atexit调用同步版本紧急清理函数
        - 进程退出兜底：确保异常退出时也能清理资源
        """
        if not self._cleanup_registered:
            atexit.register(self._emergency_cleanup)  # 同步版本避免异步竞态
            self._cleanup_registered = True
            logging.debug("Cleanup mechanism registered")
    
    def _emergency_cleanup(self):
        """紧急清理（同步版本，用于atexit）"""
        try:
            # 清理Chrome进程
            if self.chrome_process and self.chrome_process.poll() is None:
                logging.warning("Emergency cleanup: terminating Chrome process")
                self.chrome_process.terminate()
                try:
                    self.chrome_process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    logging.warning("Emergency cleanup: force killing Chrome process")
                    self.chrome_process.kill()
                    
            # 清理临时目录
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                logging.warning(f"Emergency cleanup: removing temp directory {self.temp_user_data_dir}")
                shutil.rmtree(self.temp_user_data_dir, ignore_errors=True)
                
            # 🔒 致命修复：先关闭再删除（Windows兼容）
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.close()
                    os.unlink(self._stderr_file.name)
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file in emergency: {e}")
                    
        except Exception as e:
            logging.error(f"Emergency cleanup failed: {e}")
    
    async def _cleanup_current_attempt(self):
        """清理当前尝试的资源"""
        try:
            # 清理进程
            if self.chrome_process:
                if self.chrome_process.poll() is None:
                    self.chrome_process.terminate()
                    try:
                        await asyncio.wait_for(
                            asyncio.to_thread(self.chrome_process.wait),
                            timeout=3.0
                        )
                    except asyncio.TimeoutError:
                        self.chrome_process.kill()
                self.chrome_process = None
            
            # 清理临时目录
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                await asyncio.to_thread(shutil.rmtree, self.temp_user_data_dir, ignore_errors=True)
                self.temp_user_data_dir = None
            
            # 🔒 致命修复：先关闭再删除（Windows兼容）
            if self._stderr_file:
                try:
                    self._stderr_file.close()
                    await asyncio.to_thread(os.unlink, self._stderr_file.name)
                    self._stderr_file = None
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file: {e}")
                    
        except Exception as e:
            logging.debug(f"Cleanup current attempt error: {e}")
    
    def is_chrome_running(self) -> bool:
        """检查Chrome实例是否还在运行"""
        if self.chrome_process is None:
            return False
        
        # 检查进程状态
        poll_result = self.chrome_process.poll()
        return poll_result is None
    
    async def wait_for_chrome_exit(self):
        """等待Chrome实例退出（用户关闭浏览器）"""
        if not self.chrome_process:
            return
            
        while self.is_chrome_running():
            await asyncio.sleep(1.0)
    
    async def cleanup(self):
        """完整的资源清理"""
        try:
            # 1. 优雅终止Chrome进程
            if self.chrome_process and self.chrome_process.poll() is None:
                logging.info("Gracefully terminating Chrome process...")
                self.chrome_process.terminate()
                
                try:
                    await asyncio.wait_for(
                        asyncio.to_thread(self.chrome_process.wait), 
                        timeout=5.0
                    )
                    logging.info("Chrome process terminated gracefully")
                except asyncio.TimeoutError:
                    logging.warning("Chrome process didn't terminate gracefully, force killing...")
                    self.chrome_process.kill()
                    await asyncio.to_thread(self.chrome_process.wait)
            
            # 2. 清理临时用户数据目录
            if self.temp_user_data_dir and os.path.exists(self.temp_user_data_dir):
                logging.info(f"Cleaning up temp directory: {self.temp_user_data_dir}")
                await asyncio.to_thread(shutil.rmtree, self.temp_user_data_dir, ignore_errors=True)
            
            # 3. 🔒 致命修复：先关闭再删除stderr日志文件（Windows兼容）
            if hasattr(self, '_stderr_file') and self._stderr_file:
                try:
                    self._stderr_file.close()
                    await asyncio.to_thread(os.unlink, self._stderr_file.name)
                except Exception as e:
                    logging.debug(f"Failed to cleanup stderr file: {e}")
                    
            # 4. 重置状态
            self.chrome_process = None
            self.temp_user_data_dir = None
            self.debug_port = None
            
            logging.info("Chrome instance cleanup completed")
            
        except Exception as e:
            logging.error(f"Cleanup error (non-fatal): {e}")
    
    # 支持async context manager语义
    async def __aenter__(self):
        """异步上下文管理器入口"""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """异步上下文管理器退出时自动清理"""
        await self.cleanup()


class ChromeInstanceError(Exception):
    """Chrome实例管理相关错误"""
    pass


class ChromeStartupError(ChromeInstanceError):
    """Chrome启动相关错误"""
    pass
```

### 与现有架构集成

**扩展1-1的ChromeConnector使用独立实例**：
```python
# 在未来的集成中，ChromeConnector可以接受ChromeInstanceManager
class EnhancedChromeConnector(ChromeConnector):
    def __init__(self, chrome_manager: Optional[ChromeInstanceManager] = None, 
                 host: str = "127.0.0.1", port: int = 9222):
        if chrome_manager:
            # 使用独立Chrome实例
            self.chrome_manager = chrome_manager
            super().__init__(host="127.0.0.1", port=chrome_manager.debug_port)
        else:
            # 使用传统方式（兼容现有功能）
            super().__init__(host, port)
            self.chrome_manager = None
    
    async def connect_with_managed_chrome(self):
        """连接到托管的Chrome实例"""
        if self.chrome_manager:
            host_port = await self.chrome_manager.launch_isolated_chrome()
            host, port = host_port.split(":")
            self.host = host
            self.port = int(port)
        
        await self.connect()
```

## Tests

### 单元测试
1. **Chrome路径检测测试**
   - `test_detect_chrome_path_windows()` - Windows平台Chrome路径检测
   - `test_detect_chrome_path_macos()` - macOS平台Chrome路径检测  
   - `test_chrome_path_environment_override()` - 环境变量覆盖路径测试
   - `test_chrome_path_constructor_override()` - 构造器参数覆盖路径测试
   - `test_chrome_path_not_found()` - Chrome未安装时的处理

2. **端口管理测试**
   - `test_select_port_carefully()` - 谨慎端口选择
   - `test_port_conflict_resolution()` - 端口冲突解决
   - `test_no_available_ports()` - 无可用端口时的错误处理
   - `test_port_race_condition_resilience()` - **端口竞态条件恢复能力测试**

3. **实例管理测试**
   - `test_chrome_command_building()` - Chrome启动命令构建
   - `test_optimization_args_inclusion()` - 优化参数包含测试
   - `test_user_data_directory_isolation()` - 用户数据目录隔离
   - `test_cleanup_resources()` - 资源清理完整性
   - `test_url_encoding_correctness()` - **URL编码正确性测试**

4. **错误诊断测试**
   - `test_chrome_startup_error_diagnosis()` - **Chrome启动错误诊断信息保留**
   - `test_stderr_logging_in_debug_mode()` - Debug模式stderr日志记录
   - `test_stderr_silent_in_normal_mode()` - 正常模式静默启动

### 集成测试（需要Chrome安装）
1. **Chrome实例生命周期测试**
   - `test_launch_isolated_chrome()` - 独立Chrome实例启动
   - `test_chrome_ready_detection()` - Chrome就绪状态检测
   - `test_chrome_connection()` - CDP连接建立
   - `test_graceful_shutdown()` - 优雅关闭处理

2. **多实例并行测试**
   - `test_multiple_instances_isolation()` - **多个独立实例完全隔离测试**
   - `test_port_auto_assignment()` - 自动端口分配
   - `test_user_data_isolation()` - 用户数据完全隔离
   - `test_concurrent_startup()` - 并发启动测试

3. **错误恢复测试**
   - `test_chrome_crash_recovery()` - Chrome崩溃时的处理
   - `test_startup_timeout()` - 启动超时处理
   - `test_cleanup_on_failure()` - 启动失败时的资源清理
   - `test_port_retry_mechanism()` - **端口重试机制测试**

4. **资源管理测试**
   - `test_resource_cleanup_completeness()` - **资源清理完整性测试**
   - `test_emergency_cleanup_mechanism()` - **紧急清理机制测试**
   - `test_async_context_manager()` - async context manager测试
   - `test_atexit_cleanup()` - atexit清理机制测试

### 高风险场景测试（专家评审覆盖）
```python
# 专家建议的关键测试用例

async def test_port_race_condition_resilience():
    """测试端口竞态条件的恢复能力"""
    # 同时启动多个实例，验证端口冲突重试
    managers = [ChromeInstanceManager() for _ in range(3)]
    tasks = [manager.launch_isolated_chrome() for manager in managers]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # 至少一个成功，其他的应该能自动重试到其他端口
    successful = [r for r in results if isinstance(r, str)]
    assert len(successful) >= 1, "At least one instance should start successfully"

async def test_chrome_path_environment_override():
    """测试环境变量覆盖Chrome路径"""
    with patch.dict(os.environ, {"BROWSERFAIRY_CHROME_PATH": "/fake/chrome/path"}):
        manager = ChromeInstanceManager()
        with pytest.raises(ChromeInstanceError, match="Chrome executable not found"):
            await manager.launch_isolated_chrome()

async def test_chrome_startup_error_diagnosis():
    """测试Chrome启动错误的诊断信息保留"""
    manager = ChromeInstanceManager(chrome_path="/nonexistent/chrome")
    
    with pytest.raises(ChromeStartupError) as exc_info:
        await manager.launch_isolated_chrome()
    
    assert "Failed to start Chrome process" in str(exc_info.value)

async def test_resource_cleanup_completeness():
    """测试资源清理的完整性"""
    manager = ChromeInstanceManager()
    
    # 启动并记录资源
    address = await manager.launch_isolated_chrome()
    temp_dir = manager.temp_user_data_dir
    chrome_pid = manager.chrome_process.pid
    
    # 验证资源存在
    assert os.path.exists(temp_dir)
    assert manager.chrome_process.poll() is None
    
    # 执行清理
    await manager.cleanup()
    
    # 验证资源已清理
    assert not os.path.exists(temp_dir)
    assert manager.chrome_process.poll() is not None

async def test_multiple_instances_isolation():
    """测试多实例的完全隔离"""
    manager1 = ChromeInstanceManager()
    manager2 = ChromeInstanceManager()
    
    try:
        # 同时启动两个实例
        address1 = await manager1.launch_isolated_chrome()
        address2 = await manager2.launch_isolated_chrome()
        
        # 验证使用不同端口
        port1 = int(address1.split(':')[1])
        port2 = int(address2.split(':')[1]) 
        assert port1 != port2, "Instances should use different ports"
        
        # 验证使用不同的用户数据目录
        assert manager1.temp_user_data_dir != manager2.temp_user_data_dir
        assert os.path.exists(manager1.temp_user_data_dir)
        assert os.path.exists(manager2.temp_user_data_dir)
        
    finally:
        await manager1.cleanup()
        await manager2.cleanup()

def test_emergency_cleanup_mechanism():
    """测试紧急清理机制（atexit）"""
    manager = ChromeInstanceManager()
    
    # 模拟启动过程中的状态设置
    manager.temp_user_data_dir = tempfile.mkdtemp(prefix="test_emergency_")
    manager.chrome_process = MockProcess(pid=12345)
    manager._cleanup_registered = True
    
    # 调用紧急清理
    manager._emergency_cleanup()
    
    # 验证清理效果
    assert not os.path.exists(manager.temp_user_data_dir)
    assert manager.chrome_process.terminated
```

### 验收测试
```bash
# 测试独立Chrome实例启动
python -c "
import asyncio
from browserfairy.core.chrome_instance import ChromeInstanceManager

async def test():
    manager = ChromeInstanceManager()
    try:
        address = await manager.launch_isolated_chrome()
        print(f'Chrome launched at: {address}')
        print('Chrome process ID:', manager.chrome_process.pid)
        print('Temp data dir:', manager.temp_user_data_dir)
        
        # 等待用户验证
        input('Press Enter after verifying Chrome opened...')
        
    finally:
        await manager.cleanup()
        print('Cleanup completed')

asyncio.run(test())
"

# 验证事项：
# 1. 新的Chrome窗口应该打开（与用户已有Chrome分离）
# 2. 窗口标题显示调试模式
# 3. 启动页面显示监控状态
# 4. 进程结束后临时目录被清理
# 5. 用户的正常Chrome不受影响
```

### 性能基准
- **启动时间**：Chrome实例启动到就绪 <10秒
- **内存开销**：独立Chrome实例额外内存占用 <200MB
- **清理效率**：进程和临时文件清理 <5秒
- **跨平台兼容性**：Windows/macOS/Linux Chrome路径检测成功率 >95%