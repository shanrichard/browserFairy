# Design 1-4 - 单个性能指标收集器 [COMPLETED]

## Requirements

### 核心目标
- **专注内存指标收集**：从内存监控开始，作为性能数据收集的验证原型
- **Target级会话管理**：引入`Target.attachToTarget`建立个别标签页的CDP会话
- **定时采样机制**：每5秒收集一次内存快照，提供时序数据
- **按网站分离数据**：每个hostname独立收集，便于后续按站点分析
- **不影响现有功能**：与TabMonitor松耦合集成，不破坏1-1到1-3的功能

### 具体内存指标（基于Performance.getMetrics高效实现）
**JavaScript内存**：
- JS堆内存使用量/总量 (Performance.getMetrics: JSHeapUsedSize/JSHeapTotalSize)
- 堆内存限制 (performance.memory，可选补充)

**DOM相关**：
- DOM节点总数 (Performance.getMetrics: Nodes，高效内置统计)
- 事件监听器数量 (Performance.getMetrics: JSEventListeners)
- Document和Frame数量 (Performance.getMetrics: Documents/Frames)

**性能辅助指标**：
- 布局和样式重计算次数/耗时 (Performance.getMetrics: LayoutCount/RecalcStyleCount/LayoutDuration/RecalcStyleDuration)
- JavaScript执行时间 (Performance.getMetrics: ScriptDuration)

### 技术约束
- **不影响页面性能**：监控开销 <1% CPU
- **会话生命周期管理**：标签页关闭/导航时自动清理
- **错误恢复**：CDP会话失败时优雅降级，不影响其他功能
- **内存控制**：避免监控器本身成为内存泄漏源

## Solution

### 核心架构设计

**最小化扩展现有架构**：
```
ChromeConnector (1-1, 已优化) 
    ↓ 复用连接和sessionId路由能力
TabMonitor (1-3, 已优化)
    ↓ 通过回调通知标签页变化
MemoryCollector (1-4, 新增)
    ↓ Target级会话 + 内存数据收集
数据回调 → 后续1-5数据写入器
```

### 核心类设计

**1. MemoryCollector类（核心新增）**
```python
class MemoryCollector:
    """单个标签页的内存指标收集器"""
    
    def __init__(self, connector: ChromeConnector, target_id: str, hostname: str, 
                 data_callback: Optional[Callable] = None):
        self.connector = connector
        self.target_id = target_id
        self.hostname = hostname
        self.session_id: Optional[str] = None
        self.collection_task: Optional[asyncio.Task] = None
        self.data_callback = data_callback
        self.running = False
```

**关键方法**：
- `attach()` - Target.attachToTarget建立会话 (flatten=true)
- `collect_memory_snapshot()` - 收集单次内存快照
- `start_collection(interval=5.0)` - 开始定时收集
- `stop_collection()` - 停止并清理会话
- `detach()` - Target.detachFromTarget清理
- `update_page_info(url, title)` - 更新页面URL/title元信息（供TabMonitor集成使用）

**2. MemoryMonitor类（协调器）**
```python  
class MemoryMonitor:
    """管理多个标签页的内存收集器"""
    
    def __init__(self, tab_monitor: TabMonitor, connector: ChromeConnector):
        self.collectors: Dict[str, MemoryCollector] = {}  # targetId -> collector
        self.tab_monitor = tab_monitor
        self.connector = connector
```

### 技术实现细节

**1. Target会话管理（关键新技术）**
```python
# 建立Target级会话
response = await self.connector.call(
    "Target.attachToTarget", 
    {"targetId": self.target_id, "flatten": True}
)
self.session_id = response["sessionId"]

# 使用sessionId发送命令到特定标签页
memory_data = await self.connector.call(
    "Runtime.evaluate",
    {"expression": "performance.memory", "returnByValue": True},
    session_id=self.session_id
)
```

**2. 数据收集策略（基于专家建议优化）**

**唯一权威数据收集方案**:
```python
async def collect_memory_snapshot(self) -> Dict[str, Any]:
    """收集内存快照 - 唯一实现，避免重复示例"""
    
    # 权威指标提取清单 - 与输出JSON字段完全对应
    REQUIRED_METRICS = {
        # memory字段映射
        "JSHeapUsedSize": "memory.jsHeap.used",
        "JSHeapTotalSize": "memory.jsHeap.total", 
        "JSEventListeners": "memory.listeners",
        "Documents": "memory.documents",
        "Nodes": "memory.domNodes", 
        "Frames": "memory.frames",
        # performance字段映射
        "LayoutCount": "performance.layoutCount",
        "RecalcStyleCount": "performance.recalcStyleCount",
        "LayoutDuration": "performance.layoutDuration",
        "RecalcStyleDuration": "performance.recalcStyleDuration", 
        "ScriptDuration": "performance.scriptDuration"
    }
    
    # 1. 获取Performance.getMetrics（主要数据源）
    metrics_response = await self.connector.call(
        "Performance.getMetrics", 
        session_id=self.session_id
    )
    
    # 2. 提取指标，严格按清单映射，缺失置null
    extracted = {}
    available_metrics = {m["name"]: m["value"] for m in metrics_response["metrics"]}
    
    for metric_name in REQUIRED_METRICS:
        extracted[metric_name] = available_metrics.get(metric_name, None)
    
    # 3. 可选补充：仅获取jsHeapSizeLimit（简化Runtime.evaluate）
    heap_limit = None
    try:
        limit_result = await self.connector.call(
            "Runtime.evaluate",
            {"expression": "performance.memory?.jsHeapSizeLimit", "returnByValue": True},
            session_id=self.session_id
        )
        heap_limit = limit_result.get("result", {}).get("value")
    except:
        pass  # 失败时保持null
    
    # 4. 构建输出（使用TabMonitor维护的url/title，不重复获取）
    return {
        "timestamp": datetime.now().isoformat() + "Z",
        "hostname": self.hostname,
        "targetId": self.target_id,
        "url": self.current_url,  # 来自update_page_info
        "title": self.current_title,  # 来自update_page_info
        "memory": {
            "jsHeap": {
                "used": extracted["JSHeapUsedSize"],
                "total": extracted["JSHeapTotalSize"],
                "limit": heap_limit  # 可选，缺失时为null
            },
            "domNodes": extracted["Nodes"],
            "listeners": extracted["JSEventListeners"],
            "documents": extracted["Documents"],
            "frames": extracted["Frames"]
        },
        "performance": {
            "layoutCount": extracted["LayoutCount"],
            "recalcStyleCount": extracted["RecalcStyleCount"],
            "layoutDuration": extracted["LayoutDuration"],
            "recalcStyleDuration": extracted["RecalcStyleDuration"],
            "scriptDuration": extracted["ScriptDuration"]
        }
    }
```


### 数据格式设计（标准化）

**输出数据结构（基于专家建议修正）**：
```json
{
    "timestamp": "2025-01-14T15:30:25.123Z",
    "hostname": "github.com", 
    "targetId": "ABC12345",
    "url": "https://github.com/user/repo",
    "title": "GitHub Repository",
    "memory": {
        "jsHeap": {
            "used": 45234567,        // 来自Performance.getMetrics JSHeapUsedSize
            "total": 67890123,       // 来自Performance.getMetrics JSHeapTotalSize
            "limit": 134217728       // 来自performance.memory（可选）
        },
        "domNodes": 1247,            // 来自Performance.getMetrics Nodes（高效）
        "listeners": 89,             // 来自Performance.getMetrics JSEventListeners
        "documents": 1,              // 来自Performance.getMetrics Documents
        "frames": 2                  // 来自Performance.getMetrics Frames
        // 删除detachedNodes - 专家建议移除不可行的指标
    },
    "performance": {
        "layoutCount": 12,           // 来自Performance.getMetrics LayoutCount
        "recalcStyleCount": 8,       // 来自Performance.getMetrics RecalcStyleCount
        "layoutDuration": 23.4,      // 来自Performance.getMetrics LayoutDuration
        "recalcStyleDuration": 15.2, // 来自Performance.getMetrics RecalcStyleDuration
        "scriptDuration": 156.7      // 来自Performance.getMetrics ScriptDuration
    }
}
```

### 与现有架构的集成

**1. TabMonitor集成（修正hostname导航更新问题）**
```python
# TabMonitor通过回调通知标签页变化
async def on_tab_event(event_type: str, payload: dict):
    target_id = payload["targetId"]
    hostname = payload["hostname"]
    
    if event_type == "CREATED":
        # 为新标签页创建内存收集器
        await memory_monitor.create_collector(target_id, hostname)
    elif event_type == "DESTROYED": 
        # 清理对应的内存收集器
        await memory_monitor.remove_collector(target_id)
    elif event_type == "URL_CHANGED":
        # 关键修复：hostname变化时重建collector
        current_collector = memory_monitor.collectors.get(target_id)
        if current_collector and current_collector.hostname != hostname:
            # hostname变化，重建collector确保数据正确分组
            await memory_monitor.remove_collector(target_id)
            await memory_monitor.create_collector(target_id, hostname)
        elif current_collector:
            # hostname未变化，仅更新URL/title元信息
            current_collector.update_page_info(payload["url"], payload.get("title", ""))

# 初始化时补种现有标签页（专家建议）
async def initialize_collectors():
    current_targets = await tab_monitor.get_current_targets()
    for target_id, target_info in current_targets.items():
        if target_info.get("hostname"):
            await memory_monitor.create_collector(target_id, target_info["hostname"])
```

**2. ChromeConnector复用**
- 复用现有的连接管理和重连机制
- 利用已优化的sessionId路由能力
- 复用连接丢失回调机制

**3. CLI层扩展（可选）**
```python
# 新增CLI命令用于测试
python -m browserfairy --collect-memory --duration 60
```

### 最小收敛实现（基于专家建议）

**1. 完整采样调度实现（专家建议的伪码）**
```python
# 全局并发控制
SAMPLING_SEMAPHORE = asyncio.Semaphore(8)  # 限制全局并发采样数

class MemoryCollector:
    def __init__(self, ...):
        # ...其他初始化
        self._collecting = False  # 互斥标志，避免重入
        self.running = False
    
    async def start_collection(self, interval: float = 5.0):
        self.running = True
        
        # 首次采样随机抖动，避免羊群效应
        initial_jitter = random.uniform(0, 1.0)
        await asyncio.sleep(initial_jitter)
        
        while self.running:
            # 等待下个采样周期（带抖动）
            next_interval = interval + random.uniform(-0.1, 0.1)  # 微小抖动
            await asyncio.sleep(next_interval)
            
            if not self.running:
                break
                
            # 每次采样内限流+互斥，无忙等
            async with SAMPLING_SEMAPHORE:  # 全局并发限制
                if self._collecting:
                    continue  # 跳过本次，不是忙等（因为有sleep）
                    
                self._collecting = True
                try:
                    await self.collect_memory_snapshot()
                finally:
                    self._collecting = False
    
    async def stop_collection(self):
        self.running = False  # 停止循环
        # 其余清理逻辑...
```

**2. 会话管理（修正调用上下文）**
```python
async def attach(self):
    # 先建立Target会话
    response = await self.connector.call(
        "Target.attachToTarget", 
        {"targetId": self.target_id, "flatten": True}
    )
    self.session_id = response["sessionId"]
    
    # 可选调用Performance.enable且必须带session_id=self.session_id
    # 有的环境未enable也能拿到指标，但部分版本/字段需要enable才完整
    try:
        await self.connector.call(
            "Performance.enable", 
            session_id=self.session_id  # 关键：发送到具体页面，不能用None
        )
    except:
        pass  # 失败可忽略，不影响核心功能

async def stop_collection(self):
    self.running = False
    if self.collection_task:
        self.collection_task.cancel()
        
    # 确保Target.detachFromTarget清理
    if self.session_id:
        try:
            await self.connector.call(
                "Target.detachFromTarget", 
                {"sessionId": self.session_id}
            )
        except:
            pass  # 清理时忽略错误
```

**3. 错误处理（最小化重试）**
- **会话失败**：捕获`ChromeConnectionError`执行一次detach→attach重试
- **采样失败**：Performance.getMetrics失败时记录警告，跳过本次采样
- **连接丢失**：依赖ChromeConnector的connection_lost_callback（1-6阶段集成）

**4. 关键实现细节**

**简化说明**：
- performance.memory不可用时置null，不用空字符串占位
- 缺失的指标统一置null，保持输出结构一致

**MemoryCollector.update_page_info明确说明**：
```python
def update_page_info(self, url: str, title: str):
    """仅更新缓存元信息，不做CDP evaluate，来源以TabMonitor事件为准"""
    self.current_url = url
    self.current_title = title
    # 不更新hostname，hostname变化应该重建collector
```

**初始化补种时机**：
```python
# 在TabMonitor.start_monitoring()完成_sync_targets()后调用
async def initialize_memory_monitoring():
    await tab_monitor.start_monitoring()  # 先完成标签页同步
    current_targets = await tab_monitor.get_current_targets()  # 获取完整初始集
    await memory_monitor.initialize_collectors(current_targets)
```

**收集器数量上限策略**：
```python
MAX_COLLECTORS = 50

async def create_collector(self, target_id: str, hostname: str):
    if len(self.collectors) >= MAX_COLLECTORS:
        # 溢出策略：淘汰最久未活动的collector
        oldest_id = min(self.collectors.keys(), 
                       key=lambda id: self.collectors[id].last_activity_time)
        await self.remove_collector(oldest_id)
    
    # 创建新collector
    self.collectors[target_id] = MemoryCollector(...)
```

## Tests

### 单元测试
1. **MemoryCollector核心功能**
   - `test_attach_detach()` - Target会话建立和清理
   - `test_collect_memory_snapshot()` - 内存数据收集格式验证
   - `test_collection_interval()` - 定时采样准确性
   - `test_session_failure_recovery()` - 会话失败恢复

2. **MemoryMonitor管理功能**
   - `test_collector_lifecycle()` - 收集器创建/销毁管理
   - `test_multiple_tabs()` - 多标签页并发收集
   - `test_tab_navigation_cleanup()` - 标签页变化时的清理

### 集成测试（需要Chrome实例）
1. **端到端内存收集**
   - `test_memory_collection_workflow()` - 完整的内存收集流程
   - `test_tab_monitor_integration()` - 与TabMonitor的集成测试
   - `test_multiple_websites()` - 多网站数据分离验证

2. **容错性测试**
   - `test_tab_crash_recovery()` - 标签页崩溃时的恢复
   - `test_chrome_restart_recovery()` - Chrome重启时的处理
   - `test_high_memory_page()` - 高内存使用页面的数据准确性

3. **性能影响测试**
   - `test_monitoring_overhead()` - 监控器的CPU和内存开销测试
   - `test_large_dom_handling()` - 大型DOM页面的处理能力
   - `test_long_running_stability()` - 长时间运行的稳定性

### 验收测试
```bash
# 测试单个标签页内存收集
python -m browserfairy --collect-memory --target-id ABC123

# 测试与标签页监控集成
python -m browserfairy --monitor-memory  # 新命令

# 输出示例：
# [2025-01-14 15:30:25] MEMORY: github.com - JS Heap: 45.2MB, DOM: 1247 nodes
# [2025-01-14 15:30:30] MEMORY: github.com - JS Heap: 46.1MB, DOM: 1251 nodes
```

### 性能基准
- **监控开销**：单个收集器 CPU占用 <0.1%，内存占用 <5MB
- **并发能力**：同时监控20个标签页，总开销 <2% CPU，<100MB内存
- **数据收集延迟**：单次收集完成时间 <500ms
- **会话管理效率**：建立/清理会话时间 <100ms