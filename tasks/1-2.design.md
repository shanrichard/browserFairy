# Design 1-2 - 简单的Chrome信息获取器

## Requirements
- 基于1-1的连接功能，实现Chrome信息获取
- 能获取Chrome版本、用户代理、系统信息
- 能获取当前所有打开的标签页基本信息（URL、标题）
- 提供清晰的输出格式，便于验证功能

## Solution

### 核心策略（基于专家建议修正）
严格限制在Browser级会话，避免任何Target会话复杂度：
- **Chrome信息**：仅使用`Browser.getVersion`（已有）
- **标签页列表**：使用`Target.getTargets`（Browser级调用）
- **明确不做**：不用`Runtime.evaluate`、不引入attach、不做事件监听

### 最小收敛实现
1. **扩展ChromeConnector**
   - 添加`get_targets()`方法，调用`Target.getTargets`
   - 页面过滤：只返回`type == 'page'`的目标
   - 保持Browser级会话，零sessionId复杂度

2. **CLI层轻薄格式化**
   - 移除InfoCollector类，直接在CLI层处理
   - 两个独立命令：`--chrome-info`、`--list-tabs`
   - 输出JSON格式，字段名与CDP响应一致

3. **失败处理复用1-1**
   - 沿用现有的连接/超时/错误处理
   - 不新增错误类型

### 响应格式处理
Target.getTargets返回格式：
```json
{
  "result": {
    "targetInfos": [
      {
        "targetId": "ABC123",
        "type": "page",
        "title": "Example Page",
        "url": "https://example.com",
        "attached": false
      }
    ]
  }
}
```

InfoCollector将提取和格式化：url、title、targetId

## Tests

### 单元测试
1. **ChromeConnector扩展测试**
   - `test_get_targets_call()` - 验证Target.getTargets调用格式
   - `test_page_filter()` - 验证只返回type='page'的目标

2. **InfoCollector测试**
   - `test_format_browser_info()` - 验证浏览器信息格式化
   - `test_format_tabs_info()` - 验证标签页信息格式化
   - `test_empty_tabs_handling()` - 处理无标签页情况

### 集成测试（需要Chrome实例）
1. **端到端信息收集**
   - `test_show_info_command()` - 完整的--show-info流程
   - `test_multiple_tabs()` - 多标签页信息获取
   - `test_tab_filtering()` - 过滤非页面目标（如扩展、worker等）

### 边界情况
- Chrome有标签页但都是特殊页面（chrome://、devtools://）
- 标签页标题包含特殊字符或为空
- URL超长的处理

### 验收测试
```bash
# Chrome版本信息
python -m browserfairy --chrome-info
# 输出JSON：{"product": "Chrome/91.0.4472.124", "protocolVersion": "1.3", "userAgent": "...", "jsVersion": "9.1.269.36"}

# 标签页列表
python -m browserfairy --list-tabs  
# 输出JSON：[{"targetId": "ABC123", "title": "Google", "url": "https://www.google.com", "type": "page"}]

# 空标签页情况
python -m browserfairy --list-tabs
# 输出JSON：[]
```

### CLI输出格式
- **JSON格式**：便于后续程序处理和Claude Code分析
- **CDP字段保持一致**：减少后续对接成本
- **简洁输出**：每个命令专注单一功能