# Design 2-3-6 - 分离DOM节点数监控

## Requirements

### 功能需求
实现分离DOM节点数量的监控，用于检测内存泄漏中的DOM对象未正确清理问题。

### 原始数据收集目标
- **数据类型**: 原始计数数据（不做分析指标）
- **数据来源**: Chrome DevTools Protocol Runtime domain
- **数据频率**: 与现有内存监控同步（5秒间隔）
- **数据精度**: 精确的detached DOM节点计数

### 诊断价值
- **内存泄漏检测**: 分离的DOM节点无法被GC回收，是典型的内存泄漏指标
- **DOM清理验证**: 验证应用是否正确清理了移除的DOM元素
- **性能问题定位**: 大量分离节点会导致内存占用增长和GC压力

### 技术约束
- **最小侵入**: 不破坏现有MemoryCollector架构
- **性能影响**: Runtime查询开销必须最小化
- **数据一致性**: 与现有内存数据在同一时间点采集

## Solution

### 架构设计原则

**最简单的实现方式**:
1. **扩展现有MemoryCollector**: 在现有的`_collect_metrics()`方法中添加一次额外的Runtime查询
2. **复用现有基础设施**: 使用相同的session、错误处理、数据格式
3. **保持数据结构一致**: 添加到现有的memory.jsonl输出中，不新增文件

### 技术实现方案

#### 1. Runtime查询方案

**使用Runtime.evaluate执行JavaScript查询**:
```javascript
// 查询分离DOM节点数的JavaScript代码
(() => {
  try {
    // 创建TreeWalker遍历整个DOM
    const walker = document.createTreeWalker(
      document.body || document.documentElement || document,
      NodeFilter.SHOW_ELEMENT,
      null,
      false
    );
    
    let detachedCount = 0;
    let node;
    
    // 检查每个节点是否与DOM树断开连接
    while (node = walker.nextNode()) {
      // 简单的分离检测：节点没有parentNode或不在document中
      if (!node.parentNode || !document.contains(node)) {
        detachedCount++;
      }
    }
    
    return detachedCount;
  } catch (e) {
    return -1; // 错误标记
  }
})()
```

**备选方案（更准确但开销更大）**:
```javascript
// 使用更精确的分离节点检测
(() => {
  try {
    // 收集所有DOM节点引用
    const allNodes = [];
    const walker = document.createTreeWalker(
      document,
      NodeFilter.SHOW_ALL,
      null,
      false
    );
    
    let node;
    while (node = walker.nextNode()) {
      allNodes.push(node);
    }
    
    // 检查分离的节点
    let detachedCount = 0;
    for (const node of allNodes) {
      if (node.nodeType === Node.ELEMENT_NODE && 
          !document.contains(node) && 
          node !== document.documentElement) {
        detachedCount++;
      }
    }
    
    return detachedCount;
  } catch (e) {
    return -1;
  }
})()
```

#### 2. MemoryCollector扩展方案

**在现有的_collect_metrics方法中添加查询**:

```python
async def _collect_metrics(self) -> Optional[Dict[str, Any]]:
    """现有的指标收集方法，添加分离DOM节点查询"""
    
    # ... 现有的metrics收集代码保持不变 ...
    
    # 新增：分离DOM节点数查询
    detached_dom_nodes = None
    try:
        # 执行JavaScript查询
        detached_result = await self.connector.call(
            "Runtime.evaluate", 
            {
                "expression": self._get_detached_nodes_query(),
                "returnByValue": True,
                "awaitPromise": False
            }, 
            session_id=self.session_id, 
            timeout=5.0  # 快速超时，避免影响主要监控
        )
        
        if detached_result and "result" in detached_result:
            detached_dom_nodes = detached_result["result"].get("value")
            if detached_dom_nodes == -1:  # 错误标记
                detached_dom_nodes = None
                
    except Exception as e:
        logger.debug(f"Failed to collect detached DOM nodes: {e}")
        detached_dom_nodes = None
    
    # ... 现有的数据构建代码 ...
    
    # 在返回数据中添加分离DOM节点数
    return {
        "type": "memory",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        # ... 现有字段保持不变 ...
        "memory": {
            "jsHeap": {
                "used": extracted["JSHeapUsedSize"],
                "total": extracted["JSHeapTotalSize"],
                "limit": heap_limit
            },
            "domNodes": extracted["Nodes"],
            "detachedDOMNodes": detached_dom_nodes,  # 新增字段
            # ... 其他现有字段 ...
        }
    }

def _get_detached_nodes_query(self) -> str:
    """返回分离DOM节点查询的JavaScript代码"""
    return """
    (() => {
      try {
        const walker = document.createTreeWalker(
          document.body || document.documentElement || document,
          NodeFilter.SHOW_ELEMENT,
          null,
          false
        );
        
        let detachedCount = 0;
        let node;
        while (node = walker.nextNode()) {
          if (!node.parentNode || !document.contains(node)) {
            detachedCount++;
          }
        }
        return detachedCount;
      } catch (e) {
        return -1;
      }
    })()
    """.strip()
```

#### 3. 数据结构设计

**扩展现有memory.jsonl格式**:
```json
{
  "type": "memory",
  "timestamp": "2025-08-18T14:30:25.123456Z",
  "hostname": "example.com",
  "targetId": "E4E4E4E4-1234-5678-9ABC-123456789ABC",
  "sessionId": "session123",
  "url": "https://example.com/page",
  "title": "Example Page",
  "memory": {
    "jsHeap": {
      "used": 52428800,
      "total": 83886080,
      "limit": 2197815296
    },
    "domNodes": 1247,
    "detachedDOMNodes": 15,  // 新增字段
    "eventListeners": 89,
    "documents": 1,
    "frames": 1,
    "performance": {
      "layoutCount": 45,
      "recalcStyleCount": 23,
      "layoutDuration": 12.5,
      "recalcStyleDuration": 8.3,
      "scriptDuration": 156.7
    }
  }
}
```

### 错误处理策略

**优雅降级原则**:
1. **查询失败**: detachedDOMNodes字段为null，不影响其他监控
2. **JavaScript错误**: 返回-1，记录debug日志
3. **超时处理**: 5秒超时，避免阻塞主要指标收集
4. **兼容性**: 旧版本Chrome可能不支持某些API，优雅处理

### 性能影响分析

**开销评估**:
- **CPU开销**: 单次DOM遍历，预计<50ms
- **内存开销**: 临时遍历对象，GC自动清理
- **网络开销**: 一次小的CDP调用，增加<1KB数据传输
- **总体影响**: <5%的额外开销，可接受

## Tests

### 测试驱动开发方案

#### 1. 单元测试设计

**测试文件**: `tests/test_detached_dom_monitoring.py`

```python
import pytest
from unittest.mock import AsyncMock, MagicMock
from browserfairy.monitors.memory import MemoryCollector

class TestDetachedDOMMonitoring:
    
    @pytest.fixture
    def memory_collector(self):
        """创建MemoryCollector测试实例"""
        mock_connector = AsyncMock()
        collector = MemoryCollector(
            connector=mock_connector,
            target_id="test_target",
            hostname="test.example.com"
        )
        collector.session_id = "test_session"
        return collector
    
    def test_detached_nodes_query_generation(self, memory_collector):
        """测试分离DOM节点查询代码生成"""
        query = memory_collector._get_detached_nodes_query()
        
        # 验证查询包含关键代码
        assert "createTreeWalker" in query
        assert "document.contains" in query
        assert "detachedCount" in query
        assert "return -1" in query  # 错误处理
    
    @pytest.mark.asyncio
    async def test_collect_detached_nodes_success(self, memory_collector):
        """测试成功收集分离DOM节点数"""
        # Mock CDP调用成功返回
        memory_collector.connector.call.return_value = {
            "result": {"value": 23}
        }
        
        # Mock其他必要的调用
        memory_collector.connector.call.side_effect = [
            {"result": [{"name": "JSHeapUsedSize", "value": 1000000}]},  # metrics
            {"result": {"value": 23}}  # detached nodes
        ]
        
        result = await memory_collector._collect_metrics()
        
        # 验证分离DOM节点数被正确包含
        assert result is not None
        assert "memory" in result
        assert "detachedDOMNodes" in result["memory"]
        assert result["memory"]["detachedDOMNodes"] == 23
    
    @pytest.mark.asyncio 
    async def test_collect_detached_nodes_failure(self, memory_collector):
        """测试分离DOM节点查询失败的处理"""
        # Mock CDP调用失败
        memory_collector.connector.call.side_effect = [
            {"result": [{"name": "JSHeapUsedSize", "value": 1000000}]},  # metrics成功
            Exception("CDP call failed")  # detached nodes失败
        ]
        
        result = await memory_collector._collect_metrics()
        
        # 验证失败时优雅降级
        assert result is not None
        assert "memory" in result
        assert result["memory"]["detachedDOMNodes"] is None
    
    @pytest.mark.asyncio
    async def test_collect_detached_nodes_javascript_error(self, memory_collector):
        """测试JavaScript执行错误的处理"""
        # Mock JavaScript返回错误标记
        memory_collector.connector.call.side_effect = [
            {"result": [{"name": "JSHeapUsedSize", "value": 1000000}]},  # metrics
            {"result": {"value": -1}}  # JavaScript错误标记
        ]
        
        result = await memory_collector._collect_metrics()
        
        # 验证JavaScript错误时的处理
        assert result is not None
        assert result["memory"]["detachedDOMNodes"] is None
    
    @pytest.mark.asyncio
    async def test_performance_impact(self, memory_collector):
        """测试性能影响控制"""
        import time
        
        # Mock快速响应
        memory_collector.connector.call.side_effect = [
            {"result": [{"name": "JSHeapUsedSize", "value": 1000000}]},
            {"result": {"value": 5}}
        ]
        
        start_time = time.time()
        result = await memory_collector._collect_metrics()
        end_time = time.time()
        
        # 验证执行时间合理（包含所有mock调用）
        assert end_time - start_time < 1.0  # 应该很快完成
        assert result["memory"]["detachedDOMNodes"] == 5

    def test_javascript_query_syntax(self, memory_collector):
        """测试JavaScript查询语法正确性"""
        query = memory_collector._get_detached_nodes_query()
        
        # 基本语法检查
        assert query.count("(") == query.count(")")  # 括号匹配
        assert query.count("{") == query.count("}")  # 大括号匹配
        assert "return" in query  # 有返回值
        assert query.strip().endswith(")")  # 立即执行函数
```

#### 2. 集成测试设计

**测试真实Chrome环境**:
```python
@pytest.mark.integration
class TestDetachedDOMIntegration:
    
    @pytest.mark.asyncio
    async def test_real_chrome_detached_nodes(self):
        """集成测试：真实Chrome环境下的分离DOM节点监控"""
        # 需要启动测试Chrome实例
        connector = ChromeConnector()
        await connector.connect()
        
        # 创建测试页面
        test_html = """
        <html><body>
        <div id="container"></div>
        <script>
          // 创建一些DOM元素然后移除
          for(let i = 0; i < 10; i++) {
            const div = document.createElement('div');
            document.body.appendChild(div);
            document.body.removeChild(div);
            // div现在是分离的DOM节点
          }
        </script>
        </body></html>
        """
        
        # ... 集成测试实现 ...
```

#### 3. 数据验证测试

**验证数据格式和精度**:
```python
def test_memory_data_format_with_detached_nodes():
    """测试包含分离DOM节点的数据格式"""
    # 模拟完整的memory数据
    memory_data = {
        "type": "memory",
        "timestamp": "2025-08-18T14:30:25.123456Z",
        "memory": {
            "jsHeap": {"used": 1000000, "total": 2000000},
            "domNodes": 100,
            "detachedDOMNodes": 15,  # 新字段
            "eventListeners": 50
        }
    }
    
    # 验证数据结构完整性
    assert "detachedDOMNodes" in memory_data["memory"]
    assert isinstance(memory_data["memory"]["detachedDOMNodes"], (int, type(None)))
```

### 实现步骤（TDD）

1. **Red**: 编写失败的测试用例
2. **Green**: 实现最简单的代码使测试通过  
3. **Refactor**: 重构代码保持测试通过
4. **重复**: 每个功能点都遵循TDD循环

### 验收标准

**功能验收**:
- [ ] MemoryCollector输出包含detachedDOMNodes字段
- [ ] JavaScript查询失败时优雅降级为null
- [ ] 数据采集频率与现有内存监控一致
- [ ] 不影响现有memory.jsonl数据格式

**性能验收**:
- [ ] 单次查询耗时<100ms
- [ ] 总体监控开销增加<10%
- [ ] 内存占用增加可忽略

**测试验收**:
- [ ] 单元测试覆盖率>90%
- [ ] 集成测试通过真实Chrome验证
- [ ] 错误场景测试覆盖完整

这个设计遵循最小侵入原则，通过简单扩展现有架构实现功能，同时保持数据收集的原始性质。