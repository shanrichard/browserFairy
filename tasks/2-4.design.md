# Design 2-4: AI编程友好配置功能

## Requirements

### 背景与动机

**问题定位转变**：BrowserFairy从"性能监控工具"重新定位为"AI编程辅助工具"，解决Claude Code/Cursor等AI编程工具无法获取浏览器运行时信息的痛点。

**核心痛点**：
1. AI编程工具生活在命令行中，无法看到浏览器里发生了什么
2. 服务端代码可以直接运行测试，但前端代码的运行时信息完全拿不到
3. 默认输出数据过多、格式复杂，AI难以理解
4. 数据默认保存在用户根目录，Claude Code无法访问项目外的文件

**目标用户场景**：
```
Claude写前端代码 → 用户发现bug → 启动BrowserFairy监控 → 复现问题 
→ 数据保存到项目目录 → Claude读取分析 → 基于真实数据修复bug
```

### 功能需求

#### 1. 数据目录配置（--data-dir）
- 支持指定监控数据的输出目录
- 默认值：`~/BrowserFairyData/`（保持向后兼容）
- 支持相对路径和绝对路径
- 自动创建不存在的目录

#### 2. 输出过滤器（--output）
- 控制要收集哪些类型的监控数据
- 支持逗号分隔的多个类型
- 支持细粒度控制（如 `console:error` 只收集错误级别）

#### 3. 预设模式
提供常用的数据收集组合：
- `errors-only`: 只收集错误信息（console错误、网络失败）
- `performance`: 性能相关数据（内存、网络时间、GC）
- `minimal`: 最小化输出（关键错误和内存摘要）
- `ai-debug`: AI调试优化（错误、内存泄漏检测、慢请求）
- `all`: 所有数据（默认，保持向后兼容）

#### 4. AI友好格式（--format）
- `original`: 原始完整格式（默认，保持向后兼容）
- `ai-simple`: 简化的JSON格式，去除冗余字段
- `summary`: 生成Markdown摘要报告

### 非功能需求

- **向后兼容**：不指定参数时行为与现有版本完全一致
- **性能影响**：过滤应在数据收集层进行，避免无用的数据处理
- **易用性**：参数命名直观，提供清晰的帮助信息
- **错误处理**：无效参数时给出友好提示

## Solution（最终版 - 纯过滤方案）

### 架构设计（仅实现过滤，不做格式转换）

#### 1. 配置数据流

```
CLI参数解析 (cli.py)
    ↓ 创建 MonitorConfig 对象
monitor_comprehensive(..., config) 
    ↓ 传递 config.data_dir 给
DataManager(data_dir=config.data_dir)
    ↓ 创建 unified_filtered_callback
comprehensive_data_callback中集中过滤
```

核心设计：
- 在callback层集中过滤，不修改各Monitor组件
- 保持DataManager纯粹，只传入data_dir参数
- 不做任何格式转换，只做过滤

#### 2. 实现层次（最小化方案）

##### 2.1 CLI参数扩展（cli.py）

```python
# 新增参数（在main()函数中）
parser.add_argument(
    '--data-dir',
    type=str,
    help='Directory to save monitoring data (default: ~/BrowserFairyData)'
)

parser.add_argument(
    '--output',
    type=str,
    default='all',
    help='Data types to collect: all, errors-only, performance, minimal, ai-debug, or comma-separated list'
)

# --format参数暂不实现（Phase 2考虑）
# 原因：AI格式转换存在破坏memory数据依赖链的风险
# 建议：先实现过滤功能，格式转换后续谨慎添加

# monitor_comprehensive函数签名修改
async def monitor_comprehensive(..., config: Optional[MonitorConfig] = None):
    if config is None:
        config = MonitorConfig()  # 默认配置保证向后兼容
```

##### 2.2 配置管理类（最小化实现）

```python
# browserfairy/config.py (新文件)

from pathlib import Path
from typing import List, Optional
from .utils.paths import ensure_data_directory

class MonitorConfig:
    """监控配置管理 - 最小化实现，保证向后兼容"""
    
    # 预设模式定义（根据专家建议调整）
    OUTPUT_PRESETS = {
        'all': ['*'],  # 默认，收集所有
        'errors-only': ['console:error', 'exception', 'network:failed'],
        'performance': ['memory', 'gc', 'network:complete'],  # 性能分析需要网络耗时
        'minimal': ['console:error', 'exception'],
        'ai-debug': ['console:error', 'exception', 'network:failed', 'memory']
    }
    
    def __init__(self, data_dir: Optional[str] = None, 
                 output: str = 'all', 
                 format_type: str = 'original'):
        """初始化配置
        
        Args:
            data_dir: 数据目录路径，None则使用默认
            output: 输出过滤器，预设名或逗号分隔列表
            format_type: 输出格式 original/ai-simple
        """
        self.data_dir = self._resolve_data_dir(data_dir)
        self.output_filters = self._parse_output(output)
        self.format = format_type
        
    def _resolve_data_dir(self, data_dir: Optional[str]) -> Path:
        """解析数据目录"""
        if data_dir is None:
            return ensure_data_directory()  # 使用默认
        
        path = Path(data_dir).expanduser().resolve()
        path.mkdir(parents=True, exist_ok=True)
        return path
        
    def _parse_output(self, output: str) -> List[str]:
        """解析输出过滤器"""
        if output in self.OUTPUT_PRESETS:
            return self.OUTPUT_PRESETS[output]
        
        # 自定义列表
        return [f.strip() for f in output.split(',')]
        
    def should_collect(self, data_type: str, level: Optional[str] = None) -> bool:
        """判断是否应该收集某类数据"""
        # 通配符
        if '*' in self.output_filters:
            return True
            
        # 完全匹配
        if data_type in self.output_filters:
            return True
            
        # 带级别匹配
        if level and f"{data_type}:{level}" in self.output_filters:
            return True
            
        return False
```

##### 2.3 Callback层集中处理（最小侵入实现）

```python
# 在monitor_comprehensive中创建过滤包装器

def create_unified_filtered_callback(data_manager, config):
    """创建带过滤功能的统一回调"""
    
    # 导入原始回调，避免命名冲突
    from browserfairy.cli import comprehensive_data_callback as original_callback
    
    async def unified_filtered_callback(data):
        """过滤后调用原始回调"""
        
        # 如果没有config，直接调用原始回调（向后兼容）
        if not config:
            await original_callback(data_manager, data)
            return
            
        # 使用data['type']判断类型
        data_type = data.get('type', '')
        
        # 过滤逻辑
        if data_type == 'memory':
            if not config.should_collect('memory'):
                return
                
        elif data_type == 'console':
            level = data.get('level', 'log')
            if not config.should_collect('console', level):
                return
                
        elif data_type == 'exception':
            if not config.should_collect('exception'):
                return
                
        elif data_type in ['network_request_start', 
                          'network_request_complete', 
                          'network_request_failed']:
            # 映射network子类型
            if data_type == 'network_request_failed':
                if not config.should_collect('network', 'failed'):
                    return
            elif data_type == 'network_request_complete':
                if not config.should_collect('network', 'complete'):
                    return
            elif data_type == 'network_request_start':
                if not config.should_collect('network', 'start'):
                    return
        
        # 调用原始回调（memory数据保持原始格式）
        await original_callback(data_manager, data)
    
    return unified_filtered_callback
```

##### 2.4 DataManager改造（最小改动）

```python
# DataManager只需要支持自定义数据目录，不需要其他改动

# 在monitor_comprehensive中：
if config and config.data_dir:
    data_manager = DataManager(connector, data_dir=config.data_dir)
else:
    data_manager = DataManager(connector)  # 使用默认目录

# DataManager现有签名已经支持：
# def __init__(self, connector, data_dir=None)
# 无需修改！
```


### 集成方式

#### monitor_comprehensive函数改造（最小改动）

```python
async def monitor_comprehensive(host, port, duration=None, status_callback=None, 
                              exit_event=None, config=None):
    """综合监控模式（支持配置）"""
    connector = ChromeConnector(host=host, port=port)
    
    # ... 现有连接逻辑
    
    # 创建DataManager（传入配置的数据目录）
    if config and config.data_dir:
        data_manager = DataManager(connector, data_dir=config.data_dir)
    else:
        data_manager = DataManager(connector)  # 使用默认
        
    # 创建回调
    if config:
        # 有配置时创建过滤包装器
        unified_callback = create_unified_filtered_callback(data_manager, config)
    else:
        # 无配置时使用原callback（保持向后兼容）
        from functools import partial
        unified_callback = partial(comprehensive_data_callback, data_manager)
        
    # 设置到memory_monitor（只设置一次，避免双写）
    memory_monitor.set_data_callback(unified_callback)
    
    # ... 继续现有逻辑
```

#### CLI命令更新

```python
# 在main()函数中，处理monitor_comprehensive命令时：
elif args.monitor_comprehensive:
    # 创建配置（如果有新参数）
    config = None
    if args.data_dir or args.output != 'all' or args.format != 'original':
        config = MonitorConfig(
            data_dir=args.data_dir,
            output=args.output,
            format_type=args.format
        )
    
    # 调用时传入config
    exit_code = await monitor_comprehensive(
        args.host, args.port, args.duration,
        config=config
    )
    
# 注意：BrowserFairyService暂不支持配置参数，后续迭代
```

### 使用示例

```bash
# AI调试场景：只要错误，保存到当前目录
browserfairy --start-monitoring \
  --data-dir ./debug \
  --output errors-only \
  --format ai-simple

# 性能分析场景
browserfairy --start-monitoring \
  --data-dir ./perf-analysis \
  --output performance \
  --format original

# 快速诊断场景：生成摘要报告
browserfairy --start-monitoring \
  --duration 60 \
  --data-dir . \
  --output ai-debug \
  --format summary

# 保持向后兼容（不指定任何参数）
browserfairy --start-monitoring  # 行为与现有版本完全一致
```

## Tests

### 单元测试（TDD优先）

#### 1. test_config.py - 配置管理测试
```python
def test_default_config():
    """测试默认配置 - 最重要，确保向后兼容"""
    config = MonitorConfig()
    assert config.data_dir == Path.home() / "BrowserFairyData"
    assert config.output_filters == ['*']
    assert config.format == 'original'
    assert config.should_collect('anything') == True

def test_custom_data_dir():
    """测试自定义数据目录"""
    config = MonitorConfig(data_dir='./test_data')
    assert config.data_dir.name == 'test_data'
    assert config.data_dir.is_absolute()

def test_preset_filters():
    """测试预设过滤器"""
    config = MonitorConfig(output='errors-only')
    assert config.should_collect('console', 'error') == True
    assert config.should_collect('console', 'log') == False
    assert config.should_collect('memory') == False

def test_custom_filters():
    """测试自定义过滤器列表"""
    config = MonitorConfig(output='memory,console:error')
    assert config.should_collect('memory') == True
    assert config.should_collect('console', 'error') == True
    assert config.should_collect('console', 'log') == False
```

#### 2. test_integration.py - 集成测试
```python
@pytest.mark.asyncio
async def test_backward_compatibility():
    """不提供配置时必须与旧版本行为一致"""
    # 创建默认配置
    config = MonitorConfig()
    
    # 验证数据目录
    assert config.data_dir == Path.home() / "BrowserFairyData"
    
    # 验证收集所有数据
    assert config.should_collect('memory') == True
    assert config.should_collect('console', 'any') == True
    
    # 验证原始格式
    assert config.format == 'original'
```

### 性能基准

- 过滤开销：<0.1ms per event（在Monitor层早期返回）
- 格式转换开销：<0.5ms per event（简单字段提取）
- 内存影响：无额外队列，过滤的数据不进入处理流程

## 实现优先级

### Phase 1 - 最小风险版本（本次实现）

1. **新增文件**（1个）
   - `browserfairy/config.py` - MonitorConfig配置类（只实现过滤功能）

2. **修改文件**（1个）
   - `browserfairy/cli.py`
     - 添加2个参数：--data-dir, --output（不实现--format）
     - monitor_comprehensive增加config参数
     - 在callback层集中处理过滤（不做格式转换）

3. **不修改的文件**（重要！）
   - 所有Monitor组件（ConsoleMonitor、NetworkMonitor、MemoryCollector）
   - DataManager（已支持data_dir参数）
   - DataWriter
   - BrowserFairyService（后续迭代）

### Phase 2 - AI格式（后续谨慎考虑）

- 深入研究memory数据依赖关系
- 可能采用双写策略（原始+简化并存）
- 或仅对console/network做简化，memory保持原始

### 实现步骤（Phase 1）

1. **Step 1**: 创建config.py（只实现过滤，不实现格式转换）
2. **Step 2**: 修改cli.py添加--data-dir和--output参数
3. **Step 3**: 修改monitor_comprehensive支持config
4. **Step 4**: 创建filtered_callback包装器
5. **Step 5**: 测试向后兼容性

## 风险与缓解

1. **向后兼容性风险**
   - 缓解：默认行为完全不变，新功能仅在显式指定时生效

2. **配置复杂度**
   - 缓解：提供清晰的预设模式，大多数用户不需要自定义

3. **性能影响**
   - 缓解：过滤在数据产生时进行，避免无用的处理和存储

## 成功标准

1. Claude Code可以通过简单命令获取所需的调试数据
2. 数据量减少80%以上（使用errors-only模式时）
3. AI能够理解简化格式的数据并给出有效建议
4. 现有用户的使用方式不受影响

## 设计改进总结

### 基于两轮专家评审的关键决策

1. **去除AI格式风险**：memory数据必须保持原始格式，避免破坏存储跟踪功能链
2. **保持回调签名不变**：通过闭包注入config，完全兼容现有代码
3. **集中处理优于分散修改**：在callback层统一处理，不修改各Monitor组件
4. **数据类型映射清晰**：
   - memory → 'memory'
   - console → 'console' + level
   - exception → 'exception'（独立类型）
   - network → 细分为start/complete/failed

### Phase 1 核心功能（本次实现）

- ✅ 数据目录配置（--data-dir）
- ✅ 输出过滤（--output）
- ❌ AI格式转换（风险太大，Phase 2再考虑）

这个方案在功能性和安全性之间找到了最佳平衡点。