# Design 2-4: Source Map支持 - 错误定位到源代码

## Requirements

### 背景和问题
- 当前错误堆栈显示的是压缩后的代码位置（如`bundle.js:1:45678`）
- AI无法根据压缩代码位置给出精确的修复建议
- 用户已确认目标网站有完整的Source Map支持（webpack打包，Source Map公开可访问）

### 功能需求
1. **自动检测Source Map**
   - 检测JS文件中的`//# sourceMappingURL=`标记
   - 支持相对路径和绝对路径的Source Map URL
   - 缓存已加载的Source Map避免重复下载

2. **错误堆栈增强**
   - 将压缩代码位置映射到源代码位置
   - 在错误事件中添加`original`字段包含源码信息
   - 保留原始位置信息作为fallback

3. **Source Map获取策略**
   - 优先使用CDP获取（利用Chrome已加载的Source Map）
   - 备选：通过HTTP直接下载（处理认证和CORS）
   - 支持用户手动提供Source Map文件

### 非功能需求
- 性能：Source Map解析不应阻塞主监控流程
- 内存：使用LRU缓存限制内存占用（最多缓存10个Source Map）
- 兼容性：支持Source Map v3规范
- 降级：Source Map不可用时保持现有功能正常

## Solution

### 技术方案概述

通过解析JavaScript Source Map文件，将压缩代码的错误位置映射到原始源代码位置，增强错误堆栈的可读性，让AI能够精确定位问题并提供修复建议。

**核心原则**：
1. **最小侵入**：只在ConsoleMonitor中添加可选的增强功能
2. **向后兼容**：默认关闭，不影响现有功能
3. **优雅降级**：任何失败都回退到原始堆栈
4. **TDD开发**：先写测试，后写实现

### 架构设计

```
ConsoleMonitor (现有)
    ↓ 捕获错误事件（包含scriptId）
SourceMapResolver (新增)
    ├── 监听Debugger.scriptParsed事件获取sourceMapURL
    ├── 通过HTTP下载Source Map文件
    ├── 使用sourcemap库解析位置映射
    ├── 缓存Source Map和映射结果
    └── 增强错误堆栈
    ↓ 输出增强后的错误事件
DataCallback → 写入console.jsonl
```

### 详细设计

#### 1. 实现步骤（TDD方式）

**第一步：编写测试（Red）**
1. 创建 `tests/test_source_map.py`
2. 测试SourceMapResolver的基本功能
3. 测试ConsoleMonitor集成

**第二步：实现功能（Green）**
1. 创建 `browserfairy/analysis/source_map.py`
2. 实现最简单的功能让测试通过

**第三步：重构（Refactor）**
1. 优化代码结构
2. 添加缓存和性能优化

#### 2. 新增SourceMapResolver类

```python
# browserfairy/analysis/source_map.py

import logging
import json
from typing import Optional, Dict, Any, List
from collections import OrderedDict
from pathlib import Path
from urllib.parse import urljoin, urlparse

import httpx
import sourcemap  # 需要添加到依赖

logger = logging.getLogger(__name__)

class SourceMapResolver:
    """Source Map解析器 - 将压缩代码位置映射到源代码"""
    
    def __init__(self, connector, max_cache_size: int = 10):
        self.connector = connector
        self.session_id = None
        
        # scriptId -> {url, sourceMapURL} 映射
        self.script_metadata = {}
        
        # sourceMapURL -> SourceMap对象缓存
        self.source_map_cache = OrderedDict()
        
        # (scriptId, line, column) -> source info 结果缓存
        self.location_cache = OrderedDict()
        
        self.max_cache_size = max_cache_size
        self.debugger_enabled = False
        self.http_client = httpx.AsyncClient(timeout=5.0)
        
    async def initialize(self, session_id: str) -> bool:
        """初始化Debugger domain并监听脚本事件"""
        self.session_id = session_id
        try:
            # 检查Debugger是否已启用（可能被MemoryCollector启用）
            try:
                await self.connector.call(
                    "Debugger.enable", 
                    {"silent": True},  # 静默模式，不暂停执行
                    session_id=session_id
                )
            except Exception as e:
                # 可能已经启用，继续
                logger.debug(f"Debugger might be already enabled: {e}")
            
            # 监听脚本解析事件以获取sourceMapURL
            self.connector.on_event("Debugger.scriptParsed", self._on_script_parsed)
            self.debugger_enabled = True
            
            logger.debug(f"SourceMapResolver initialized for session {session_id}")
            return True
        except Exception as e:
            logger.warning(f"Failed to initialize SourceMapResolver: {e}")
            return False
    
    async def _on_script_parsed(self, params: dict) -> None:
        """监听脚本解析事件，收集sourceMapURL"""
        if params.get("sessionId") != self.session_id:
            return
            
        script_id = params.get("scriptId")
        source_map_url = params.get("sourceMapURL")
        url = params.get("url")
        
        if script_id and url:
            self.script_metadata[script_id] = {
                "url": url,
                "sourceMapURL": source_map_url
            }
            if source_map_url:
                logger.debug(f"Found source map for {url}: {source_map_url}")
    
    async def resolve_stack_trace(self, stack_trace: List[Dict]) -> List[Dict]:
        """解析整个堆栈跟踪"""
        if not self.debugger_enabled or not stack_trace:
            return stack_trace
            
        enhanced_stack = []
        for frame in stack_trace:
            enhanced_frame = await self.resolve_frame(frame)
            enhanced_stack.append(enhanced_frame)
            
        return enhanced_stack
    
    async def resolve_frame(self, frame: Dict) -> Dict:
        """解析单个堆栈帧"""
        try:
            script_id = frame.get('scriptId')
            if not script_id or script_id not in self.script_metadata:
                return frame
                
            # 检查缓存
            cache_key = f"{script_id}:{frame.get('lineNumber')}:{frame.get('columnNumber')}"
            if cache_key in self.location_cache:
                frame['original'] = self.location_cache[cache_key]
                return frame
            
            # 获取脚本元数据
            script_meta = self.script_metadata[script_id]
            source_map_url = script_meta.get('sourceMapURL')
            
            if not source_map_url:
                return frame
            
            # 获取Source Map对象
            source_map = await self._get_source_map(script_meta['url'], source_map_url)
            if not source_map:
                return frame
            
            # 查找原始位置（注意：CDP使用0-based行号，source-map也是0-based）
            line = frame.get('lineNumber', 0)
            column = frame.get('columnNumber', 0)
            
            # 使用sourcemap库查找原始位置
            token = source_map.lookup(line=line, column=column)
            
            if token and token.src:
                original_info = {
                    'file': token.src,  # 原始文件路径
                    'line': token.src_line,  # 原始行号
                    'column': token.src_col,  # 原始列号
                    'name': token.name  # 原始函数名（如果有）
                }
                
                # 获取源代码片段（如果Source Map包含源代码）
                if hasattr(source_map, 'sources') and token.src_id < len(source_map.sources):
                    source_content = source_map.sources[token.src_id]
                    if source_content:
                        lines = source_content.split('\n')
                        if 0 <= token.src_line < len(lines):
                            original_info['source'] = lines[token.src_line].strip()
                
                # 更新缓存
                self._update_cache(cache_key, original_info)
                frame['original'] = original_info
                
        except Exception as e:
            logger.debug(f"Failed to resolve frame: {e}")
            
        return frame
    
    async def _get_source_map(self, script_url: str, source_map_url: str) -> Optional[Any]:
        """获取并解析Source Map"""
        # 检查缓存
        if source_map_url in self.source_map_cache:
            return self.source_map_cache[source_map_url]
        
        try:
            # 构造完整URL（处理相对路径）
            if not source_map_url.startswith(('http://', 'https://', 'data:')):
                source_map_url = urljoin(script_url, source_map_url)
            
            # 处理data URL
            if source_map_url.startswith('data:'):
                # data:application/json;base64,xxxxx
                import base64
                _, data = source_map_url.split(',', 1)
                if 'base64' in source_map_url:
                    source_map_content = base64.b64decode(data).decode('utf-8')
                else:
                    source_map_content = data
            else:
                # HTTP下载
                response = await self.http_client.get(source_map_url)
                response.raise_for_status()
                source_map_content = response.text
            
            # 解析Source Map
            source_map = sourcemap.loads(source_map_content)
            
            # 更新缓存
            self._update_source_map_cache(source_map_url, source_map)
            
            return source_map
            
        except Exception as e:
            logger.debug(f"Failed to get source map {source_map_url}: {e}")
            return None
    
    def _update_cache(self, key: str, value: Dict):
        """更新位置映射LRU缓存"""
        # 如果已存在，先删除（移到最后）
        if key in self.location_cache:
            del self.location_cache[key]
        # 如果缓存满了，删除最旧的
        elif len(self.location_cache) >= self.max_cache_size * 10:  # 位置缓存可以更大
            self.location_cache.popitem(last=False)
        # 添加到末尾
        self.location_cache[key] = value
    
    def _update_source_map_cache(self, url: str, source_map: Any):
        """更新Source Map LRU缓存"""
        # 如果已存在，先删除（移到最后）
        if url in self.source_map_cache:
            del self.source_map_cache[url]
        # 如果缓存满了，删除最旧的
        elif len(self.source_map_cache) >= self.max_cache_size:
            self.source_map_cache.popitem(last=False)
        # 添加到末尾
        self.source_map_cache[url] = source_map
    
    async def cleanup(self):
        """清理资源"""
        if self.debugger_enabled:
            try:
                # 取消事件监听
                self.connector.off_event("Debugger.scriptParsed", self._on_script_parsed)
                # 注意：不禁用Debugger domain，因为可能被其他组件使用
            except Exception:
                pass
            self.debugger_enabled = False
        
        # 清理缓存
        self.script_metadata.clear()
        self.source_map_cache.clear()
        self.location_cache.clear()
        
        # 关闭HTTP客户端
        await self.http_client.aclose()
```

#### 3. 集成到ConsoleMonitor（最小侵入）

```python
# 修改 browserfairy/monitors/console.py

class ConsoleMonitor:
    def __init__(self, connector: ChromeConnector, session_id: str,
                 event_queue: asyncio.Queue, status_callback: Optional[Callable] = None,
                 enable_source_map: bool = False):  # 新增参数，默认关闭
        # 现有代码完全不变
        self.connector = connector
        self.session_id = session_id
        self.event_queue = event_queue
        self.status_callback = status_callback
        self.hostname = None
        
        # 新增属性
        self.enable_source_map = enable_source_map
        self.source_map_resolver = None
        
    async def start_monitoring(self):
        """Start console monitoring with optional source map support."""
        # 现有代码：注册事件监听器
        logger.debug(f"ConsoleMonitor.start_monitoring: registering handlers for session {self.session_id}")
        self.connector.on_event("Runtime.consoleAPICalled", self._on_console_message)
        self.connector.on_event("Runtime.exceptionThrown", self._on_exception_thrown)
        logger.debug(f"ConsoleMonitor handlers registered")
        
        # 新增：初始化Source Map解析器
        if self.enable_source_map:
            try:
                from ..analysis.source_map import SourceMapResolver
                self.source_map_resolver = SourceMapResolver(self.connector)
                await self.source_map_resolver.initialize(self.session_id)
                logger.debug(f"Source map resolver initialized for session {self.session_id}")
            except Exception as e:
                logger.debug(f"Source map resolver initialization failed: {e}")
    
    async def stop_monitoring(self) -> None:
        """Stop Console event listening with paired off_event."""
        self.connector.off_event("Runtime.consoleAPICalled", self._on_console_message)
        self.connector.off_event("Runtime.exceptionThrown", self._on_exception_thrown)
        
        # 新增：清理Source Map解析器
        if self.source_map_resolver:
            await self.source_map_resolver.cleanup()
            self.source_map_resolver = None
        
    async def _on_exception_thrown(self, params: dict) -> None:
        """处理异常事件 - 增强版（保持现有逻辑）"""
        # 现有的过滤逻辑完全不变
        if params.get("sessionId") != self.session_id:
            return
            
        exception = params["exceptionDetails"]
        
        # 构建exception_data（现有代码）
        exception_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "type": "exception",
            "message": exception["text"][:500],
            "source": {
                "url": exception.get("url", "")[:200],
                "line": exception.get("lineNumber", 0),
                "column": exception.get("columnNumber", 0)
            },
            "stackTrace": self._format_stack_trace(exception.get("stackTrace", {})),
            "hostname": self.hostname
        }
        
        # 新增：Source Map增强（可选）
        if self.source_map_resolver and exception_data.get("stackTrace"):
            try:
                exception_data["stackTrace"] = await self.source_map_resolver.resolve_stack_trace(
                    exception_data["stackTrace"]
                )
            except Exception as e:
                logger.debug(f"Source map resolution failed: {e}")
                # 失败时保持原始堆栈
        
        # 现有的event_id生成（不变）
        exception_data["event_id"] = make_event_id(
            "exception",
            self.hostname or "",
            exception_data["timestamp"],
            exception_data.get("message", ""),
            exception_data.get("source", {}).get("url", ""),
            exception_data.get("source", {}).get("line", 0),
            exception_data.get("source", {}).get("column", 0)
        )
        
        # 现有的队列和回调逻辑（完全不变）
        try:
            self.event_queue.put_nowait(("exception", exception_data))
        except asyncio.QueueFull:
            logger.warning("Exception event queue full, dropping event")
    
    def _format_stack_trace(self, stack: dict) -> list:
        """Format stack trace information - 保留scriptId用于Source Map解析"""
        if not stack or not stack.get("callFrames"):
            return []
        
        return [
            {
                "functionName": frame.get("functionName", "anonymous")[:100],
                "scriptId": frame.get("scriptId"),  # 新增：保留scriptId
                "url": frame.get("url", "")[:200],
                "lineNumber": frame.get("lineNumber", 0),
                "columnNumber": frame.get("columnNumber", 0)
            }
            for frame in stack["callFrames"][:5]
        ]
```

#### 3. 输出格式示例

增强后的错误事件：
```json
{
  "type": "console",
  "level": "error",
  "timestamp": "2025-01-21T10:30:45.123Z",
  "hostname": "example.com",
  "message": "TypeError: Cannot read property 'value' of null",
  "stackTrace": [
    {
      "functionName": "handleSubmit",
      "scriptId": "123",
      "url": "https://example.com/static/js/bundle.min.js",
      "lineNumber": 1,
      "columnNumber": 45678,
      "original": {  // 新增字段
        "file": "lib-axios.c963551e.js",
        "line": 345,
        "column": 15,
        "source": "const value = form.username.value;"
      }
    }
  ]
}
```

### 性能优化策略

1. **异步非阻塞**：Source Map解析在后台进行，不阻塞主监控
2. **LRU缓存**：避免重复解析相同位置
3. **快速超时**：CDP调用2-3秒超时，失败快速降级
4. **选择性启用**：可通过配置关闭Source Map功能

### 错误处理

1. **Debugger domain不可用**：记录警告，继续使用原始堆栈
2. **解析超时**：使用原始位置信息
3. **Source Map缺失**：保持原样，不影响其他功能

## Tests

### TDD测试计划

#### 第一轮测试（基础功能）
```python
# tests/test_source_map.py

import pytest
from unittest.mock import AsyncMock, MagicMock
from browserfairy.analysis.source_map import SourceMapResolver

class TestSourceMapResolver:
    
    @pytest.fixture
    def mock_connector(self):
        """创建mock connector"""
        connector = AsyncMock()
        return connector
    
    @pytest.fixture
    def resolver(self, mock_connector):
        """创建SourceMapResolver实例"""
        return SourceMapResolver(mock_connector)
    
    @pytest.mark.asyncio
    async def test_initialization(self, resolver, mock_connector):
        """测试初始化Debugger domain"""
        mock_connector.call.return_value = {}
        
        result = await resolver.initialize("test_session")
        
        # 验证调用了Debugger.enable
        mock_connector.call.assert_called_with(
            "Debugger.enable",
            {"silent": True},
            session_id="test_session"
        )
        assert resolver.debugger_enabled is True
        assert result is True
    
    @pytest.mark.asyncio
    async def test_initialization_failure(self, resolver, mock_connector):
        """测试初始化失败时的优雅降级"""
        mock_connector.call.side_effect = Exception("Debugger not available")
        
        result = await resolver.initialize("test_session")
        
        assert resolver.debugger_enabled is False
        assert result is False
    
    @pytest.mark.asyncio
    async def test_resolve_frame_without_scriptid(self, resolver):
        """测试没有scriptId的堆栈帧"""
        frame = {
            "functionName": "test",
            "url": "http://example.com/app.js",
            "lineNumber": 10,
            "columnNumber": 5
        }
        
        enhanced_frame = await resolver.resolve_frame(frame)
        
        # 应该原样返回
        assert enhanced_frame == frame
        assert "original" not in enhanced_frame
    
    @pytest.mark.asyncio
    async def test_resolve_frame_with_cache(self, resolver):
        """测试缓存机制"""
        resolver.debugger_enabled = True
        
        # 预填充缓存
        cache_key = "script123:10:5"
        cached_info = {
            "file": "source.js",
            "line": 45,
            "column": 12
        }
        resolver.location_cache[cache_key] = cached_info
        
        frame = {
            "scriptId": "script123",
            "lineNumber": 10,
            "columnNumber": 5
        }
        
        enhanced_frame = await resolver.resolve_frame(frame)
        
        # 应该从缓存返回
        assert enhanced_frame["original"] == cached_info
    
    def test_lru_cache_eviction(self, resolver):
        """测试LRU缓存淘汰"""
        resolver.max_cache_size = 3
        
        # 填充缓存
        for i in range(4):
            key = f"key{i}"
            value = {"data": i}
            resolver._update_cache(key, value)
        
        # 第一个应该被淘汰
        assert "key0" not in resolver.location_cache
        assert "key1" in resolver.location_cache
        assert "key2" in resolver.location_cache
        assert "key3" in resolver.location_cache
```

#### 第二轮测试（ConsoleMonitor集成）
```python
# tests/test_console_source_map.py

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from browserfairy.monitors.console import ConsoleMonitor

class TestConsoleMonitorWithSourceMap:
    
    @pytest.fixture
    def console_monitor(self):
        """创建ConsoleMonitor实例"""
        connector = AsyncMock()
        event_queue = AsyncMock()
        monitor = ConsoleMonitor(connector, "test_session", event_queue)
        monitor.set_hostname("example.com")
        return monitor
    
    @pytest.mark.asyncio
    async def test_source_map_disabled_by_default(self, console_monitor):
        """测试Source Map默认关闭"""
        await console_monitor.start_monitoring()
        assert console_monitor.source_map_resolver is None
    
    @pytest.mark.asyncio
    async def test_source_map_enabled(self, console_monitor):
        """测试启用Source Map"""
        console_monitor.enable_source_map = True
        
        with patch("browserfairy.monitors.console.SourceMapResolver") as MockResolver:
            mock_resolver = AsyncMock()
            MockResolver.return_value = mock_resolver
            mock_resolver.initialize.return_value = True
            
            await console_monitor.start_monitoring()
            
            assert console_monitor.source_map_resolver is not None
            mock_resolver.initialize.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_exception_with_source_map(self, console_monitor):
        """测试异常事件的Source Map增强"""
        console_monitor.enable_source_map = True
        console_monitor.source_map_resolver = AsyncMock()
        
        # 模拟增强后的堆栈
        enhanced_stack = [{
            "functionName": "test",
            "scriptId": "123",
            "lineNumber": 1,
            "columnNumber": 100,
            "original": {
                "file": "source.js",
                "line": 45,
                "column": 10
            }
        }]
        console_monitor.source_map_resolver.resolve_stack_trace.return_value = enhanced_stack
        
        # 触发异常事件
        params = {
            "sessionId": "test_session",
            "exceptionDetails": {
                "text": "Test error",
                "stackTrace": {
                    "callFrames": [{
                        "functionName": "test",
                        "scriptId": "123",
                        "lineNumber": 1,
                        "columnNumber": 100
                    }]
                }
            }
        }
        
        await console_monitor._on_exception_thrown(params)
        
        # 验证调用了source map解析
        console_monitor.source_map_resolver.resolve_stack_trace.assert_called_once()
```

### 集成测试
```python
async def test_console_monitor_with_source_map():
    """测试ConsoleMonitor集成Source Map功能"""
    
async def test_real_website_source_map():
    """测试真实网站的Source Map解析"""
```

### 验收标准
- [ ] 能自动检测并使用Chrome加载的Source Map
- [ ] 错误堆栈包含源代码位置信息
- [ ] Source Map不可用时正常降级
- [ ] 性能影响<100ms
- [ ] 内存占用增加<10MB
- [ ] 所有现有测试继续通过