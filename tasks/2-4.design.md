# Design 2-4: Source Map支持 - 错误定位到源代码

## Requirements

### 背景和问题
- 当前错误堆栈显示的是压缩后的代码位置（如`bundle.js:1:45678`）
- AI无法根据压缩代码位置给出精确的修复建议
- 用户已确认目标网站有完整的Source Map支持（webpack打包，Source Map公开可访问）

### 功能需求
1. **自动检测Source Map**
   - 检测JS文件中的`//# sourceMappingURL=`标记
   - 支持相对路径和绝对路径的Source Map URL
   - 缓存已加载的Source Map避免重复下载

2. **错误堆栈增强**
   - 将压缩代码位置映射到源代码位置
   - 在错误事件中添加`original`字段包含源码信息
   - 保留原始位置信息作为fallback

3. **Source Map获取策略**
   - 优先使用CDP获取（利用Chrome已加载的Source Map）
   - 备选：通过HTTP直接下载（处理认证和CORS）
   - 支持用户手动提供Source Map文件

### 非功能需求
- 性能：Source Map解析不应阻塞主监控流程
- 内存：使用LRU缓存限制内存占用（最多缓存10个Source Map）
- 兼容性：支持Source Map v3规范
- 降级：Source Map不可用时保持现有功能正常

## Solution

### 技术方案概述

通过解析JavaScript Source Map文件，将压缩代码的错误位置映射到原始源代码位置，增强错误堆栈的可读性，让AI能够精确定位问题并提供修复建议。

**v1实现范围**：
- 仅处理包含scriptId的堆栈帧（不做URL反查）
- 仅支持data URL和HTTP直接获取Source Map
- 保持原有字段不变，仅新增字段

**核心原则**：
1. **向后兼容**：保留`function/url/line/column`字段，仅新增`scriptId/lineNumber/columnNumber/original`
2. **最小侵入**：复用已有Debugger domain，不重复启用
3. **优雅降级**：任何失败都静默回退，不影响主功能
4. **默认关闭**：需显式启用`enable_source_map`参数

### 架构设计

```
ConsoleMonitor (现有)
    ↓ 捕获错误事件（保留原字段，新增scriptId）
SourceMapResolver (新增)
    ├── 监听Debugger.scriptParsed事件（带sessionId过滤）
    ├── 收集scriptId→sourceMapURL映射
    ├── 通过HTTP下载Source Map（v1仅data/HTTP）
    ├── 使用sourcemap库解析位置
    └── 仅添加original字段，不改原字段
    ↓ 输出增强后的错误事件
DataCallback → 写入console.jsonl
```

**后续增强计划**：
- CDP优先获取Source Map（处理认证/CORS）
- URL反查scriptId支持
- 更智能的缓存策略

### 详细设计

#### 1. 实现步骤（TDD方式）

**第一步：编写测试（Red）**
1. 创建 `tests/test_source_map.py`
2. 测试SourceMapResolver的基本功能
3. 测试ConsoleMonitor集成

**第二步：实现功能（Green）**
1. 创建 `browserfairy/analysis/source_map.py`
2. 实现最简单的功能让测试通过

**第三步：重构（Refactor）**
1. 优化代码结构
2. 添加缓存和性能优化

#### 2. 新增SourceMapResolver类

```python
# browserfairy/analysis/source_map.py

import logging
import json
from typing import Optional, Dict, Any, List
from collections import OrderedDict
from pathlib import Path
from urllib.parse import urljoin, urlparse

import httpx
import sourcemap  # 需要添加到依赖

logger = logging.getLogger(__name__)

class SourceMapResolver:
    """Source Map解析器 - 将压缩代码位置映射到源代码"""
    
    def __init__(self, connector, max_cache_size: int = 10):
        self.connector = connector
        self.session_id = None
        
        # scriptId -> {url, sourceMapURL} 映射
        self.script_metadata = {}
        
        # sourceMapURL -> SourceMap对象缓存
        self.source_map_cache = OrderedDict()
        
        # (scriptId, line, column) -> source info 结果缓存
        self.location_cache = OrderedDict()
        
        self.max_cache_size = max_cache_size
        self.initialized = False  # 更准确的命名：表示解析器已初始化
        self.http_client = httpx.AsyncClient(timeout=5.0)
        
    async def initialize(self, session_id: str) -> bool:
        """初始化并监听脚本事件（复用已有的Debugger domain）"""
        self.session_id = session_id
        try:
            # 注意：不主动启用Debugger domain，假设已被MemoryCollector等组件启用
            # 如果确实需要独立使用，调用方应先确保Debugger已启用
            
            # 监听脚本解析事件以获取sourceMapURL
            self.connector.on_event("Debugger.scriptParsed", self._on_script_parsed)
            self.initialized = True
            
            logger.debug(f"SourceMapResolver initialized for session {session_id}")
            return True
        except Exception as e:
            logger.warning(f"Failed to initialize SourceMapResolver: {e}")
            return False
    
    async def _on_script_parsed(self, params: dict) -> None:
        """监听脚本解析事件，收集sourceMapURL"""
        if params.get("sessionId") != self.session_id:
            return
            
        script_id = params.get("scriptId")
        source_map_url = params.get("sourceMapURL")
        url = params.get("url")
        
        if script_id and url:
            self.script_metadata[script_id] = {
                "url": url,
                "sourceMapURL": source_map_url
            }
            if source_map_url:
                logger.debug(f"Found source map for {url}: {source_map_url}")
    
    async def resolve_stack_trace(self, stack_trace: List[Dict]) -> List[Dict]:
        """解析整个堆栈跟踪"""
        if not self.initialized or not stack_trace:
            return stack_trace
            
        enhanced_stack = []
        for frame in stack_trace:
            enhanced_frame = await self.resolve_frame(frame)
            enhanced_stack.append(enhanced_frame)
            
        return enhanced_stack
    
    async def resolve_frame(self, frame: Dict) -> Dict:
        """解析单个堆栈帧（v1仅支持有scriptId的帧）"""
        try:
            # v1要求必须有scriptId才能解析，没有scriptId直接返回
            script_id = frame.get('scriptId')
            if not script_id or script_id not in self.script_metadata:
                return frame
                
            # 读取行列号：优先使用lineNumber/columnNumber，回退到line/column
            line = frame.get('lineNumber', frame.get('line', 0))
            column = frame.get('columnNumber', frame.get('column', 0))
            
            # 检查缓存
            cache_key = f"{script_id}:{line}:{column}"
            if cache_key in self.location_cache:
                frame['original'] = self.location_cache[cache_key]
                return frame
            
            # 获取脚本元数据
            script_meta = self.script_metadata[script_id]
            source_map_url = script_meta.get('sourceMapURL')
            
            if not source_map_url:
                return frame
            
            # 获取Source Map对象
            source_map = await self._get_source_map(script_meta['url'], source_map_url)
            if not source_map:
                return frame
            
            # 使用sourcemap库查找原始位置（CDP和source-map都是0-based）
            token = source_map.lookup(line=line, column=column)
            
            if token and token.src:
                original_info = {
                    'file': token.src,  # 原始文件路径
                    'line': token.src_line,  # 原始行号
                    'column': token.src_col,  # 原始列号
                    'name': token.name  # 原始函数名（如果有）
                }
                
                # 获取源代码片段（Source Map v3标准使用sourcesContent字段）
                # 注意：需要确认sourcemap库的具体API
                # 某些库通过token.get_source_content()或source_map.sourcesContent访问
                if hasattr(source_map, 'sourcesContent') and token.src_id < len(source_map.sourcesContent):
                    source_content = source_map.sourcesContent[token.src_id]
                    if source_content:
                        lines = source_content.split('\n')
                        if 0 <= token.src_line < len(lines):
                            original_info['source'] = lines[token.src_line].strip()
                # v1暂时移除源码片段功能，待确认库API后再添加
                # original_info中暂不包含'source'字段
                
                # 更新缓存
                self._update_cache(cache_key, original_info)
                frame['original'] = original_info
                
        except Exception as e:
            logger.debug(f"Failed to resolve frame: {e}")
            
        return frame
    
    async def _get_source_map(self, script_url: str, source_map_url: str) -> Optional[Any]:
        """获取并解析Source Map（v1仅支持data URL和HTTP）"""
        try:
            # 先规范化URL为绝对路径，确保缓存键一致
            if not source_map_url.startswith(('http://', 'https://', 'data:')):
                source_map_url = urljoin(script_url, source_map_url)
            
            # 规范化后再检查缓存
            if source_map_url in self.source_map_cache:
                return self.source_map_cache[source_map_url]
            
            # v1实现：仅支持data URL和直接HTTP获取
            # v2增强：并发下载去重（共享pending future）
            # 后续增强：CDP获取、认证处理、CORS绕过等
            
            # 处理data URL
            if source_map_url.startswith('data:'):
                # data:application/json;base64,xxxxx
                import base64
                _, data = source_map_url.split(',', 1)
                if 'base64' in source_map_url:
                    source_map_content = base64.b64decode(data).decode('utf-8')
                else:
                    source_map_content = data
            else:
                # HTTP下载
                response = await self.http_client.get(source_map_url)
                response.raise_for_status()
                source_map_content = response.text
            
            # 解析Source Map
            source_map = sourcemap.loads(source_map_content)
            
            # 更新缓存
            self._update_source_map_cache(source_map_url, source_map)
            
            return source_map
            
        except Exception as e:
            logger.debug(f"Failed to get source map {source_map_url}: {e}")
            return None
    
    def _update_cache(self, key: str, value: Dict):
        """更新位置映射LRU缓存"""
        # 如果已存在，先删除（移到最后）
        if key in self.location_cache:
            del self.location_cache[key]
        # 如果缓存满了，删除最旧的
        elif len(self.location_cache) >= self.max_cache_size * 10:  # 位置缓存可以更大
            self.location_cache.popitem(last=False)
        # 添加到末尾
        self.location_cache[key] = value
    
    def _update_source_map_cache(self, url: str, source_map: Any):
        """更新Source Map LRU缓存"""
        # 如果已存在，先删除（移到最后）
        if url in self.source_map_cache:
            del self.source_map_cache[url]
        # 如果缓存满了，删除最旧的
        elif len(self.source_map_cache) >= self.max_cache_size:
            self.source_map_cache.popitem(last=False)
        # 添加到末尾
        self.source_map_cache[url] = source_map
    
    async def cleanup(self):
        """清理资源"""
        if self.initialized:
            try:
                # 取消事件监听
                self.connector.off_event("Debugger.scriptParsed", self._on_script_parsed)
                # 注意：不禁用Debugger domain，因为可能被其他组件使用
            except Exception:
                pass
            self.initialized = False
        
        # 清理缓存
        self.script_metadata.clear()
        self.source_map_cache.clear()
        self.location_cache.clear()
        
        # 关闭HTTP客户端
        await self.http_client.aclose()
```

#### 3. 集成到ConsoleMonitor（最小侵入）

```python
# 修改 browserfairy/monitors/console.py

class ConsoleMonitor:
    def __init__(self, connector: ChromeConnector, session_id: str,
                 event_queue: asyncio.Queue, status_callback: Optional[Callable] = None,
                 enable_source_map: bool = False):  # 新增参数，默认关闭
        # 现有代码完全不变
        self.connector = connector
        self.session_id = session_id
        self.event_queue = event_queue
        self.status_callback = status_callback
        self.hostname = None
        
        # 新增属性
        self.enable_source_map = enable_source_map
        self.source_map_resolver = None
        
    async def start_monitoring(self):
        """Start console monitoring with optional source map support."""
        # 现有代码：注册事件监听器
        logger.debug(f"ConsoleMonitor.start_monitoring: registering handlers for session {self.session_id}")
        self.connector.on_event("Runtime.consoleAPICalled", self._on_console_message)
        self.connector.on_event("Runtime.exceptionThrown", self._on_exception_thrown)
        logger.debug(f"ConsoleMonitor handlers registered")
        
        # 新增：初始化Source Map解析器
        if self.enable_source_map:
            try:
                from ..analysis.source_map import SourceMapResolver
                self.source_map_resolver = SourceMapResolver(self.connector)
                await self.source_map_resolver.initialize(self.session_id)
                logger.debug(f"Source map resolver initialized for session {self.session_id}")
            except Exception as e:
                logger.debug(f"Source map resolver initialization failed: {e}")
    
    async def stop_monitoring(self) -> None:
        """Stop Console event listening with paired off_event."""
        self.connector.off_event("Runtime.consoleAPICalled", self._on_console_message)
        self.connector.off_event("Runtime.exceptionThrown", self._on_exception_thrown)
        
        # 新增：清理Source Map解析器
        if self.source_map_resolver:
            await self.source_map_resolver.cleanup()
            self.source_map_resolver = None
        
    async def _on_exception_thrown(self, params: dict) -> None:
        """处理异常事件 - 增强版（保持现有逻辑）"""
        # 现有的过滤逻辑完全不变
        if params.get("sessionId") != self.session_id:
            return
            
        exception = params["exceptionDetails"]
        
        # 构建exception_data（现有代码）
        exception_data = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "type": "exception",
            "message": exception["text"][:500],
            "source": {
                "url": exception.get("url", "")[:200],
                "line": exception.get("lineNumber", 0),
                "column": exception.get("columnNumber", 0)
            },
            "stackTrace": self._format_stack_trace(exception.get("stackTrace", {})),
            "hostname": self.hostname
        }
        
        # 新增：Source Map增强（可选）
        if self.source_map_resolver and exception_data.get("stackTrace"):
            try:
                exception_data["stackTrace"] = await self.source_map_resolver.resolve_stack_trace(
                    exception_data["stackTrace"]
                )
            except Exception as e:
                logger.debug(f"Source map resolution failed: {e}")
                # 失败时保持原始堆栈
        
        # 现有的event_id生成（不变）
        exception_data["event_id"] = make_event_id(
            "exception",
            self.hostname or "",
            exception_data["timestamp"],
            exception_data.get("message", ""),
            exception_data.get("source", {}).get("url", ""),
            exception_data.get("source", {}).get("line", 0),
            exception_data.get("source", {}).get("column", 0)
        )
        
        # 现有的队列和回调逻辑（完全不变）
        try:
            self.event_queue.put_nowait(("exception", exception_data))
        except asyncio.QueueFull:
            logger.warning("Exception event queue full, dropping event")
    
    def _format_stack_trace(self, stack: dict) -> list:
        """Format stack trace information - 保持向后兼容，仅新增字段"""
        if not stack or not stack.get("callFrames"):
            return []
        
        return [
            {
                # 保留原有字段名，确保向后兼容
                "function": frame.get("functionName", "anonymous")[:100],
                "url": frame.get("url", "")[:200],
                "line": frame.get("lineNumber", 0),
                "column": frame.get("columnNumber", 0),
                # 新增字段用于Source Map解析
                "scriptId": frame.get("scriptId"),  # 新增：用于Source Map查找
                "lineNumber": frame.get("lineNumber", 0),  # 新增：CDP原始字段（方便解析）
                "columnNumber": frame.get("columnNumber", 0)  # 新增：CDP原始字段（方便解析）
            }
            for frame in stack["callFrames"][:5]
        ]
```

#### 4. 输出格式示例

增强后的错误事件（保持向后兼容，仅新增字段）：
```json
{
  "type": "exception",
  "timestamp": "2025-01-21T10:30:45.123Z",
  "hostname": "example.com",
  "message": "TypeError: Cannot read property 'value' of null",
  "source": {
    "url": "https://example.com/static/js/bundle.min.js",
    "line": 1,
    "column": 45678
  },
  "stackTrace": [
    {
      "function": "handleSubmit",         // 保留原字段
      "url": "https://example.com/static/js/bundle.min.js",  // 保留原字段
      "line": 1,                          // 保留原字段
      "column": 45678,                    // 保留原字段
      "scriptId": "123",                  // 新增：用于Source Map查找
      "lineNumber": 1,                    // 新增：CDP原始字段
      "columnNumber": 45678,               // 新增：CDP原始字段
      "original": {                        // 新增：Source Map解析结果
        "file": "src/components/LoginForm.jsx",
        "line": 42,
        "column": 15,
        "name": "handleSubmit"
        // v1暂不包含source字段，待确认sourcemap库API后添加
      }
    },
    {
      "function": "onClick",
      "url": "https://example.com/static/js/bundle.min.js",
      "line": 1,
      "column": 23456,
      "scriptId": "123",
      "lineNumber": 1,
      "columnNumber": 23456,
      "original": {
        "file": "src/components/Button.jsx",
        "line": 18,
        "column": 8,
        "name": "Button.onClick"
      }
    }
  ],
  "event_id": "exception_example.com_2025-01-21T10:30:45.123Z_..."
}
```

### 依赖项更新

在`pyproject.toml`中添加Source Map解析库：
```toml
[project]
dependencies = [
    "websockets>=12.0",
    "httpx>=0.25.0",
    "sourcemap>=0.2.1",  # 新增：Source Map解析库（需验证API）
]
```

**Source Map库选择说明**：
1. 首选`sourcemap`库，但其API文档不完善
2. 实现前需要先写测试验证具体API：
   - `lookup()`方法的返回值结构
   - 源码内容访问方式（`sourcesContent` vs 其他）
   - 错误处理机制
3. 备选方案：`python-sourcemaps`库，如果`sourcemap`库API不满足需求

### 集成策略

**v1阶段集成**：
1. 先在`ConsoleMonitor`构造函数添加`enable_source_map`参数（默认False）
2. `MemoryCollector`暂时保持不变，内部固定为关闭
3. CLI参数可在后续版本添加，避免一次性改动过多文件

**后续增强**：
```python
# 未来可在MemoryCollector中透传参数
class MemoryCollector:
    def __init__(self, ..., enable_source_map: bool = False):
        self.enable_source_map = enable_source_map
    
    async def _enable_comprehensive_monitoring(self):
        # 创建ConsoleMonitor时透传
        self.console_monitor = ConsoleMonitor(
            self.connector, self.session_id, self.event_queue,
            enable_source_map=self.enable_source_map
        )

# CLI中添加参数
@click.option('--enable-source-map', is_flag=True, 
              help='Enable source map resolution for error stacks')
async def monitor_comprehensive(enable_source_map: bool = False):
    # 传递给MemoryCollector
    memory_collector = MemoryCollector(..., enable_source_map=enable_source_map)
```

### 性能优化策略

1. **异步非阻塞**：Source Map解析在后台进行，不阻塞主监控
2. **三级缓存**：
   - scriptId → sourceMapURL映射（避免重复查询）
   - Source Map文件缓存（避免重复下载）
   - 位置映射结果缓存（避免重复解析）
3. **快速超时**：HTTP请求5秒超时，失败快速降级
4. **选择性启用**：默认关闭，需要时通过`--enable-source-map`开启
5. **并发优化（v2增强）**：
   - 多个堆栈帧并发请求同一Source Map时，共享pending future
   - 避免重复下载，提高效率
   - v1暂时接受并发下载，保持实现简单

### 错误处理

1. **Debugger domain不可用**：记录调试日志，继续使用原始堆栈
2. **Source Map下载失败**：记录警告，保持原始位置信息
3. **解析错误**：静默失败，不影响主监控功能
4. **内存保护**：LRU缓存限制，防止内存泄漏

## Tests

### TDD测试计划

#### 第一轮测试（库API验证）
```python
# tests/test_source_map_lib.py - 实现前先验证库API

import pytest
import sourcemap  # 或 python_sourcemaps

def test_sourcemap_library_api():
    """验证Source Map库的实际API（实现前必须运行）"""
    # 测试用的简单Source Map
    source_map_content = {
        "version": 3,
        "sources": ["src/app.js"],
        "sourcesContent": ["const x = 1;\nconst y = 2;"],
        "names": ["x", "y"],
        "mappings": "AAAA,MAAM,CAAC"
    }
    
    # 验证解析API
    import json
    sm = sourcemap.loads(json.dumps(source_map_content))
    
    # 验证lookup API和返回值结构
    token = sm.lookup(line=0, column=0)
    assert hasattr(token, 'src')  # 原始文件名
    assert hasattr(token, 'src_line')  # 原始行号
    assert hasattr(token, 'src_col')  # 原始列号
    assert hasattr(token, 'name')  # 原始名称（可能为None）
    
    # 验证源码内容访问方式
    # 选项1: sm.sourcesContent
    # 选项2: sm.sources_content
    # 选项3: token.get_source_content()
    # 需要实际测试确定
    
    print(f"Token structure: {dir(token)}")
    print(f"SourceMap structure: {dir(sm)}")
```

#### 第二轮测试（基础功能）
```python
# tests/test_source_map.py

import pytest
import json
from unittest.mock import AsyncMock, MagicMock, patch
from browserfairy.analysis.source_map import SourceMapResolver

class TestSourceMapResolver:
    
    @pytest.fixture
    def mock_connector(self):
        """创建mock connector"""
        connector = AsyncMock()
        connector.on_event = MagicMock()
        connector.off_event = MagicMock()
        return connector
    
    @pytest.fixture
    def resolver(self, mock_connector):
        """创建SourceMapResolver实例"""
        return SourceMapResolver(mock_connector)
    
    @pytest.mark.asyncio
    async def test_initialization(self, resolver, mock_connector):
        """测试初始化和事件监听（不主动启用Debugger）"""
        result = await resolver.initialize("test_session")
        
        # 验证不主动调用Debugger.enable
        mock_connector.call.assert_not_called()
        # 验证注册了scriptParsed事件监听
        mock_connector.on_event.assert_called_with(
            "Debugger.scriptParsed",
            resolver._on_script_parsed
        )
        assert resolver.initialized is True
        assert result is True
    
    @pytest.mark.asyncio
    async def test_initialization_failure(self, resolver, mock_connector):
        """测试初始化失败时的优雅降级"""
        mock_connector.call.side_effect = Exception("Debugger not available")
        
        result = await resolver.initialize("test_session")
        
        assert resolver.initialized is False
        assert result is False
    
    @pytest.mark.asyncio
    async def test_resolve_frame_without_scriptid(self, resolver):
        """测试没有scriptId的堆栈帧"""
        frame = {
            "functionName": "test",
            "url": "http://example.com/app.js",
            "lineNumber": 10,
            "columnNumber": 5
        }
        
        enhanced_frame = await resolver.resolve_frame(frame)
        
        # 应该原样返回
        assert enhanced_frame == frame
        assert "original" not in enhanced_frame
    
    @pytest.mark.asyncio
    async def test_script_parsed_event(self, resolver):
        """测试脚本解析事件处理"""
        resolver.session_id = "test_session"
        
        # 模拟scriptParsed事件
        params = {
            "sessionId": "test_session",
            "scriptId": "script123",
            "url": "https://example.com/app.js",
            "sourceMapURL": "app.js.map"
        }
        
        await resolver._on_script_parsed(params)
        
        # 验证脚本元数据被记录
        assert "script123" in resolver.script_metadata
        assert resolver.script_metadata["script123"]["sourceMapURL"] == "app.js.map"
    
    @pytest.mark.asyncio
    async def test_source_map_download_and_parse(self, resolver):
        """测试Source Map下载和解析"""
        with patch('browserfairy.analysis.source_map.sourcemap') as mock_sourcemap:
            # 模拟Source Map内容
            mock_source_map = MagicMock()
            mock_source_map.lookup.return_value = MagicMock(
                src="src/app.js",
                src_line=42,
                src_col=10,
                name="myFunction"
            )
            mock_sourcemap.loads.return_value = mock_source_map
            
            # 模拟HTTP响应
            resolver.http_client.get = AsyncMock()
            resolver.http_client.get.return_value.text = '{"version": 3}'
            resolver.http_client.get.return_value.raise_for_status = MagicMock()
            
            # 获取Source Map
            source_map = await resolver._get_source_map(
                "https://example.com/app.js",
                "app.js.map"
            )
            
            assert source_map is not None
            # 验证缓存
            assert "https://example.com/app.js.map" in resolver.source_map_cache
    
    @pytest.mark.asyncio
    async def test_resolve_frame_without_scriptid(self, resolver):
        """测试没有scriptId的帧保持原样"""
        frame = {
            "function": "myFunction",
            "url": "https://example.com/app.js",
            "line": 10,
            "column": 5
        }
        
        enhanced_frame = await resolver.resolve_frame(frame)
        
        # 应该原样返回，不添加original字段
        assert enhanced_frame == frame
        assert "original" not in enhanced_frame
    
    @pytest.mark.asyncio
    async def test_cleanup(self, resolver, mock_connector):
        """测试清理资源（不禁用Debugger）"""
        await resolver.initialize("test_session")
        await resolver.cleanup()
        
        # 验证取消事件监听
        mock_connector.off_event.assert_called_with(
            "Debugger.scriptParsed",
            resolver._on_script_parsed
        )
        # 验证不调用Debugger.disable
        mock_connector.call.assert_not_called()
        # 验证清理缓存
        assert len(resolver.script_metadata) == 0
        assert len(resolver.source_map_cache) == 0
        assert len(resolver.location_cache) == 0
    
    def test_lru_cache_eviction(self, resolver):
        """测试LRU缓存淘汰"""
        resolver.max_cache_size = 3
        
        # 填充缓存
        for i in range(4):
            key = f"key{i}"
            value = {"data": i}
            resolver._update_cache(key, value)
        
        # 第一个应该被淘汰
        assert "key0" not in resolver.location_cache
        assert "key1" in resolver.location_cache
        assert "key2" in resolver.location_cache
        assert "key3" in resolver.location_cache
```

#### 第二轮测试（ConsoleMonitor集成）
```python
# tests/test_console_source_map.py

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from browserfairy.monitors.console import ConsoleMonitor

class TestConsoleMonitorWithSourceMap:
    
    @pytest.fixture
    def console_monitor(self):
        """创建ConsoleMonitor实例"""
        connector = AsyncMock()
        event_queue = AsyncMock()
        monitor = ConsoleMonitor(connector, "test_session", event_queue)
        monitor.set_hostname("example.com")
        return monitor
    
    @pytest.mark.asyncio
    async def test_source_map_disabled_by_default(self, console_monitor):
        """测试Source Map默认关闭"""
        await console_monitor.start_monitoring()
        assert console_monitor.source_map_resolver is None
    
    @pytest.mark.asyncio
    async def test_source_map_enabled(self, console_monitor):
        """测试启用Source Map"""
        console_monitor.enable_source_map = True
        
        with patch("browserfairy.monitors.console.SourceMapResolver") as MockResolver:
            mock_resolver = AsyncMock()
            MockResolver.return_value = mock_resolver
            mock_resolver.initialize.return_value = True
            
            await console_monitor.start_monitoring()
            
            assert console_monitor.source_map_resolver is not None
            mock_resolver.initialize.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_backward_compatibility(self, console_monitor):
        """测试字段向后兼容性"""
        # 触发异常事件
        params = {
            "sessionId": "test_session",
            "exceptionDetails": {
                "text": "Test error",
                "stackTrace": {
                    "callFrames": [{
                        "functionName": "test",
                        "scriptId": "123",
                        "url": "https://example.com/app.js",
                        "lineNumber": 10,
                        "columnNumber": 20
                    }]
                }
            }
        }
        
        await console_monitor._on_exception_thrown(params)
        
        # 验证队列中的数据
        call_args = console_monitor.event_queue.put_nowait.call_args
        event_type, event_data = call_args[0][0]
        
        # 验证保留了原字段名
        stack_frame = event_data["stackTrace"][0]
        assert "function" in stack_frame  # 原字段
        assert "url" in stack_frame       # 原字段
        assert "line" in stack_frame      # 原字段
        assert "column" in stack_frame    # 原字段
        
        # 验证新增了字段
        assert "scriptId" in stack_frame
        assert "lineNumber" in stack_frame
        assert "columnNumber" in stack_frame
    
    @pytest.mark.asyncio
    async def test_exception_with_source_map(self, console_monitor):
        """测试异常事件的Source Map增强"""
        console_monitor.enable_source_map = True
        console_monitor.source_map_resolver = AsyncMock()
        
        # 模拟增强后的堆栈（保持字段兼容）
        enhanced_stack = [{
            "function": "test",  # 保留原字段
            "url": "https://example.com/app.js",
            "line": 1,
            "column": 100,
            "scriptId": "123",
            "lineNumber": 1,
            "columnNumber": 100,
            "original": {  # 仅新增original字段
                "file": "source.js",
                "line": 45,
                "column": 10
            }
        }]
        console_monitor.source_map_resolver.resolve_stack_trace.return_value = enhanced_stack
        
        # 触发异常事件
        params = {
            "sessionId": "test_session",
            "exceptionDetails": {
                "text": "Test error",
                "stackTrace": {
                    "callFrames": [{
                        "functionName": "test",
                        "scriptId": "123",
                        "lineNumber": 1,
                        "columnNumber": 100
                    }]
                }
            }
        }
        
        await console_monitor._on_exception_thrown(params)
        
        # 验证调用了source map解析
        console_monitor.source_map_resolver.resolve_stack_trace.assert_called_once()
```

### 集成测试
```python
async def test_console_monitor_with_source_map():
    """测试ConsoleMonitor集成Source Map功能"""
    
async def test_real_website_source_map():
    """测试真实网站的Source Map解析"""
```

### v1验收标准

**实现前置条件**：
- [ ] 运行test_source_map_lib.py验证Source Map库API
- [ ] 确认sourcemap库的具体API用法
- [ ] 必要时切换到python-sourcemaps库

**字段兼容性**：
- [ ] 保留原有`function/url/line/column`字段不变
- [ ] 新增`scriptId/lineNumber/columnNumber`字段用于解析
- [ ] 仅在有scriptId的帧中添加`original`字段

**功能实现**：
- [ ] 监听Debugger.scriptParsed事件（带sessionId过滤）
- [ ] 收集scriptId→sourceMapURL映射
- [ ] 支持data URL和HTTP直接下载Source Map（v1范围）
- [ ] 使用验证过的Source Map库API进行位置映射
- [ ] 三级缓存：scriptId映射、Source Map文件、位置结果

**兼容性要求**：
- [ ] 不主动启用Debugger domain（复用已有）
- [ ] cleanup时不禁用Debugger（避免影响其他组件）
- [ ] 默认关闭，需显式启用`enable_source_map`参数
- [ ] Source Map不可用时静默降级

**性能要求**：
- [ ] 异步处理，不阻塞主监控流程
- [ ] HTTP请求5秒超时，快速失败
- [ ] LRU缓存限制在10个Source Map文件
- [ ] 位置缓存可存储100个映射结果

**测试覆盖**：
- [ ] 字段向后兼容性测试
- [ ] 无scriptId帧保持原样测试
- [ ] sessionId过滤测试
- [ ] 缓存淘汰机制测试
- [ ] 资源清理测试（不禁用Debugger）