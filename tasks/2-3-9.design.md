# Design 2-3-9 - WebSocket消息监控

## Requirements

扩展现有NetworkMonitor，添加WebSocket消息帧监控能力，帮助诊断WebSocket相关的性能问题。

### 核心需求
- 监控WebSocket消息的发送和接收事件
- 记录消息大小、类型、频率信息
- 支持文本和二进制消息的适当处理
- 集成到现有的网络监控数据流中

### 技术约束
- 不能破坏现有NetworkMonitor的功能
- 复用现有的event_queue机制和数据写入流程
- 保持与现有HTTP监控数据格式的一致性
- Network.enable已启用，无需额外domain配置

## Solution

### 核心设计原则
1. **最小侵入性**：在现有NetworkMonitor中添加WebSocket事件处理器
2. **数据格式统一**：WebSocket数据写入同一个network.jsonl文件
3. **性能优先**：消息内容截断处理，避免大数据量影响
4. **测试驱动**：先写测试用例，确保功能正确性和回归防护

### 实现方案

#### 1. 事件监听扩展
在NetworkMonitor.start_monitoring()中添加WebSocket全生命周期事件监听：
```python
# WebSocket生命周期事件
self.connector.on_event("Network.webSocketCreated", self._on_websocket_created)
self.connector.on_event("Network.webSocketFrameSent", self._on_websocket_frame_sent)
self.connector.on_event("Network.webSocketFrameReceived", self._on_websocket_frame_received)
self.connector.on_event("Network.webSocketFrameError", self._on_websocket_frame_error)
self.connector.on_event("Network.webSocketClosed", self._on_websocket_closed)
```

在stop_monitoring()中对应清理：
```python
# WebSocket事件解绑
self.connector.off_event("Network.webSocketCreated", self._on_websocket_created)
self.connector.off_event("Network.webSocketFrameSent", self._on_websocket_frame_sent)
self.connector.off_event("Network.webSocketFrameReceived", self._on_websocket_frame_received)
self.connector.off_event("Network.webSocketFrameError", self._on_websocket_frame_error)
self.connector.off_event("Network.webSocketClosed", self._on_websocket_closed)
```

#### 2. 数据结构设计

##### WebSocket连接创建事件：
```json
{
  "type": "websocket_created",
  "timestamp": "2025-01-01T10:00:00Z",
  "requestId": "ws_request_123",
  "url": "wss://example.com/live",
  "hostname": "example.com",
  "sessionId": "session_123",
  "event_id": "generated_hash"
}
```

##### WebSocket消息帧事件：
```json
{
  "type": "websocket_frame_sent|websocket_frame_received",
  "timestamp": "2025-01-01T10:00:00Z",
  "requestId": "ws_request_123",
  "url": "wss://example.com/live",
  "opcode": 1,
  "payloadLength": 2048,
  "payloadText": "截断的文本内容...",
  "hostname": "example.com",
  "sessionId": "session_123",
  "event_id": "generated_hash"
}
```

##### WebSocket错误和关闭事件：
```json
{
  "type": "websocket_closed|websocket_frame_error",
  "timestamp": "2025-01-01T10:00:00Z",
  "requestId": "ws_request_123",
  "url": "wss://example.com/live",
  "reason": "close reason or error message",
  "hostname": "example.com",
  "sessionId": "session_123",
  "event_id": "generated_hash"
}
```

#### 3. 数据存储和映射管理

##### requestId -> URL映射维护
```python
# 在NetworkMonitor中增加WebSocket连接跟踪
self.websocket_connections = {}  # requestId -> {url, created_at, stats}
```

##### 消息内容处理策略（修正版）
- **文本消息**(opcode=1)：截取前1024字符，超长加"...[truncated]"
- **二进制消息**(opcode=2)：**仅记录payloadLength和类型，不记录内容**
- **控制帧**(ping/pong/close)：记录类型和opcode，不记录payload
- **未知opcode**：记录原始opcode值和长度

**重要调整**：CDP的`payloadData`是字符串表示，不是原始字节，不能直接转换为十六进制。

##### 聚合统计设计
按hostname+path维度计数，记录在每个WebSocket事件中：
```python
# 在事件中添加聚合统计
frame_data["frameStats"] = {
    "totalFramesThisSecond": self._count_frames_in_current_second(hostname, path),
    "connectionAge": time.now() - connection_created_time
}
```

#### 4. 事件ID生成（简化版）

使用现有的`utils/event_id.make_event_id`，不新增API：
```python
# WebSocket事件ID生成
event_id = make_event_id(
    "websocket_frame_sent",  # 事件类型
    self.hostname,           # 主机名
    timestamp,               # 时间戳
    request_id,              # WebSocket连接ID
    opcode,                  # 消息类型
    payload_length           # 消息长度
)
```

**优势**：保持API一致性，降低改动面，减少回归风险。

### 集成点分析

#### 与现有NetworkMonitor的协作
- **事件过滤**：与现有HTTP事件一样做`sessionId`过滤
- **数据队列**：复用`self.event_queue`机制
- **错误处理**：遵循现有的`try-except`模式和`logger.warning`约定
- **生命周期管理**：在`stop_monitoring`中正确解绑所有WebSocket事件

#### 新增状态管理
```python
# 在NetworkMonitor.__init__()中添加
self.websocket_connections = {}  # requestId -> connection_info
self.websocket_frame_stats = {}  # (hostname, path) -> frame_count_per_second
```

#### 数据写入流程保持不变
```
WebSocket事件 → sessionId过滤 → event_queue → MemoryCollector._consume_events() → data_callback → DataManager → network.jsonl
```

## Tests

### 测试策略（TDD方法）

#### 1. 单元测试
测试文件：`tests/test_websocket_monitoring.py`

**测试用例设计**：
```python
class TestWebSocketMonitoring:
    # 基础功能测试
    def test_websocket_frame_sent_event()
    def test_websocket_frame_received_event()
    
    # 消息类型处理测试
    def test_text_message_truncation()
    def test_binary_message_hex_encoding()
    def test_control_frame_handling()
    
    # 集成测试
    def test_event_queue_integration()
    def test_session_id_filtering()
    def test_event_id_generation()
    
    # 边界情况测试
    def test_large_text_message()
    def test_empty_payload()
    def test_invalid_opcode()
```

#### 2. 集成测试模拟
```python
# 模拟CDP WebSocket事件数据
MOCK_WS_FRAME_SENT = {
    "requestId": "ws_123",
    "timestamp": 1234567.89,
    "response": {
        "opcode": 1,
        "payloadData": "Hello WebSocket"
    },
    "sessionId": "session_456"
}
```

#### 3. 回归测试保护
确保WebSocket功能不影响现有HTTP监控：
- 验证现有HTTP事件仍正常处理
- 验证事件队列性能不受影响
- 验证数据文件格式向下兼容

#### 4. 性能测试指标
- WebSocket高频消息场景下的内存占用
- 事件队列处理延迟变化
- 数据文件写入性能影响

### 测试数据文件验证
生成的network.jsonl应包含WebSocket事件：
```jsonl
{"type":"websocket_frame_sent","timestamp":"2025-01-01T10:00:00Z","requestId":"ws_123"...}
{"type":"websocket_frame_received","timestamp":"2025-01-01T10:00:01Z","requestId":"ws_123"...}
```

### 关键技术决策总结

**基于专家意见的核心调整**：
1. ✅ **完整生命周期监控**：Created+Frame+Closed/Error，便于诊断连接问题
2. ✅ **sessionId过滤+事件解绑**：防止内存泄漏和事件混乱
3. ✅ **requestId->URL映射**：保持数据格式与HTTP一致性
4. ✅ **简化二进制处理**：避免CDP字符串表示的编码错误
5. ✅ **API一致性**：复用现有event_id工具，不新增接口

### 实施验证标准
- [ ] 所有单元测试通过（重点：sessionId过滤、事件解绑）
- [ ] WebSocket全生命周期事件记录到network.jsonl
- [ ] 现有HTTP监控功能完全不受影响（回归测试）
- [ ] requestId->URL映射正确维护（包括连接清理）
- [ ] 聚合统计正确记录（每秒帧数统计）