# Design 2-3-10 - 事件监听器详情分组统计

## Requirements

### 核心问题
开发者在实际使用中发现的关键痛点：**内存泄漏源头难定位** - 知道内存在增长，但不知道具体是哪个组件或函数导致事件监听器泄漏。

当前监控只提供监听器总数(`listeners: 342`)，无法指导具体的问题修复。需要能够：
1. **定位到具体文件和函数**：告诉开发者是哪个JS文件的哪行代码在泄漏监听器
2. **识别异常增长模式**：发现同一函数被重复绑定到多个元素的问题
3. **提供可操作的修复建议**：从"不知道哪里有问题"到"检查ProductList.js:156的事件清理逻辑"

### 技术可行性
使用`DOMDebugger.getEventListeners`可以获取详细信息：
- 监听器的函数名称和描述
- 精确的文件位置(scriptId + lineNumber)  
- 事件类型和目标元素信息
- 通过`Debugger.getScriptSource`获取完整文件URL

## Solution

### 核心设计原则
1. **异常触发**：只在监听器异常增长(>20个)时执行详细分析，平时做轻量级统计
2. **来源聚合**：按文件+行号分组，统计同一函数绑定到多少元素上
3. **性能优先**：只分析监听器最多的前50个元素，避免全页面扫描
4. **集成现有架构**：扩展MemoryCollector，复用会话管理和数据写入机制

### 实现架构

#### 1. 扩展MemoryCollector
**关键**：基于现有的`collect_memory_snapshot`方法扩展，保持向后兼容性：

```python
async def collect_memory_snapshot(self) -> Dict[str, Any]:
    # ... 现有内存收集逻辑保持不变 ...
    
    # 4. Build output (现有逻辑)
    record = {
        "type": "memory",
        "memory": {
            "listeners": extracted["JSEventListeners"],  # 保持现有格式
            # ... 其他现有字段
        }
    }
    
    # 5. 新增：事件监听器详细分析(可选，不影响现有数据)
    try:
        current_listener_count = extracted["JSEventListeners"] or 0
        listeners_analysis = await self._analyze_event_listeners(current_listener_count)
        if listeners_analysis:
            record["eventListenersAnalysis"] = listeners_analysis
    except Exception as e:
        logger.warning(f"Event listener analysis failed: {e}")
        # 失败不影响主要数据收集
    
    # Add event_id (现有逻辑)
    record["event_id"] = make_event_id(...)
    return record

async def _analyze_event_listeners(self, current_count: int) -> Optional[Dict[str, Any]]:
    """分析事件监听器详情，仅在异常增长时执行"""
    if not self._event_listener_analysis_enabled:
        return None
        
    # 1. 计算增长delta
    growth_delta = current_count - self._last_listener_count
    self._last_listener_count = current_count
    
    # 2. 轻量级统计 (每次都执行)
    try:
        basic_stats = await self._get_basic_listener_stats()
    except Exception as e:
        logger.debug(f"Basic listener stats failed: {e}")
        return None
    
    # 3. 检查是否需要详细分析 (MVP版本：简单阈值)
    analysis_result = {
        "summary": basic_stats,
        "growthDelta": growth_delta,
        "analysisTriggered": False
    }
    
    if growth_delta > 20:  # 增长阈值
        # 异步启动详细分析，避免阻塞采样周期
        if not self._detailed_analysis_task or self._detailed_analysis_task.done():
            self._detailed_analysis_task = asyncio.create_task(
                self._async_detailed_analysis(current_count, basic_stats)
            )
        analysis_result["analysisTriggered"] = True
        
    return analysis_result

async def _async_detailed_analysis(self, current_count: int, basic_stats: dict) -> None:
    """异步执行详细分析，避免阻塞内存采样周期"""
    try:
        # 只在需要时启用DOMDebugger域
        await self.connector.call("DOMDebugger.enable", session_id=self.session_id, timeout=10.0)
        
        # 执行详细分析，带超时控制
        detailed_sources = await asyncio.wait_for(
            self._perform_detailed_listener_analysis(), timeout=3.0
        )
        
        # 构建完整分析结果并通过data_callback发送
        if detailed_sources and self.data_callback:
            analysis_result = {
                "type": "memory",  # 仍然作为memory事件的扩展部分
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "hostname": self.hostname,
                "targetId": self.target_id,
                "sessionId": self.session_id,
                "eventListenersAnalysis": {
                    "summary": basic_stats,
                    "growthDelta": current_count - (self._last_listener_count - current_count + self._last_listener_count),
                    "analysisTriggered": True,
                    "detailedSources": detailed_sources
                }
            }
            
            if asyncio.iscoroutinefunction(self.data_callback):
                await self.data_callback(analysis_result)
            else:
                self.data_callback(analysis_result)
                
    except asyncio.TimeoutError:
        logger.warning("Detailed event listener analysis timeout (3s)")
    except Exception as e:
        logger.warning(f"Detailed event listener analysis failed: {e}")
    finally:
        # 可选：关闭DOMDebugger域减少事件噪音
        try:
            await self.connector.call("DOMDebugger.disable", session_id=self.session_id)
        except Exception:
            pass
```

#### 2. 事件监听器分析实现

```python
async def _get_basic_listener_stats(self) -> Dict[str, Any]:
    """获取基础监听器统计"""
    # 创建专用objectGroup避免内存泄漏
    object_group = f"listener_analysis_{int(datetime.now().timestamp())}"
    
    try:
        # 获取document和window的objectId
        doc_result = await self.connector.call(
            "Runtime.evaluate",
            {"expression": "document", "objectGroup": object_group},
            session_id=self.session_id
        )
        win_result = await self.connector.call(
            "Runtime.evaluate", 
            {"expression": "window", "objectGroup": object_group},
            session_id=self.session_id
        )
        
        # 获取详细监听器信息
        doc_listeners_response = await self.connector.call(
            "DOMDebugger.getEventListeners",
            {"objectId": doc_result["result"]["objectId"]},
            session_id=self.session_id
        )
        win_listeners_response = await self.connector.call(
            "DOMDebugger.getEventListeners",
            {"objectId": win_result["result"]["objectId"]}, 
            session_id=self.session_id
        )
        
        # 正确访问listeners数组
        doc_listeners = doc_listeners_response.get("listeners", [])
        win_listeners = win_listeners_response.get("listeners", [])
        
        # 轻量级估算：elements_total ≈ (JSEventListeners - document - window)
        total_from_metrics = extracted["JSEventListeners"] or 0
        elements_total = max(0, total_from_metrics - len(doc_listeners) - len(win_listeners))
        
        return {
            "total": len(doc_listeners) + len(win_listeners) + elements_total,
            "byTarget": {
                "document": len(doc_listeners),
                "window": len(win_listeners),
                "elements": elements_total
            },
            "byType": self._group_listeners_by_type(doc_listeners + win_listeners)
        }
        
    finally:
        # 释放objectGroup避免内存泄漏
        try:
            await self.connector.call(
                "Runtime.releaseObjectGroup",
                {"objectGroup": object_group},
                session_id=self.session_id
            )
        except Exception:
            pass

async def _perform_detailed_listener_analysis(self) -> List[Dict[str, Any]]:
    """详细监听器来源分析 - 有限候选采样避免全页面扫描"""
    object_group = f"detailed_analysis_{int(datetime.now().timestamp())}"
    
    try:
        # 1. 有限候选集合：避免全页面搜索，专注常见泄漏场景
        candidate_selectors = [
            "body",  # 页面主体
            "[role=button]", "button",  # 按钮类元素  
            "a[href]",  # 链接
            "input", "select", "textarea",  # 表单元素
            ".modal", ".dialog", ".popup",  # 弹窗组件
            ".chart-container", ".visualization"  # 可视化组件
        ]
        
        candidate_elements = []
        
        # 获取每类元素的前100个，总计≤800个候选
        for selector in candidate_selectors:
            try:
                elements_result = await self.connector.call(
                    "Runtime.evaluate",
                    {
                        "expression": f"Array.from(document.querySelectorAll('{selector}')).slice(0, 100)",
                        "objectGroup": object_group
                    },
                    session_id=self.session_id
                )
                if elements_result.get("result", {}).get("objectId"):
                    candidate_elements.append(elements_result["result"]["objectId"])
            except Exception:
                continue  # 跳过失败的选择器
        
        # 2. 按来源(scriptId+lineNumber)聚合监听器
        sources = defaultdict(lambda: {
            "elementCount": 0,
            "eventTypes": set(),
            "functionName": "",
            "scriptId": "",
            "lineNumber": 0
        })
        
        # 分析候选元素的监听器
        for element_array_id in candidate_elements[:300]:  # 限制最多300个数组对象
            try:
                # 获取数组中每个元素的监听器
                array_length_result = await self.connector.call(
                    "Runtime.getProperties", 
                    {"objectId": element_array_id},
                    session_id=self.session_id
                )
                
                properties = array_length_result.get("result", [])
                for prop in properties:
                    if prop.get("name", "").isdigit():  # 数组索引
                        element_id = prop.get("value", {}).get("objectId")
                        if not element_id:
                            continue
                            
                        listeners_response = await self.connector.call(
                            "DOMDebugger.getEventListeners",
                            {"objectId": element_id},
                            session_id=self.session_id
                        )
                        
                        for listener in listeners_response.get("listeners", []):
                            location = listener.get("location", {})
                            script_id = location.get("scriptId")
                            line_number = location.get("lineNumber")
                            
                            if script_id and line_number:
                                source_key = f"{script_id}:{line_number}"
                                source_data = sources[source_key]
                                
                                source_data["elementCount"] += 1
                                source_data["eventTypes"].add(listener.get("type", "unknown"))
                                source_data["scriptId"] = script_id
                                source_data["lineNumber"] = line_number
                                source_data["functionName"] = self._extract_function_name(
                                    listener.get("handler", {}).get("description", "")
                                )
                                
            except Exception as e:
                logger.debug(f"Failed to analyze element array: {e}")
                continue
        
        # 3. 使用缓存的URL映射，避免错误的getScriptSource调用
        result = []
        for source_key, data in sources.items():
            if data["elementCount"] > 1:  # 只关注绑定到多个元素的函数
                script_id = data["scriptId"]
                source_file = self._script_url_cache.get(script_id, f"script://{script_id}")
                
                result.append({
                    "sourceFile": source_file,
                    "lineNumber": data["lineNumber"],
                    "functionName": data["functionName"][:100],  # 截断函数名
                    "elementCount": data["elementCount"], 
                    "eventTypes": list(data["eventTypes"])[:5],  # 限制事件类型数量
                    "suspicion": "high" if data["elementCount"] > 10 else "medium",
                    "scriptId": script_id  # 保留用于调试
                })
        
        # 按元素绑定数量排序，返回前10个最可疑的来源
        return sorted(result, key=lambda x: x["elementCount"], reverse=True)[:10]
        
    finally:
        # 释放所有分析用的对象
        try:
            await self.connector.call(
                "Runtime.releaseObjectGroup",
                {"objectGroup": object_group},
                session_id=self.session_id
            )
        except Exception:
            pass
```

#### 3. 数据格式扩展

扩展memory.jsonl的数据结构：

```json
{
  "type": "memory",
  "timestamp": "2025-08-19T10:30:25Z",
  "memory": {
    "jsHeap": {...},
    "listeners": 234  // 保持兼容性
  },
  "eventListenersAnalysis": {
    "summary": {
      "total": 234,
      "byTarget": {
        "document": 23,
        "window": 12, 
        "elements": 199
      },
      "byType": {
        "click": 89,
        "scroll": 45,
        "resize": 23
      }
    },
    "growthDelta": 32,
    "analysisTriggered": true,
    "detailedSources": [
      {
        "sourceFile": "https://example.com/js/ProductList.js",
        "lineNumber": 156,
        "functionName": "handleProductClick",
        "elementCount": 15,
        "eventTypes": ["click"],
        "suspicion": "high"
      }
    ]
  }
}
```

### 集成方式

#### 1. CDP域管理和脚本URL缓存
在`attach()`方法中添加必要的域启用和事件监听：

```python
async def attach(self) -> None:
    # ... 现有逻辑 ...
    
    # Enable Performance domain (现有逻辑)
    try:
        await self.connector.call("Performance.enable", session_id=self.session_id, timeout=15.0)
    except Exception:
        pass
    
    # 新增：启用事件监听器分析所需的域
    try:
        # 始终启用Debugger域并监听scriptParsed，成本低
        await self.connector.call("Debugger.enable", session_id=self.session_id, timeout=10.0)
        self.connector.on_event("Debugger.scriptParsed", self._on_script_parsed)
        self._event_listener_analysis_enabled = True
        logger.debug("Event listener analysis enabled")
    except Exception as e:
        logger.debug(f"Failed to enable event listener analysis: {e}")
        self._event_listener_analysis_enabled = False

async def _on_script_parsed(self, params: dict) -> None:
    """监听Debugger.scriptParsed事件，维护scriptId->URL映射"""
    if params.get("sessionId") != self.session_id:
        return
        
    script_id = params.get("scriptId")
    url = params.get("url")
    if script_id and url:
        # 维护轻量级LRU缓存，最多缓存1000个脚本
        if len(self._script_url_cache) >= 1000:
            # 简单的FIFO清理策略
            oldest_key = next(iter(self._script_url_cache))
            del self._script_url_cache[oldest_key]
        
        self._script_url_cache[script_id] = url
```

#### 2. 数据缓存和增长检测
在MemoryCollector中添加必要的状态跟踪：

```python
def __init__(self, ...):
    # ... 现有初始化 ...
    
    # 新增：事件监听器分析相关状态
    self._event_listener_analysis_enabled = False
    self._last_listener_count = 0
    self._listener_growth_history = deque(maxlen=5)  # 保留最近5次统计
    self._script_url_cache = {}  # scriptId -> url映射
    self._detailed_analysis_task = None  # 异步分析任务跟踪
```

#### 3. 错误处理和降级策略
- **域启用失败** → 跳过详细分析，保持基础监控
- **详细分析异常** → 记录警告日志，不中断数据收集  
- **超时控制** → 详细分析超过3秒自动中止，避免影响采样周期
- **objectGroup清理** → 确保所有分析用的对象都被正确释放
- **缓存清理** → URL缓存超过1000项时FIFO清理，避免内存膨胀

#### 4. 性能保障和资源控制
- **触发阈值**：只在监听器增长>20时执行详细分析
- **候选限制**：每类元素最多100个，总计≤800个候选元素
- **分析范围**：限制在常见泄漏场景(按钮、表单、弹窗等)，避免全页面扫描
- **超时控制**：3秒执行超时，保证不阻塞内存采样周期
- **异步执行**：详细分析异步进行，不影响主采样流程
- **数据截断**：函数名截断至100字符，事件类型限制5个

## Tests

### 测试策略

#### 1. 单元测试 (test_event_listener_analysis.py)
- 基础统计功能测试
- 增长delta计算测试  
- 详细分析触发条件测试
- 数据聚合逻辑测试
- 错误处理和降级测试

#### 2. 集成测试
- 与现有memory收集的兼容性测试
- CDP域启用和方法调用测试
- 数据格式向后兼容性测试

#### 3. 性能测试
- 详细分析执行时间测试 (<5s)
- 内存开销测试 (<10MB额外占用)
- 高频触发场景测试

#### 4. 模拟测试场景
```python
@pytest.mark.asyncio
async def test_listener_leak_detection():
    """测试监听器泄漏检测能力"""
    collector = create_test_collector()
    
    # 模拟监听器从100增长到150
    collector._last_listener_count = 100
    
    # Mock CDP调用返回150个监听器，触发详细分析
    mock_performance_response = {"metrics": [{"name": "JSEventListeners", "value": 150}]}
    mock_detailed_listeners = create_mock_listener_data()  # 包含重复绑定的函数
    
    with patch_cdp_calls(collector.connector) as mock_calls:
        mock_calls.return_values = [mock_performance_response, mock_detailed_listeners]
        
        result = await collector.collect_memory_snapshot()
        
        # 验证触发了详细分析
        assert "eventListenersAnalysis" in result
        assert result["eventListenersAnalysis"]["analysisTriggered"] is True
        assert result["eventListenersAnalysis"]["growthDelta"] == 50
        
        # 验证识别出问题函数
        sources = result["eventListenersAnalysis"]["detailedSources"]
        assert len(sources) > 0
        assert sources[0]["functionName"] == "handleProductClick"
        assert sources[0]["elementCount"] >= 10
    
@pytest.mark.asyncio
async def test_normal_growth_no_analysis():
    """测试正常增长不触发详细分析"""
    collector = create_test_collector()
    collector._last_listener_count = 100
    
    # Mock返回115个监听器(+15个，低于阈值)
    mock_response = {"metrics": [{"name": "JSEventListeners", "value": 115}]}
    
    with patch_cdp_calls(collector.connector) as mock_calls:
        mock_calls.return_values = [mock_response]
        
        result = await collector.collect_memory_snapshot()
        
        # 验证没有触发详细分析
        analysis = result.get("eventListenersAnalysis", {})
        assert analysis.get("analysisTriggered") is False
        assert analysis.get("growthDelta") == 15
        assert "detailedSources" not in analysis

@pytest.mark.asyncio 
async def test_backwards_compatibility():
    """测试向后兼容性 - 现有数据格式不变"""
    collector = create_test_collector()
    collector._event_listener_analysis_enabled = False  # 禁用详细分析
    
    mock_response = {"metrics": [{"name": "JSEventListeners", "value": 123}]}
    
    with patch_cdp_calls(collector.connector) as mock_calls:
        mock_calls.return_values = [mock_response]
        
        result = await collector.collect_memory_snapshot()
        
        # 验证现有数据格式完全不变
        assert result["memory"]["listeners"] == 123
        assert "eventListenersAnalysis" not in result  # 新字段不存在
        
def test_error_handling_graceful_degradation():
    """测试错误处理和优雅降级"""
    collector = create_test_collector()
    
    # Mock详细分析抛出异常
    with patch_cdp_calls(collector.connector) as mock_calls:
        mock_calls.side_effect = [
            {"metrics": [{"name": "JSEventListeners", "value": 150}]},  # 正常基础数据
            Exception("DOMDebugger failed")  # 详细分析失败
        ]
        
        result = await collector.collect_memory_snapshot()
        
        # 验证基础数据仍然正常收集
        assert result["memory"]["listeners"] == 150
        # 详细分析失败，但不影响主要功能
        assert "eventListenersAnalysis" not in result

def create_mock_listener_data():
    """创建模拟的监听器详细数据"""
    return {
        "listeners": [
            {
                "type": "click",
                "handler": {"description": "function handleProductClick() { [code] }"},
                "location": {"scriptId": "123", "lineNumber": 156}
            },
            {
                "type": "scroll", 
                "handler": {"description": "function onScroll() { [code] }"},
                "location": {"scriptId": "124", "lineNumber": 89}
            }
            # ... 更多测试数据
        ]
    }

@pytest.mark.asyncio
async def test_script_url_mapping():
    """测试scriptId->URL映射机制"""
    collector = create_test_collector()
    
    # 模拟scriptParsed事件
    await collector._on_script_parsed({
        "sessionId": collector.session_id,
        "scriptId": "123",
        "url": "https://example.com/js/ProductList.js"
    })
    
    # 验证URL映射被正确缓存
    assert collector._script_url_cache.get("123") == "https://example.com/js/ProductList.js"

def test_url_cache_lru_cleanup():
    """测试URL缓存的LRU清理机制"""
    collector = create_test_collector()
    
    # 填充超过1000个缓存项
    for i in range(1001):
        collector._script_url_cache[f"script_{i}"] = f"https://example.com/script_{i}.js"
    
    # 验证缓存大小被限制
    assert len(collector._script_url_cache) <= 1000
    # 验证最老的项被清理
    assert "script_0" not in collector._script_url_cache
```

### TDD实施步骤

1. **先写测试用例**：定义期望的数据结构和行为
2. **实现基础统计**：先实现轻量级的监听器统计
3. **实现增长检测**：添加delta计算和触发逻辑
4. **实现详细分析**：逐步实现来源聚合功能
5. **集成测试验证**：确保不破坏现有功能

### 预期开发时间

基于专家意见修正后的开发计划：

- **第1-2天**：基础架构 + 脚本URL缓存机制
  - 实现`_on_script_parsed`事件监听和URL映射
  - 添加基础的增长检测和轻量级统计
  - 编写核心测试用例

- **第3-4天**：详细分析核心逻辑  
  - 实现有限候选采样策略
  - objectGroup管理和内存安全
  - 异步分析任务架构

- **第5-6天**：集成测试和错误处理
  - 完整的降级策略实现
  - 向后兼容性验证
  - 性能测试和优化

- **第7天**：文档和最终测试
  - 更新DATA_ANALYSIS_GUIDE.md
  - 端到端功能验证
  - 代码review和清理

**总计：6-7天**（比原计划略短，因为避免了一些过度设计）

### 关键里程碑验证

- ✅ **Day 2**: 基础功能可用，能输出listener统计和增长delta
- ✅ **Day 4**: 详细分析可以定位到具体文件和函数名  
- ✅ **Day 6**: 所有错误场景都有优雅降级，不影响现有功能
- ✅ **Day 7**: 完整功能交付，ready for production use