# Design 1 - Chrome性能监控工具

## Requirements

### 核心问题
- Web程序在浏览器运行一段时间后变卡、电脑发烫、页面加载慢
- 重启Chrome能暂时解决问题
- 该问题断断续续存在快一年，开发团队无法定位根本原因
- 需要工具来发现和定位问题，而不是简单解决表面症状

### 部署模式
- **用户端部署**：工具安装在用户的机器上，自动收集监控数据
- **数据回传**：用户定期手动发送收集的数据文件给开发团队
- **集中分析**：开发团队使用Claude Code等AI工具分析收集的数据
- **隐私安全**：数据完全在用户控制下，手动决定何时分享

### 功能需求
1. **内存监控维度**
   - JS堆内存使用量和限制
   - DOM节点总数和增长速率
   - 事件监听器数量
   - 分离DOM节点数（内存泄漏指标）
   - 垃圾回收触发频率和耗时
   - Document和Frame数量

2. **性能监控维度**
   - 主线程阻塞时间和频率
   - JavaScript执行时间分布
   - 布局重排和重绘次数
   - FPS和掉帧统计
   - 长任务检测（>50ms的任务）
   - CPU使用率（按进程和标签页）

3. **网络监控维度（精准到API调用）**
   - **详细请求追踪**：URL、方法、头部、请求体、响应体
   - **调用栈关联**：网络请求的JavaScript发起位置和函数调用链
   - **大数据请求标记**：>1MB的请求响应特别标记（针对5.2M JSON问题）
   - **API性能分析**：各个接口的响应时间、失败率、重试次数
   - **WebSocket消息监控**：实时数据推送的内容和频率
   - **缓存行为分析**：命中/未命中的详细原因
   - **请求时序关联**：网络请求与内存峰值的时间关联

4. **Console日志监控维度（代码级问题定位）**
   - **分级日志收集**：console.log/warn/error/debug的完整内容
   - **性能标记追踪**：console.time/timeEnd的执行耗时统计
   - **错误上下文**：JavaScript异常的完整堆栈信息
   - **自定义标记**：应用代码中的性能埋点和调试信息
   - **大对象警告**：代码中关于大数据处理的日志
   - **模块级分类**：根据日志内容自动识别功能模块

5. **JavaScript执行监控维度（函数级性能）**
   - **长任务检测**：>50ms的函数执行，包含具体函数名和调用栈
   - **内存分配追踪**：哪个函数分配了大量内存
   - **垃圾回收触发**：GC事件与具体代码执行的关联
   - **异常捕获**：运行时错误的详细上下文和变量状态
   - **性能瓶颈识别**：CPU密集型操作的代码位置

6. **用户交互监控**
   - **页面识别信息**：URL、域名、页面标题、referrer
   - **标签页管理**：创建、切换、关闭、激活/非激活状态
   - 页面路由变化（SPA应用内的导航）
   - 用户操作响应延迟
   - 页面可见性变化和焦点切换
   - 滚动性能指标
   - **多标签页影响**：记录标签页数量对各个网站性能的影响

7. **浏览器进程监控**
   - 各进程内存占用
   - 标签页数量变化
   - 扩展程序影响
   - GPU进程状态
   - 渲染进程数量

8. **IndexedDB和存储监控维度**
   - **存储配额监控**：总配额、已使用空间、各origin存储使用情况
   - **存储事件监控**：IndexedDB数据库创建/修改事件（通过CDP Storage domain）
   - **内存峰值关联**：存储操作期间的JS heap激增检测
   - **配额压力报警**：存储使用率接近限制时的警告
   - **跨站点存储影响**：多个网站的存储竞争对性能的影响

9. **异常检测与报告**
   - 检测内存泄漏模式
   - 识别性能下降趋势
   - 捕获异常的网络行为
   - 存储配额异常和大对象操作检测
   - 生成问题分析报告

**AI分析专用指标**
- **网站性能画像** - 每个域名的性能基线和异常模式
- **跨站点影响分析** - A网站的操作如何影响B网站的性能
- **内存增长率模式** - 按网站分别统计线性/指数/周期性增长
- **性能下降轨迹** - 渐进式下降 vs 突然卡顿，按网站维度分析
- **资源竞争指标** - 多标签页/进程间的资源争抢，识别罪魁祸首
- **时间相关性** - 特定时间段各网站的性能表现
- **操作关联性** - 在某网站的操作对其他网站的连锁影响
- **环境变量** - 系统负载、网络状况对不同网站的影响差异

**数据收集与存储**
- **按网站维度分离数据**：每个domain/origin独立记录
- **标签页级别追踪**：记录每个tab的URL、标题、生命周期
- **跨站关联分析**：识别多站点间的资源竞争和相互影响
- **域名分类统计**：主站点 vs 第三方脚本 vs CDN资源的性能影响
- 时序数据采集（每1-5秒记录一次）
- 关联性数据标记（用户操作与性能变化的对应关系）
- 异常点标注（突然的性能下降或内存激增）
- 数据格式便于Claude Code等AI工具分析

### 技术约束
- **性能影响最小**：监控工具本身不能影响浏览器性能
- **安装简单**：员工能快速安装部署
- **自动运行**：启动后无需人工干预
- **数据完整**：收集尽可能详细的调试信息

### 核心技术挑战
- **Chrome DevTools Protocol连接**：确保能稳定连接到Chrome实例
- **多标签页数据同步**：正确跟踪和关联各个网站的数据
- **性能影响最小化**：监控本身不能拖慢浏览器
- **数据完整性**：Chrome崩溃重启后能继续收集数据

### 期望产出

**用户最终收到的东西：**

**macOS（主要支持）- CLI优先**：
1. **Python包** - `pip install browserfairy` 或直接运行源码
2. **CLI命令** - `browserfairy --start-monitoring` 或 `python -m browserfairy --start-monitoring`
3. **简单文档** - README.md中的快速开始指南

**Windows（次要支持）- 打包优先**：
1. **可执行文件** - browserfairy.exe（PyInstaller打包）
2. **简单说明** - 一页纸的双击运行指南

**macOS用户的使用流程：**
1. 下载项目或安装包：`pip install browserfairy`
2. 命令行运行：`browserfairy --start-monitoring`
3. 看到实时监控输出和状态更新
4. 正常使用打开的Chrome窗口浏览
5. 按Ctrl+C或关闭Chrome停止监控
6. 一周后，将 `~/BrowserFairyData/` 文件夹打包发送给开发团队

**Windows用户的使用流程：**
1. 下载 browserfairy.exe 到桌面
2. 双击运行，看到控制台窗口和监控状态
3. 正常使用打开的Chrome窗口浏览
4. 关闭控制台窗口或Chrome停止监控
5. 一周后，将 `C:\Users\用户名\BrowserFairyData\` 文件夹发送给开发团队

**数据存储位置：**
- **Windows**: `C:\Users\用户名\BrowserFairyData\`
- **macOS**: `/Users/用户名/BrowserFairyData/`

**技术实现：**
- **独立Chrome实例管理**：程序自动启动专门的Chrome实例（用户数据目录隔离）
- **生命周期绑定**：监控与Chrome实例生命周期完全绑定，Chrome关闭=监控停止
- **数据存储**：数据存储在用户主目录
- **CLI界面**：实时输出监控状态、发现的问题、数据收集进度
- **安全隔离**：专门Chrome实例与用户日常Chrome完全独立

**最终交付物：**

**macOS版本**：
- browserfairy Python包 - CLI工具，显示实时监控输出
- README.md - 安装和使用说明

**Windows版本（可选）**：
- browserfairy.exe - 自包含可执行文件（约50-100MB，包含Python运行时）
- 简单使用说明

**新增功能：**
- **性能基线建立**：自动记录各网站的正常性能指标，建立基线
- **趋势分析对比**：对比当前性能与历史基线，识别性能退化
- **会话生命周期管理**：Chrome关闭即停止监控，确保数据完整性

## Solution

### 技术架构

**Core Stack**: Python 3.11+ + asyncio + Chrome DevTools Protocol + WebSockets

**独立Chrome实例架构**:
```
BrowserFairy Monitor Service
├── ChromeInstanceManager (1-1-1) - 独立Chrome实例生命周期管理
├── ChromeConnector (1-1) - WebSocket连接管理和重连
├── TabMonitor (1-3) - 标签页事件监控和状态同步
├── MemoryMonitor (1-4) - 内存指标收集
├── DataManager (1-5) - 数据文件写入和存储监控
├── ComprehensiveCollector (1-6) - Console/Network/JS监控
├── PerformanceAnalyzer (1-7) - 基线分析和趋势
└── BrowserFairyService (1-8) - 完整服务协调器

Independent Chrome Instance (临时用户数据目录)
    ↓ WebSocket Connection (127.0.0.1:9222)
Monitor Components
    ↓ Real-time Data Processing  
JSONL Data Files (~/BrowserFairyData/)
    → Organized by Website/Session
```

### 核心组件设计

1. **ChromeInstanceManager** - 独立Chrome实例管理器
   - 自动启动专门Chrome实例（用户数据目录隔离）
   - 跨平台Chrome路径检测（macOS/Windows）
   - 端口冲突重试和资源清理
   - 生命周期绑定（Chrome关闭=监控停止）

2. **ChromeConnector** - CDP连接管理器  
   - WebSocket连接和重连机制（指数退避）
   - 连接丢失回调和状态管理
   - 跨平台错误提示和诊断

3. **TabMonitor** - 标签页监控器
   - 事件监听 + 轮询兜底机制
   - URL变化和domain识别
   - 状态一致性并发保护
   - 回调机制输出（职责分离）

4. **MemoryMonitor** - 内存数据收集器
   - 每个Target独立CDP session
   - JS heap, DOM节点, 事件监听器监控
   - 按网站维度数据分离

5. **DataManager** - 数据管理和存储监控器
   - 按网站维度组织JSONL文件
   - IndexedDB配额和存储监控
   - 数据完整性保证和会话管理

6. **ComprehensiveCollector** - 综合监控器
   - Console日志收集和分类
   - 网络请求监控（>1MB标记）
   - JavaScript执行性能追踪

7. **PerformanceAnalyzer** - 性能基线分析器
   - 网站性能基线建立
   - 趋势分析和异常检测
   - 跨站点影响分析

8. **BrowserFairyService** - 完整服务协调器
   - 一键启动监控流程
   - 组件生命周期管理
   - 用户友好的状态显示

### 数据存储结构
```
~/BrowserFairyData/
├── session_2025-01-15_143022/
│   ├── overview.json              # 会话概览和元数据
│   ├── example.com/
│   │   ├── memory.jsonl          # 内存监控时序数据
│   │   ├── network.jsonl         # 网络请求详细日志
│   │   ├── console.jsonl         # Console日志和错误
│   │   ├── storage.jsonl         # IndexedDB配额监控
│   │   └── performance.jsonl     # 性能指标和基线
│   └── trading.example.com/
│       ├── memory.jsonl          # 针对5.2M JSON问题的重点监控
│       ├── network.jsonl         # 大数据请求标记
│       └── ...
└── session_2025-01-15_180033/
    └── ...
```

### 关键技术实现

**独立Chrome实例管理**:
- 临时用户数据目录完全隔离用户Chrome
- 自动端口分配和冲突重试（9222+）
- 跨平台Chrome路径检测和环境变量覆盖
- 强制本地绑定（127.0.0.1）和安全参数

**Chrome DevTools Protocol集成**:
- Target.attachToTarget建立个人会话
- Runtime.evaluate获取JS heap和内存信息
- Storage.getUsageAndQuota监控IndexedDB配额
- Runtime.consoleAPICalled捕获所有日志
- Network.requestWillBeSent监控大数据请求

**多标签页数据分离**:
- 每个Target独立CDP session和数据收集器
- 通过hostname和origin按网站维度分离
- 处理SPA路由变化和domain变化
- 状态一致性锁保护并发竞态

**实时数据处理**:
- 每5秒采集性能快照
- 异常事件（错误、大内存、长任务）立即记录
- JSONL格式时序数据便于AI分析
- 异步IO确保Chrome性能不受影响

**跨站点关联分析**:
- 时间戳对齐的跨网站数据关联
- 内存压力和网络请求的时序关系
- 多标签页资源竞争识别

## Tests

### 单元测试 (pytest)
1. **ChromeInstanceManager测试**
   - macOS/Windows Chrome路径检测
   - 端口冲突重试和资源清理
   - 独立用户数据目录隔离
   - 生命周期绑定和异常处理

2. **ChromeConnector测试**
   - WebSocket连接建立和重连机制
   - 连接丢失回调和状态管理
   - 指数退避重试逻辑

3. **TabMonitor测试**
   - 标签页事件处理和状态同步
   - URL变化和domain识别
   - 并发状态一致性保护
   - 回调机制和职责分离

4. **MemoryMonitor测试**
   - Target级CDP session管理
   - JS heap和内存指标收集
   - 按网站维度数据分离

5. **DataManager测试**
   - JSONL文件写入和组织
   - IndexedDB配额监控
   - 会话管理和数据完整性

6. **ComprehensiveCollector测试**
   - Console日志收集和分类
   - 网络请求监控（>1MB标记）
   - JavaScript执行性能追踪

### 集成测试（需要Chrome安装）
1. **独立Chrome实例测试**
   - 自动启动和生命周期管理
   - 用户数据目录完全隔离
   - 端口自动分配和冲突处理

2. **端到端监控测试**
   - 完整监控流程验证
   - 实际网站数据收集
   - 多组件协调工作

3. **性能基准测试**
   - 监控工具CPU/内存占用（<2% CPU, <50MB内存）
   - Chrome性能影响最小化
   - 长时间运行稳定性（24小时）

### 功能验证测试
1. **5.2M JSON问题模拟**
   - 创建大数据IndexedDB操作场景
   - 验证存储配额监控和内存关联
   - 大数据请求标记和网络监控

2. **多网站监控测试**
   - 同时打开多个网站（交易系统、仪表板）
   - 验证按网站维度数据分离
   - 跨站点影响分析

3. **用户场景测试**
   - 模拟真实交易系统使用
   - 长时间浏览和性能下降模拟
   - Chrome关闭时的优雅停止

### 数据分析测试
1. **输出格式验证**
   - JSONL格式符合AI分析需求
   - 时间戳对齐和元数据完整性
   - 跨文件数据关联正确性

2. **异常场景处理**
   - Chrome崩溃时的资源清理
   - 独立实例启动失败处理
   - 磁盘空间不足优雅降级

### 跨平台测试
- **macOS优先**：完整功能测试和性能基准
- **Windows次要**：基础功能验证和兼容性

**测试覆盖率目标**: >90%
**性能基准**: 监控工具CPU占用 <2%, 内存占用 <50MB, 独立Chrome实例<200MB额外内存