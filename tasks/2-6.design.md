# Design 2-6

## Requirements

- **核心需求**：将Source Map和源代码文件持久化存储到本地，替代当前的纯内存缓存机制
- **存储结构**：按网站维度组织，创建`source_maps/`和`sources/`目录存储相关文件
- **数据完整性**：保存Source Map原始JSON、sourcesContent中的源代码文件、scriptId映射关系
- **AI分析增强**：为后续AI分析提供完整的源代码上下文，支持深度代码分析和问题诊断
- **向后兼容**：保持现有异常堆栈增强功能不变，仅增加持久化存储能力
- **性能要求**：不影响现有监控性能，异步写入文件，避免阻塞主监控流程

## Solution

### 1. 增强SourceMapResolver类 - 自管理持久化

**核心修改点**：在`_get_source_map()`方法的177行后增加持久化逻辑

**新增属性**：
```python
# 在__init__方法中添加
self.hostname = None  # 由ConsoleMonitor设置
self.persistence_semaphore = asyncio.Semaphore(2)  # 并发控制
```

**新增方法**：
```python
def set_hostname(self, hostname: str) -> None:
    """设置hostname用于确定存储路径"""
    self.hostname = hostname

async def _persist_source_map_async(self, script_id: str, source_map_url: str,
                                   source_map_content: str, source_map: Any) -> None:
    """异步持久化source map和源文件（完全自管理，零耦合）"""
    if not self.hostname:
        return
        
    async with self.persistence_semaphore:
        try:
            # 使用 asyncio.to_thread 执行文件操作
            # 路径: get_data_directory() + session_dir + hostname + source_maps/
            await asyncio.to_thread(self._write_source_map_files, 
                                  script_id, source_map_url, source_map_content, source_map)
        except Exception as e:
            logger.warning(f"Source map persistence failed: {e}")

def _write_source_map_files(self, script_id: str, source_map_url: str, 
                           source_map_content: str, source_map: Any) -> None:
    """同步文件写入逻辑（在thread中执行）"""
    # 写入source map JSON文件
    # 提取并写入sourcesContent源文件  
    # 更新metadata记录
```

**集成点修改**：
```python
# 在 _get_source_map() 第177行 source_map = sourcemap.loads(source_map_content) 后添加：
if self.hostname:
    # 异步持久化，不等待完成，不阻塞主流程
    asyncio.create_task(self._persist_source_map_async(
        # 需要传递script_id，从script_metadata中获取
        script_id, source_map_url, source_map_content, source_map
    ))
```

### 2. 自动会话目录发现 - 零耦合方案

**SourceMapResolver自动发现会话目录**：
```python
def _get_current_session_dir(self) -> Optional[Path]:
    """自动发现当前会话目录（最新创建的session_*目录）"""
    from ..utils.paths import get_data_directory
    data_dir = get_data_directory()
    
    # 查找最新的session_*目录
    session_dirs = list(data_dir.glob("session_*"))
    if not session_dirs:
        return None
    
    # 按创建时间排序，返回最新的
    latest_session = max(session_dirs, key=lambda p: p.stat().st_ctime)
    return latest_session
```

**目录结构**（与DataManager完全一致）：
```
~/BrowserFairyData/session_YYYY-MM-DD_HHMMSS/
├── example.com/
│   ├── console.jsonl           # DataManager管理
│   ├── memory.jsonl           # DataManager管理  
│   ├── source_maps/           # SourceMapResolver自管理
│   │   ├── script_ABC123.map.json     # Source Map原始JSON
│   │   └── metadata.jsonl             # scriptId映射记录
│   └── sources/               # SourceMapResolver自管理
│       └── src_app.js         # 扁平化文件名
```

### 3. ConsoleMonitor集成 - 零参数变化

**在ConsoleMonitor的start_monitoring方法第48行后添加**：
```python
if self.source_map_resolver and self.hostname:
    # 设置hostname用于持久化路径确定
    self.source_map_resolver.set_hostname(self.hostname)
```

**无需修改ConsoleMonitor构造函数** - 完全向后兼容

### 4. 文件格式设计 - 简单JSON

**Source Map文件** (`script_ABC123.map.json`)：
```json
{
  "sourceMapUrl": "https://example.com/app.js.map",
  "scriptUrl": "https://example.com/app.min.js", 
  "sourceMap": { /* 原始source map JSON */ },
  "timestamp": "2025-08-20T10:30:00Z"
}
```

**元数据文件** (`metadata.jsonl`)：
```jsonl
{"scriptId":"script_ABC123","sourceMapFile":"script_ABC123.map.json","scriptUrl":"https://example.com/app.min.js","timestamp":"2025-08-20T10:30:00Z"}
```

**源文件命名**：使用安全的文件名转换
- `src/app.js` → `src_app.js` 
- `components/Button.jsx` → `components_Button.jsx`

### 5. TDD测试驱动设计

**测试优先级**：
1. **SourceMapResolver.set_data_manager()** - 数据管理器设置
2. **DataManager.write_source_map_data()** - 文件写入逻辑  
3. **Source map持久化集成测试** - 端到端流程
4. **向后兼容测试** - 确保现有功能不受影响
5. **错误处理测试** - 文件写入失败的优雅降级

**最小可测试单元**：
- 每个新方法独立可测试
- 文件写入使用临时目录
- 异步任务完成验证机制

## Tests

### 1. SourceMapResolver单元测试

**test_source_map_persistence.py**：
```python
async def test_set_data_manager():
    """测试数据管理器设置"""
    # 验证 set_data_manager 正确设置属性
    
async def test_persist_source_map_async_with_sources_content():
    """测试完整持久化流程（含sourcesContent）"""
    # 模拟有sourcesContent的source map
    # 验证source map文件和源文件都被保存
    
async def test_persist_source_map_async_without_sources():
    """测试无sourcesContent的持久化"""
    # 验证只保存source map，不创建sources目录
```

### 2. 会话目录发现测试

**test_source_map_session_discovery.py**：
```python
async def test_get_current_session_dir():
    """测试会话目录自动发现"""
    # 创建多个session目录
    # 验证返回最新创建的目录
    
async def test_get_current_session_dir_no_sessions():
    """测试无session目录时的处理"""
    # 验证返回None且不抛出异常
```

### 3. ConsoleMonitor零侵入集成测试

**扩展test_console_source_map.py**：
```python
async def test_console_monitor_set_hostname():
    """测试ConsoleMonitor设置hostname"""
    # 验证source_map_resolver.set_hostname被调用
    # 确保只在有resolver和hostname时调用
    
async def test_backward_compatibility_unchanged():
    """测试完全向后兼容"""
    # 验证无任何构造函数参数变化
    # 确保现有功能完全不受影响
```

### 4. 端到端集成测试

**test_source_map_integration.py**：
```python
async def test_end_to_end_persistence():
    """完整流程测试：脚本解析→异常→持久化"""
    # 模拟 Debugger.scriptParsed 事件
    # 触发异常处理
    # 验证文件被正确保存
    
async def test_multiple_sites_isolation():
    """测试多站点数据隔离"""
    # 验证不同hostname的source map分别存储
```

### 5. 性能和错误处理测试

**test_source_map_performance.py**：
```python
async def test_async_persistence_non_blocking():
    """测试异步持久化不阻塞异常处理"""
    # 验证 asyncio.create_task 正确使用
    
async def test_persistence_failure_graceful_degradation():
    """测试持久化失败的优雅降级"""
    # 文件写入失败时，内存缓存功能不受影响
```

### 测试数据准备

**fixtures/source_maps/**：
```python
# 真实的source map示例
SAMPLE_SOURCE_MAP_WITH_SOURCES = {
    "version": 3,
    "sources": ["src/app.js", "src/utils.js"],
    "sourcesContent": ["const app = () => {...}", "const utils = {...}"],
    "mappings": "AAAA,SAAS..."
}

SAMPLE_SOURCE_MAP_WITHOUT_SOURCES = {
    "version": 3, 
    "sources": ["src/app.js"],
    "mappings": "AAAA,SAAS..."
}
```